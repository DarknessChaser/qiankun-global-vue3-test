/* eslint-disable */
export default 'var Vue = (function (exports) {\n  \'use strict\';\n\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   * IMPORTANT: all calls of this function must be prefixed with\n   * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n   * So that rollup can tree-shake them if necessary.\n   */\n  function makeMap(str, expectsLowerCase) {\n      const map = Object.create(null);\n      const list = str.split(\',\');\n      for (let i = 0; i < list.length; i++) {\n          map[list[i]] = true;\n      }\n      return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n  }\n\n  // Patch flags are optimization hints generated by the compiler.\n  // when a block with dynamicChildren is encountered during diff, the algorithm\n  // enters "optimized mode". In this mode, we know that the vdom is produced by\n  // a render function generated by the compiler, so the algorithm only needs to\n  // handle updates explicitly marked by these patch flags.\n  // dev only flag -> name mapping\n  const PatchFlagNames = {\n      [1 /* TEXT */]: `TEXT`,\n      [2 /* CLASS */]: `CLASS`,\n      [4 /* STYLE */]: `STYLE`,\n      [8 /* PROPS */]: `PROPS`,\n      [16 /* FULL_PROPS */]: `FULL_PROPS`,\n      [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\n      [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\n      [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\n      [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\n      [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\n      [512 /* NEED_PATCH */]: `NEED_PATCH`,\n      [-1 /* HOISTED */]: `HOISTED`,\n      [-2 /* BAIL */]: `BAIL`\n  };\n\n  const GLOBALS_WHITE_LISTED = \'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,\' +\n      \'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,\' +\n      \'Object,Boolean,String,RegExp,Map,Set,JSON,Intl\';\n  const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\n  const range = 2;\n  function generateCodeFrame(source, start = 0, end = source.length) {\n      const lines = source.split(/\\r?\\n/);\n      let count = 0;\n      const res = [];\n      for (let i = 0; i < lines.length; i++) {\n          count += lines[i].length + 1;\n          if (count >= start) {\n              for (let j = i - range; j <= i + range || end > count; j++) {\n                  if (j < 0 || j >= lines.length)\n                      continue;\n                  const line = j + 1;\n                  res.push(`${line}${\' \'.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n                  const lineLength = lines[j].length;\n                  if (j === i) {\n                      // push underline\n                      const pad = start - (count - lineLength) + 1;\n                      const length = Math.max(1, end > count ? lineLength - pad : end - start);\n                      res.push(`   |  ` + \' \'.repeat(pad) + \'^\'.repeat(length));\n                  }\n                  else if (j > i) {\n                      if (end > count) {\n                          const length = Math.max(Math.min(end - count, lineLength), 1);\n                          res.push(`   |  ` + \'^\'.repeat(length));\n                      }\n                      count += lineLength + 1;\n                  }\n              }\n              break;\n          }\n      }\n      return res.join(\'\\n\');\n  }\n\n  /**\n   * On the client we only need to offer special cases for boolean attributes that\n   * have different names from their corresponding dom properties:\n   * - itemscope -> N/A\n   * - allowfullscreen -> allowFullscreen\n   * - formnovalidate -> formNoValidate\n   * - ismap -> isMap\n   * - nomodule -> noModule\n   * - novalidate -> noValidate\n   * - readonly -> readOnly\n   */\n  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\n  const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\n\n  function normalizeStyle(value) {\n      if (isArray(value)) {\n          const res = {};\n          for (let i = 0; i < value.length; i++) {\n              const item = value[i];\n              const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\n              if (normalized) {\n                  for (const key in normalized) {\n                      res[key] = normalized[key];\n                  }\n              }\n          }\n          return res;\n      }\n      else if (isObject(value)) {\n          return value;\n      }\n  }\n  const listDelimiterRE = /;(?![^(]*\\))/g;\n  const propertyDelimiterRE = /:(.+)/;\n  function parseStringStyle(cssText) {\n      const ret = {};\n      cssText.split(listDelimiterRE).forEach(item => {\n          if (item) {\n              const tmp = item.split(propertyDelimiterRE);\n              tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n          }\n      });\n      return ret;\n  }\n  function normalizeClass(value) {\n      let res = \'\';\n      if (isString(value)) {\n          res = value;\n      }\n      else if (isArray(value)) {\n          for (let i = 0; i < value.length; i++) {\n              res += normalizeClass(value[i]) + \' \';\n          }\n      }\n      else if (isObject(value)) {\n          for (const name in value) {\n              if (value[name]) {\n                  res += name + \' \';\n              }\n          }\n      }\n      return res.trim();\n  }\n\n  // These tag configs are shared between compiler-dom and runtime-dom, so they\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n  const HTML_TAGS = \'html,body,base,head,link,meta,style,title,address,article,aside,footer,\' +\n      \'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,\' +\n      \'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,\' +\n      \'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,\' +\n      \'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,\' +\n      \'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,\' +\n      \'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,\' +\n      \'option,output,progress,select,textarea,details,dialog,menu,\' +\n      \'summary,template,blockquote,iframe,tfoot\';\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Element\n  const SVG_TAGS = \'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,\' +\n      \'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,\' +\n      \'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,\' +\n      \'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,\' +\n      \'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,\' +\n      \'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,\' +\n      \'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,\' +\n      \'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,\' +\n      \'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,\' +\n      \'text,textPath,title,tspan,unknown,use,view\';\n  const VOID_TAGS = \'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\';\n  const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\n  const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\n  const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\n  function looseCompareArrays(a, b) {\n      if (a.length !== b.length)\n          return false;\n      let equal = true;\n      for (let i = 0; equal && i < a.length; i++) {\n          equal = looseEqual(a[i], b[i]);\n      }\n      return equal;\n  }\n  function looseEqual(a, b) {\n      if (a === b)\n          return true;\n      let aValidType = isDate(a);\n      let bValidType = isDate(b);\n      if (aValidType || bValidType) {\n          return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n      }\n      aValidType = isArray(a);\n      bValidType = isArray(b);\n      if (aValidType || bValidType) {\n          return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n      }\n      aValidType = isObject(a);\n      bValidType = isObject(b);\n      if (aValidType || bValidType) {\n          /* istanbul ignore if: this if will probably never be called */\n          if (!aValidType || !bValidType) {\n              return false;\n          }\n          const aKeysCount = Object.keys(a).length;\n          const bKeysCount = Object.keys(b).length;\n          if (aKeysCount !== bKeysCount) {\n              return false;\n          }\n          for (const key in a) {\n              const aHasKey = a.hasOwnProperty(key);\n              const bHasKey = b.hasOwnProperty(key);\n              if ((aHasKey && !bHasKey) ||\n                  (!aHasKey && bHasKey) ||\n                  !looseEqual(a[key], b[key])) {\n                  return false;\n              }\n          }\n      }\n      return String(a) === String(b);\n  }\n  function looseIndexOf(arr, val) {\n      return arr.findIndex(item => looseEqual(item, val));\n  }\n\n  /**\n   * For converting {{ interpolation }} values to displayed strings.\n   * @private\n   */\n  const toDisplayString = (val) => {\n      return val == null\n          ? \'\'\n          : isObject(val)\n              ? JSON.stringify(val, replacer, 2)\n              : String(val);\n  };\n  const replacer = (_key, val) => {\n      if (isMap(val)) {\n          return {\n              [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\n                  entries[`${key} =>`] = val;\n                  return entries;\n              }, {})\n          };\n      }\n      else if (isSet(val)) {\n          return {\n              [`Set(${val.size})`]: [...val.values()]\n          };\n      }\n      else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n          return String(val);\n      }\n      return val;\n  };\n\n  const EMPTY_OBJ =  Object.freeze({})\n      ;\n  const EMPTY_ARR =  Object.freeze([]) ;\n  const NOOP = () => { };\n  /**\n   * Always return false.\n   */\n  const NO = () => false;\n  const onRE = /^on[^a-z]/;\n  const isOn = (key) => onRE.test(key);\n  const isModelListener = (key) => key.startsWith(\'onUpdate:\');\n  const extend = Object.assign;\n  const remove = (arr, el) => {\n      const i = arr.indexOf(el);\n      if (i > -1) {\n          arr.splice(i, 1);\n      }\n  };\n  const hasOwnProperty = Object.prototype.hasOwnProperty;\n  const hasOwn = (val, key) => hasOwnProperty.call(val, key);\n  const isArray = Array.isArray;\n  const isMap = (val) => toTypeString(val) === \'[object Map]\';\n  const isSet = (val) => toTypeString(val) === \'[object Set]\';\n  const isDate = (val) => val instanceof Date;\n  const isFunction = (val) => typeof val === \'function\';\n  const isString = (val) => typeof val === \'string\';\n  const isSymbol = (val) => typeof val === \'symbol\';\n  const isObject = (val) => val !== null && typeof val === \'object\';\n  const isPromise = (val) => {\n      return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n  };\n  const objectToString = Object.prototype.toString;\n  const toTypeString = (value) => objectToString.call(value);\n  const toRawType = (value) => {\n      // extract "RawType" from strings like "[object RawType]"\n      return toTypeString(value).slice(8, -1);\n  };\n  const isPlainObject = (val) => toTypeString(val) === \'[object Object]\';\n  const isIntegerKey = (key) => isString(key) &&\n      key !== \'NaN\' &&\n      key[0] !== \'-\' &&\n      \'\' + parseInt(key, 10) === key;\n  const isReservedProp = /*#__PURE__*/ makeMap(\n  // the leading comma is intentional so empty string "" is also included\n  \',key,ref,\' +\n      \'onVnodeBeforeMount,onVnodeMounted,\' +\n      \'onVnodeBeforeUpdate,onVnodeUpdated,\' +\n      \'onVnodeBeforeUnmount,onVnodeUnmounted\');\n  const cacheStringFunction = (fn) => {\n      const cache = Object.create(null);\n      return ((str) => {\n          const hit = cache[str];\n          return hit || (cache[str] = fn(str));\n      });\n  };\n  const camelizeRE = /-(\\w)/g;\n  /**\n   * @private\n   */\n  const camelize = cacheStringFunction((str) => {\n      return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : \'\'));\n  });\n  const hyphenateRE = /\\B([A-Z])/g;\n  /**\n   * @private\n   */\n  const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \'-$1\').toLowerCase());\n  /**\n   * @private\n   */\n  const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\n  /**\n   * @private\n   */\n  const toHandlerKey = cacheStringFunction((str) => (str ? `on${capitalize(str)}` : ``));\n  // compare whether a value has changed, accounting for NaN.\n  const hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\n  const invokeArrayFns = (fns, arg) => {\n      for (let i = 0; i < fns.length; i++) {\n          fns[i](arg);\n      }\n  };\n  const def = (obj, key, value) => {\n      Object.defineProperty(obj, key, {\n          configurable: true,\n          enumerable: false,\n          value\n      });\n  };\n  const toNumber = (val) => {\n      const n = parseFloat(val);\n      return isNaN(n) ? val : n;\n  };\n  let _globalThis;\n  const getGlobalThis = () => {\n      return (_globalThis ||\n          (_globalThis =\n              typeof globalThis !== \'undefined\'\n                  ? globalThis\n                  : typeof self !== \'undefined\'\n                      ? self\n                      : typeof window !== \'undefined\'\n                          ? window\n                          : typeof global !== \'undefined\'\n                              ? global\n                              : {}));\n  };\n\n  const targetMap = new WeakMap();\n  const effectStack = [];\n  let activeEffect;\n  const ITERATE_KEY = Symbol( \'iterate\' );\n  const MAP_KEY_ITERATE_KEY = Symbol( \'Map key iterate\' );\n  function isEffect(fn) {\n      return fn && fn._isEffect === true;\n  }\n  function effect(fn, options = EMPTY_OBJ) {\n      if (isEffect(fn)) {\n          fn = fn.raw;\n      }\n      const effect = createReactiveEffect(fn, options);\n      if (!options.lazy) {\n          effect();\n      }\n      return effect;\n  }\n  function stop(effect) {\n      if (effect.active) {\n          cleanup(effect);\n          if (effect.options.onStop) {\n              effect.options.onStop();\n          }\n          effect.active = false;\n      }\n  }\n  let uid = 0;\n  function createReactiveEffect(fn, options) {\n      const effect = function reactiveEffect() {\n          if (!effect.active) {\n              return options.scheduler ? undefined : fn();\n          }\n          if (!effectStack.includes(effect)) {\n              cleanup(effect);\n              try {\n                  enableTracking();\n                  effectStack.push(effect);\n                  activeEffect = effect;\n                  return fn();\n              }\n              finally {\n                  effectStack.pop();\n                  resetTracking();\n                  activeEffect = effectStack[effectStack.length - 1];\n              }\n          }\n      };\n      effect.id = uid++;\n      effect.allowRecurse = !!options.allowRecurse;\n      effect._isEffect = true;\n      effect.active = true;\n      effect.raw = fn;\n      effect.deps = [];\n      effect.options = options;\n      return effect;\n  }\n  function cleanup(effect) {\n      const { deps } = effect;\n      if (deps.length) {\n          for (let i = 0; i < deps.length; i++) {\n              deps[i].delete(effect);\n          }\n          deps.length = 0;\n      }\n  }\n  let shouldTrack = true;\n  const trackStack = [];\n  function pauseTracking() {\n      trackStack.push(shouldTrack);\n      shouldTrack = false;\n  }\n  function enableTracking() {\n      trackStack.push(shouldTrack);\n      shouldTrack = true;\n  }\n  function resetTracking() {\n      const last = trackStack.pop();\n      shouldTrack = last === undefined ? true : last;\n  }\n  function track(target, type, key) {\n      if (!shouldTrack || activeEffect === undefined) {\n          return;\n      }\n      let depsMap = targetMap.get(target);\n      if (!depsMap) {\n          targetMap.set(target, (depsMap = new Map()));\n      }\n      let dep = depsMap.get(key);\n      if (!dep) {\n          depsMap.set(key, (dep = new Set()));\n      }\n      if (!dep.has(activeEffect)) {\n          dep.add(activeEffect);\n          activeEffect.deps.push(dep);\n          if ( activeEffect.options.onTrack) {\n              activeEffect.options.onTrack({\n                  effect: activeEffect,\n                  target,\n                  type,\n                  key\n              });\n          }\n      }\n  }\n  function trigger(target, type, key, newValue, oldValue, oldTarget) {\n      const depsMap = targetMap.get(target);\n      if (!depsMap) {\n          // never been tracked\n          return;\n      }\n      const effects = new Set();\n      const add = (effectsToAdd) => {\n          if (effectsToAdd) {\n              effectsToAdd.forEach(effect => {\n                  if (effect !== activeEffect || effect.allowRecurse) {\n                      effects.add(effect);\n                  }\n              });\n          }\n      };\n      if (type === "clear" /* CLEAR */) {\n          // collection being cleared\n          // trigger all effects for target\n          depsMap.forEach(add);\n      }\n      else if (key === \'length\' && isArray(target)) {\n          depsMap.forEach((dep, key) => {\n              if (key === \'length\' || key >= newValue) {\n                  add(dep);\n              }\n          });\n      }\n      else {\n          // schedule runs for SET | ADD | DELETE\n          if (key !== void 0) {\n              add(depsMap.get(key));\n          }\n          // also run for iteration key on ADD | DELETE | Map.SET\n          switch (type) {\n              case "add" /* ADD */:\n                  if (!isArray(target)) {\n                      add(depsMap.get(ITERATE_KEY));\n                      if (isMap(target)) {\n                          add(depsMap.get(MAP_KEY_ITERATE_KEY));\n                      }\n                  }\n                  else if (isIntegerKey(key)) {\n                      // new index added to array -> length changes\n                      add(depsMap.get(\'length\'));\n                  }\n                  break;\n              case "delete" /* DELETE */:\n                  if (!isArray(target)) {\n                      add(depsMap.get(ITERATE_KEY));\n                      if (isMap(target)) {\n                          add(depsMap.get(MAP_KEY_ITERATE_KEY));\n                      }\n                  }\n                  break;\n              case "set" /* SET */:\n                  if (isMap(target)) {\n                      add(depsMap.get(ITERATE_KEY));\n                  }\n                  break;\n          }\n      }\n      const run = (effect) => {\n          if ( effect.options.onTrigger) {\n              effect.options.onTrigger({\n                  effect,\n                  target,\n                  key,\n                  type,\n                  newValue,\n                  oldValue,\n                  oldTarget\n              });\n          }\n          if (effect.options.scheduler) {\n              effect.options.scheduler(effect);\n          }\n          else {\n              effect();\n          }\n      };\n      effects.forEach(run);\n  }\n\n  const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\n      .map(key => Symbol[key])\n      .filter(isSymbol));\n  const get = /*#__PURE__*/ createGetter();\n  const shallowGet = /*#__PURE__*/ createGetter(false, true);\n  const readonlyGet = /*#__PURE__*/ createGetter(true);\n  const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\n  const arrayInstrumentations = {};\n  [\'includes\', \'indexOf\', \'lastIndexOf\'].forEach(key => {\n      const method = Array.prototype[key];\n      arrayInstrumentations[key] = function (...args) {\n          const arr = toRaw(this);\n          for (let i = 0, l = this.length; i < l; i++) {\n              track(arr, "get" /* GET */, i + \'\');\n          }\n          // we run the method using the original args first (which may be reactive)\n          const res = method.apply(arr, args);\n          if (res === -1 || res === false) {\n              // if that didn\'t work, run it again using raw values.\n              return method.apply(arr, args.map(toRaw));\n          }\n          else {\n              return res;\n          }\n      };\n  });\n  [\'push\', \'pop\', \'shift\', \'unshift\', \'splice\'].forEach(key => {\n      const method = Array.prototype[key];\n      arrayInstrumentations[key] = function (...args) {\n          pauseTracking();\n          const res = method.apply(this, args);\n          resetTracking();\n          return res;\n      };\n  });\n  function createGetter(isReadonly = false, shallow = false) {\n      return function get(target, key, receiver) {\n          if (key === "__v_isReactive" /* IS_REACTIVE */) {\n              return !isReadonly;\n          }\n          else if (key === "__v_isReadonly" /* IS_READONLY */) {\n              return isReadonly;\n          }\n          else if (key === "__v_raw" /* RAW */ &&\n              receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {\n              return target;\n          }\n          const targetIsArray = isArray(target);\n          if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n              return Reflect.get(arrayInstrumentations, key, receiver);\n          }\n          const res = Reflect.get(target, key, receiver);\n          if (isSymbol(key)\n              ? builtInSymbols.has(key)\n              : key === `__proto__` || key === `__v_isRef`) {\n              return res;\n          }\n          if (!isReadonly) {\n              track(target, "get" /* GET */, key);\n          }\n          if (shallow) {\n              return res;\n          }\n          if (isRef(res)) {\n              // ref unwrapping - does not apply for Array + integer key.\n              const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\n              return shouldUnwrap ? res.value : res;\n          }\n          if (isObject(res)) {\n              // Convert returned value into a proxy as well. we do the isObject check\n              // here to avoid invalid value warning. Also need to lazy access readonly\n              // and reactive here to avoid circular dependency.\n              return isReadonly ? readonly(res) : reactive(res);\n          }\n          return res;\n      };\n  }\n  const set = /*#__PURE__*/ createSetter();\n  const shallowSet = /*#__PURE__*/ createSetter(true);\n  function createSetter(shallow = false) {\n      return function set(target, key, value, receiver) {\n          const oldValue = target[key];\n          if (!shallow) {\n              value = toRaw(value);\n              if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n                  oldValue.value = value;\n                  return true;\n              }\n          }\n          const hadKey = isArray(target) && isIntegerKey(key)\n              ? Number(key) < target.length\n              : hasOwn(target, key);\n          const result = Reflect.set(target, key, value, receiver);\n          // don\'t trigger if target is something up in the prototype chain of original\n          if (target === toRaw(receiver)) {\n              if (!hadKey) {\n                  trigger(target, "add" /* ADD */, key, value);\n              }\n              else if (hasChanged(value, oldValue)) {\n                  trigger(target, "set" /* SET */, key, value, oldValue);\n              }\n          }\n          return result;\n      };\n  }\n  function deleteProperty(target, key) {\n      const hadKey = hasOwn(target, key);\n      const oldValue = target[key];\n      const result = Reflect.deleteProperty(target, key);\n      if (result && hadKey) {\n          trigger(target, "delete" /* DELETE */, key, undefined, oldValue);\n      }\n      return result;\n  }\n  function has(target, key) {\n      const result = Reflect.has(target, key);\n      if (!isSymbol(key) || !builtInSymbols.has(key)) {\n          track(target, "has" /* HAS */, key);\n      }\n      return result;\n  }\n  function ownKeys(target) {\n      track(target, "iterate" /* ITERATE */, isArray(target) ? \'length\' : ITERATE_KEY);\n      return Reflect.ownKeys(target);\n  }\n  const mutableHandlers = {\n      get,\n      set,\n      deleteProperty,\n      has,\n      ownKeys\n  };\n  const readonlyHandlers = {\n      get: readonlyGet,\n      set(target, key) {\n          {\n              console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);\n          }\n          return true;\n      },\n      deleteProperty(target, key) {\n          {\n              console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);\n          }\n          return true;\n      }\n  };\n  const shallowReactiveHandlers = extend({}, mutableHandlers, {\n      get: shallowGet,\n      set: shallowSet\n  });\n  // Props handlers are special in the sense that it should not unwrap top-level\n  // refs (in order to allow refs to be explicitly passed down), but should\n  // retain the reactivity of the normal readonly object.\n  const shallowReadonlyHandlers = extend({}, readonlyHandlers, {\n      get: shallowReadonlyGet\n  });\n\n  const toReactive = (value) => isObject(value) ? reactive(value) : value;\n  const toReadonly = (value) => isObject(value) ? readonly(value) : value;\n  const toShallow = (value) => value;\n  const getProto = (v) => Reflect.getPrototypeOf(v);\n  function get$1(target, key, isReadonly = false, isShallow = false) {\n      // #1772: readonly(reactive(Map)) should return readonly + reactive version\n      // of the value\n      target = target["__v_raw" /* RAW */];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (key !== rawKey) {\n          !isReadonly && track(rawTarget, "get" /* GET */, key);\n      }\n      !isReadonly && track(rawTarget, "get" /* GET */, rawKey);\n      const { has } = getProto(rawTarget);\n      const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\n      if (has.call(rawTarget, key)) {\n          return wrap(target.get(key));\n      }\n      else if (has.call(rawTarget, rawKey)) {\n          return wrap(target.get(rawKey));\n      }\n  }\n  function has$1(key, isReadonly = false) {\n      const target = this["__v_raw" /* RAW */];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (key !== rawKey) {\n          !isReadonly && track(rawTarget, "has" /* HAS */, key);\n      }\n      !isReadonly && track(rawTarget, "has" /* HAS */, rawKey);\n      return key === rawKey\n          ? target.has(key)\n          : target.has(key) || target.has(rawKey);\n  }\n  function size(target, isReadonly = false) {\n      target = target["__v_raw" /* RAW */];\n      !isReadonly && track(toRaw(target), "iterate" /* ITERATE */, ITERATE_KEY);\n      return Reflect.get(target, \'size\', target);\n  }\n  function add(value) {\n      value = toRaw(value);\n      const target = toRaw(this);\n      const proto = getProto(target);\n      const hadKey = proto.has.call(target, value);\n      const result = target.add(value);\n      if (!hadKey) {\n          trigger(target, "add" /* ADD */, value, value);\n      }\n      return result;\n  }\n  function set$1(key, value) {\n      value = toRaw(value);\n      const target = toRaw(this);\n      const { has, get } = getProto(target);\n      let hadKey = has.call(target, key);\n      if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n      }\n      else {\n          checkIdentityKeys(target, has, key);\n      }\n      const oldValue = get.call(target, key);\n      const result = target.set(key, value);\n      if (!hadKey) {\n          trigger(target, "add" /* ADD */, key, value);\n      }\n      else if (hasChanged(value, oldValue)) {\n          trigger(target, "set" /* SET */, key, value, oldValue);\n      }\n      return result;\n  }\n  function deleteEntry(key) {\n      const target = toRaw(this);\n      const { has, get } = getProto(target);\n      let hadKey = has.call(target, key);\n      if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n      }\n      else {\n          checkIdentityKeys(target, has, key);\n      }\n      const oldValue = get ? get.call(target, key) : undefined;\n      // forward the operation before queueing reactions\n      const result = target.delete(key);\n      if (hadKey) {\n          trigger(target, "delete" /* DELETE */, key, undefined, oldValue);\n      }\n      return result;\n  }\n  function clear() {\n      const target = toRaw(this);\n      const hadItems = target.size !== 0;\n      const oldTarget =  isMap(target)\n              ? new Map(target)\n              : new Set(target)\n          ;\n      // forward the operation before queueing reactions\n      const result = target.clear();\n      if (hadItems) {\n          trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);\n      }\n      return result;\n  }\n  function createForEach(isReadonly, isShallow) {\n      return function forEach(callback, thisArg) {\n          const observed = this;\n          const target = observed["__v_raw" /* RAW */];\n          const rawTarget = toRaw(target);\n          const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\n          !isReadonly && track(rawTarget, "iterate" /* ITERATE */, ITERATE_KEY);\n          return target.forEach((value, key) => {\n              // important: make sure the callback is\n              // 1. invoked with the reactive map as `this` and 3rd arg\n              // 2. the value received should be a corresponding reactive/readonly.\n              return callback.call(thisArg, wrap(value), wrap(key), observed);\n          });\n      };\n  }\n  function createIterableMethod(method, isReadonly, isShallow) {\n      return function (...args) {\n          const target = this["__v_raw" /* RAW */];\n          const rawTarget = toRaw(target);\n          const targetIsMap = isMap(rawTarget);\n          const isPair = method === \'entries\' || (method === Symbol.iterator && targetIsMap);\n          const isKeyOnly = method === \'keys\' && targetIsMap;\n          const innerIterator = target[method](...args);\n          const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\n          !isReadonly &&\n              track(rawTarget, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n          // return a wrapped iterator which returns observed versions of the\n          // values emitted from the real iterator\n          return {\n              // iterator protocol\n              next() {\n                  const { value, done } = innerIterator.next();\n                  return done\n                      ? { value, done }\n                      : {\n                          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n                          done\n                      };\n              },\n              // iterable protocol\n              [Symbol.iterator]() {\n                  return this;\n              }\n          };\n      };\n  }\n  function createReadonlyMethod(type) {\n      return function (...args) {\n          {\n              const key = args[0] ? `on key "${args[0]}" ` : ``;\n              console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n          }\n          return type === "delete" /* DELETE */ ? false : this;\n      };\n  }\n  const mutableInstrumentations = {\n      get(key) {\n          return get$1(this, key);\n      },\n      get size() {\n          return size(this);\n      },\n      has: has$1,\n      add,\n      set: set$1,\n      delete: deleteEntry,\n      clear,\n      forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations = {\n      get(key) {\n          return get$1(this, key, false, true);\n      },\n      get size() {\n          return size(this);\n      },\n      has: has$1,\n      add,\n      set: set$1,\n      delete: deleteEntry,\n      clear,\n      forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations = {\n      get(key) {\n          return get$1(this, key, true);\n      },\n      get size() {\n          return size(this, true);\n      },\n      has(key) {\n          return has$1.call(this, key, true);\n      },\n      add: createReadonlyMethod("add" /* ADD */),\n      set: createReadonlyMethod("set" /* SET */),\n      delete: createReadonlyMethod("delete" /* DELETE */),\n      clear: createReadonlyMethod("clear" /* CLEAR */),\n      forEach: createForEach(true, false)\n  };\n  const iteratorMethods = [\'keys\', \'values\', \'entries\', Symbol.iterator];\n  iteratorMethods.forEach(method => {\n      mutableInstrumentations[method] = createIterableMethod(method, false, false);\n      readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n      shallowInstrumentations[method] = createIterableMethod(method, false, true);\n  });\n  function createInstrumentationGetter(isReadonly, shallow) {\n      const instrumentations = shallow\n          ? shallowInstrumentations\n          : isReadonly\n              ? readonlyInstrumentations\n              : mutableInstrumentations;\n      return (target, key, receiver) => {\n          if (key === "__v_isReactive" /* IS_REACTIVE */) {\n              return !isReadonly;\n          }\n          else if (key === "__v_isReadonly" /* IS_READONLY */) {\n              return isReadonly;\n          }\n          else if (key === "__v_raw" /* RAW */) {\n              return target;\n          }\n          return Reflect.get(hasOwn(instrumentations, key) && key in target\n              ? instrumentations\n              : target, key, receiver);\n      };\n  }\n  const mutableCollectionHandlers = {\n      get: createInstrumentationGetter(false, false)\n  };\n  const shallowCollectionHandlers = {\n      get: createInstrumentationGetter(false, true)\n  };\n  const readonlyCollectionHandlers = {\n      get: createInstrumentationGetter(true, false)\n  };\n  function checkIdentityKeys(target, has, key) {\n      const rawKey = toRaw(key);\n      if (rawKey !== key && has.call(target, rawKey)) {\n          const type = toRawType(target);\n          console.warn(`Reactive ${type} contains both the raw and reactive ` +\n              `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\n              `which can lead to inconsistencies. ` +\n              `Avoid differentiating between the raw and reactive versions ` +\n              `of an object and only use the reactive version if possible.`);\n      }\n  }\n\n  const reactiveMap = new WeakMap();\n  const readonlyMap = new WeakMap();\n  function targetTypeMap(rawType) {\n      switch (rawType) {\n          case \'Object\':\n          case \'Array\':\n              return 1 /* COMMON */;\n          case \'Map\':\n          case \'Set\':\n          case \'WeakMap\':\n          case \'WeakSet\':\n              return 2 /* COLLECTION */;\n          default:\n              return 0 /* INVALID */;\n      }\n  }\n  function getTargetType(value) {\n      return value["__v_skip" /* SKIP */] || !Object.isExtensible(value)\n          ? 0 /* INVALID */\n          : targetTypeMap(toRawType(value));\n  }\n  function reactive(target) {\n      // if trying to observe a readonly proxy, return the readonly version.\n      if (target && target["__v_isReadonly" /* IS_READONLY */]) {\n          return target;\n      }\n      return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);\n  }\n  // Return a reactive-copy of the original object, where only the root level\n  // properties are reactive, and does NOT unwrap refs nor recursively convert\n  // returned properties.\n  function shallowReactive(target) {\n      return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers);\n  }\n  function readonly(target) {\n      return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);\n  }\n  // Return a reactive-copy of the original object, where only the root level\n  // properties are readonly, and does NOT unwrap refs nor recursively convert\n  // returned properties.\n  // This is used for creating the props proxy object for stateful components.\n  function shallowReadonly(target) {\n      return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);\n  }\n  function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {\n      if (!isObject(target)) {\n          {\n              console.warn(`value cannot be made reactive: ${String(target)}`);\n          }\n          return target;\n      }\n      // target is already a Proxy, return it.\n      // exception: calling readonly() on a reactive object\n      if (target["__v_raw" /* RAW */] &&\n          !(isReadonly && target["__v_isReactive" /* IS_REACTIVE */])) {\n          return target;\n      }\n      // target already has corresponding Proxy\n      const proxyMap = isReadonly ? readonlyMap : reactiveMap;\n      const existingProxy = proxyMap.get(target);\n      if (existingProxy) {\n          return existingProxy;\n      }\n      // only a whitelist of value types can be observed.\n      const targetType = getTargetType(target);\n      if (targetType === 0 /* INVALID */) {\n          return target;\n      }\n      const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\n      proxyMap.set(target, proxy);\n      return proxy;\n  }\n  function isReactive(value) {\n      if (isReadonly(value)) {\n          return isReactive(value["__v_raw" /* RAW */]);\n      }\n      return !!(value && value["__v_isReactive" /* IS_REACTIVE */]);\n  }\n  function isReadonly(value) {\n      return !!(value && value["__v_isReadonly" /* IS_READONLY */]);\n  }\n  function isProxy(value) {\n      return isReactive(value) || isReadonly(value);\n  }\n  function toRaw(observed) {\n      return ((observed && toRaw(observed["__v_raw" /* RAW */])) || observed);\n  }\n  function markRaw(value) {\n      def(value, "__v_skip" /* SKIP */, true);\n      return value;\n  }\n\n  const convert = (val) => isObject(val) ? reactive(val) : val;\n  function isRef(r) {\n      return Boolean(r && r.__v_isRef === true);\n  }\n  function ref(value) {\n      return createRef(value);\n  }\n  function shallowRef(value) {\n      return createRef(value, true);\n  }\n  class RefImpl {\n      constructor(_rawValue, _shallow = false) {\n          this._rawValue = _rawValue;\n          this._shallow = _shallow;\n          this.__v_isRef = true;\n          this._value = _shallow ? _rawValue : convert(_rawValue);\n      }\n      get value() {\n          track(toRaw(this), "get" /* GET */, \'value\');\n          return this._value;\n      }\n      set value(newVal) {\n          if (hasChanged(toRaw(newVal), this._rawValue)) {\n              this._rawValue = newVal;\n              this._value = this._shallow ? newVal : convert(newVal);\n              trigger(toRaw(this), "set" /* SET */, \'value\', newVal);\n          }\n      }\n  }\n  function createRef(rawValue, shallow = false) {\n      if (isRef(rawValue)) {\n          return rawValue;\n      }\n      return new RefImpl(rawValue, shallow);\n  }\n  function triggerRef(ref) {\n      trigger(toRaw(ref), "set" /* SET */, \'value\',  ref.value );\n  }\n  function unref(ref) {\n      return isRef(ref) ? ref.value : ref;\n  }\n  const shallowUnwrapHandlers = {\n      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n      set: (target, key, value, receiver) => {\n          const oldValue = target[key];\n          if (isRef(oldValue) && !isRef(value)) {\n              oldValue.value = value;\n              return true;\n          }\n          else {\n              return Reflect.set(target, key, value, receiver);\n          }\n      }\n  };\n  function proxyRefs(objectWithRefs) {\n      return isReactive(objectWithRefs)\n          ? objectWithRefs\n          : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n  }\n  class CustomRefImpl {\n      constructor(factory) {\n          this.__v_isRef = true;\n          const { get, set } = factory(() => track(this, "get" /* GET */, \'value\'), () => trigger(this, "set" /* SET */, \'value\'));\n          this._get = get;\n          this._set = set;\n      }\n      get value() {\n          return this._get();\n      }\n      set value(newVal) {\n          this._set(newVal);\n      }\n  }\n  function customRef(factory) {\n      return new CustomRefImpl(factory);\n  }\n  function toRefs(object) {\n      if ( !isProxy(object)) {\n          console.warn(`toRefs() expects a reactive object but received a plain one.`);\n      }\n      const ret = isArray(object) ? new Array(object.length) : {};\n      for (const key in object) {\n          ret[key] = toRef(object, key);\n      }\n      return ret;\n  }\n  class ObjectRefImpl {\n      constructor(_object, _key) {\n          this._object = _object;\n          this._key = _key;\n          this.__v_isRef = true;\n      }\n      get value() {\n          return this._object[this._key];\n      }\n      set value(newVal) {\n          this._object[this._key] = newVal;\n      }\n  }\n  function toRef(object, key) {\n      return isRef(object[key])\n          ? object[key]\n          : new ObjectRefImpl(object, key);\n  }\n\n  class ComputedRefImpl {\n      constructor(getter, _setter, isReadonly) {\n          this._setter = _setter;\n          this._dirty = true;\n          this.__v_isRef = true;\n          this.effect = effect(getter, {\n              lazy: true,\n              scheduler: () => {\n                  if (!this._dirty) {\n                      this._dirty = true;\n                      trigger(toRaw(this), "set" /* SET */, \'value\');\n                  }\n              }\n          });\n          this["__v_isReadonly" /* IS_READONLY */] = isReadonly;\n      }\n      get value() {\n          if (this._dirty) {\n              this._value = this.effect();\n              this._dirty = false;\n          }\n          track(toRaw(this), "get" /* GET */, \'value\');\n          return this._value;\n      }\n      set value(newValue) {\n          this._setter(newValue);\n      }\n  }\n  function computed(getterOrOptions) {\n      let getter;\n      let setter;\n      if (isFunction(getterOrOptions)) {\n          getter = getterOrOptions;\n          setter =  () => {\n                  console.warn(\'Write operation failed: computed value is readonly\');\n              }\n              ;\n      }\n      else {\n          getter = getterOrOptions.get;\n          setter = getterOrOptions.set;\n      }\n      return new ComputedRefImpl(getter, setter, isFunction(getterOrOptions) || !getterOrOptions.set);\n  }\n\n  const stack = [];\n  function pushWarningContext(vnode) {\n      stack.push(vnode);\n  }\n  function popWarningContext() {\n      stack.pop();\n  }\n  function warn(msg, ...args) {\n      // avoid props formatting or warn handler tracking deps that might be mutated\n      // during patch, leading to infinite recursion.\n      pauseTracking();\n      const instance = stack.length ? stack[stack.length - 1].component : null;\n      const appWarnHandler = instance && instance.appContext.config.warnHandler;\n      const trace = getComponentTrace();\n      if (appWarnHandler) {\n          callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\n              msg + args.join(\'\'),\n              instance && instance.proxy,\n              trace\n                  .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\n                  .join(\'\\n\'),\n              trace\n          ]);\n      }\n      else {\n          const warnArgs = [`[Vue warn]: ${msg}`, ...args];\n          /* istanbul ignore if */\n          if (trace.length &&\n              // avoid spamming console during tests\n              !false) {\n              warnArgs.push(`\\n`, ...formatTrace(trace));\n          }\n          console.warn(...warnArgs);\n      }\n      resetTracking();\n  }\n  function getComponentTrace() {\n      let currentVNode = stack[stack.length - 1];\n      if (!currentVNode) {\n          return [];\n      }\n      // we can\'t just use the stack because it will be incomplete during updates\n      // that did not start from the root. Re-construct the parent chain using\n      // instance parent pointers.\n      const normalizedStack = [];\n      while (currentVNode) {\n          const last = normalizedStack[0];\n          if (last && last.vnode === currentVNode) {\n              last.recurseCount++;\n          }\n          else {\n              normalizedStack.push({\n                  vnode: currentVNode,\n                  recurseCount: 0\n              });\n          }\n          const parentInstance = currentVNode.component && currentVNode.component.parent;\n          currentVNode = parentInstance && parentInstance.vnode;\n      }\n      return normalizedStack;\n  }\n  /* istanbul ignore next */\n  function formatTrace(trace) {\n      const logs = [];\n      trace.forEach((entry, i) => {\n          logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\n      });\n      return logs;\n  }\n  function formatTraceEntry({ vnode, recurseCount }) {\n      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\n      const isRoot = vnode.component ? vnode.component.parent == null : false;\n      const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\n      const close = `>` + postfix;\n      return vnode.props\n          ? [open, ...formatProps(vnode.props), close]\n          : [open + close];\n  }\n  /* istanbul ignore next */\n  function formatProps(props) {\n      const res = [];\n      const keys = Object.keys(props);\n      keys.slice(0, 3).forEach(key => {\n          res.push(...formatProp(key, props[key]));\n      });\n      if (keys.length > 3) {\n          res.push(` ...`);\n      }\n      return res;\n  }\n  /* istanbul ignore next */\n  function formatProp(key, value, raw) {\n      if (isString(value)) {\n          value = JSON.stringify(value);\n          return raw ? value : [`${key}=${value}`];\n      }\n      else if (typeof value === \'number\' ||\n          typeof value === \'boolean\' ||\n          value == null) {\n          return raw ? value : [`${key}=${value}`];\n      }\n      else if (isRef(value)) {\n          value = formatProp(key, toRaw(value.value), true);\n          return raw ? value : [`${key}=Ref<`, value, `>`];\n      }\n      else if (isFunction(value)) {\n          return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\n      }\n      else {\n          value = toRaw(value);\n          return raw ? value : [`${key}=`, value];\n      }\n  }\n\n  const ErrorTypeStrings = {\n      ["bc" /* BEFORE_CREATE */]: \'beforeCreate hook\',\n      ["c" /* CREATED */]: \'created hook\',\n      ["bm" /* BEFORE_MOUNT */]: \'beforeMount hook\',\n      ["m" /* MOUNTED */]: \'mounted hook\',\n      ["bu" /* BEFORE_UPDATE */]: \'beforeUpdate hook\',\n      ["u" /* UPDATED */]: \'updated\',\n      ["bum" /* BEFORE_UNMOUNT */]: \'beforeUnmount hook\',\n      ["um" /* UNMOUNTED */]: \'unmounted hook\',\n      ["a" /* ACTIVATED */]: \'activated hook\',\n      ["da" /* DEACTIVATED */]: \'deactivated hook\',\n      ["ec" /* ERROR_CAPTURED */]: \'errorCaptured hook\',\n      ["rtc" /* RENDER_TRACKED */]: \'renderTracked hook\',\n      ["rtg" /* RENDER_TRIGGERED */]: \'renderTriggered hook\',\n      [0 /* SETUP_FUNCTION */]: \'setup function\',\n      [1 /* RENDER_FUNCTION */]: \'render function\',\n      [2 /* WATCH_GETTER */]: \'watcher getter\',\n      [3 /* WATCH_CALLBACK */]: \'watcher callback\',\n      [4 /* WATCH_CLEANUP */]: \'watcher cleanup function\',\n      [5 /* NATIVE_EVENT_HANDLER */]: \'native event handler\',\n      [6 /* COMPONENT_EVENT_HANDLER */]: \'component event handler\',\n      [7 /* VNODE_HOOK */]: \'vnode hook\',\n      [8 /* DIRECTIVE_HOOK */]: \'directive hook\',\n      [9 /* TRANSITION_HOOK */]: \'transition hook\',\n      [10 /* APP_ERROR_HANDLER */]: \'app errorHandler\',\n      [11 /* APP_WARN_HANDLER */]: \'app warnHandler\',\n      [12 /* FUNCTION_REF */]: \'ref function\',\n      [13 /* ASYNC_COMPONENT_LOADER */]: \'async component loader\',\n      [14 /* SCHEDULER */]: \'scheduler flush. This is likely a Vue internals bug. \' +\n          \'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next\'\n  };\n  function callWithErrorHandling(fn, instance, type, args) {\n      let res;\n      try {\n          res = args ? fn(...args) : fn();\n      }\n      catch (err) {\n          handleError(err, instance, type);\n      }\n      return res;\n  }\n  function callWithAsyncErrorHandling(fn, instance, type, args) {\n      if (isFunction(fn)) {\n          const res = callWithErrorHandling(fn, instance, type, args);\n          if (res && isPromise(res)) {\n              res.catch(err => {\n                  handleError(err, instance, type);\n              });\n          }\n          return res;\n      }\n      const values = [];\n      for (let i = 0; i < fn.length; i++) {\n          values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\n      }\n      return values;\n  }\n  function handleError(err, instance, type, throwInDev = true) {\n      const contextVNode = instance ? instance.vnode : null;\n      if (instance) {\n          let cur = instance.parent;\n          // the exposed instance is the render proxy to keep it consistent with 2.x\n          const exposedInstance = instance.proxy;\n          // in production the hook receives only the error code\n          const errorInfo =  ErrorTypeStrings[type] ;\n          while (cur) {\n              const errorCapturedHooks = cur.ec;\n              if (errorCapturedHooks) {\n                  for (let i = 0; i < errorCapturedHooks.length; i++) {\n                      if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\n                          return;\n                      }\n                  }\n              }\n              cur = cur.parent;\n          }\n          // app-level handling\n          const appErrorHandler = instance.appContext.config.errorHandler;\n          if (appErrorHandler) {\n              callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\n              return;\n          }\n      }\n      logError(err, type, contextVNode, throwInDev);\n  }\n  function logError(err, type, contextVNode, throwInDev = true) {\n      {\n          const info = ErrorTypeStrings[type];\n          if (contextVNode) {\n              pushWarningContext(contextVNode);\n          }\n          warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\n          if (contextVNode) {\n              popWarningContext();\n          }\n          // crash in dev by default so it\'s more noticeable\n          if (throwInDev) {\n              throw err;\n          }\n          else {\n              console.error(err);\n          }\n      }\n  }\n\n  let isFlushing = false;\n  let isFlushPending = false;\n  const queue = [];\n  let flushIndex = 0;\n  const pendingPreFlushCbs = [];\n  let activePreFlushCbs = null;\n  let preFlushIndex = 0;\n  const pendingPostFlushCbs = [];\n  let activePostFlushCbs = null;\n  let postFlushIndex = 0;\n  const resolvedPromise = Promise.resolve();\n  let currentFlushPromise = null;\n  let currentPreFlushParentJob = null;\n  const RECURSION_LIMIT = 100;\n  function nextTick(fn) {\n      const p = currentFlushPromise || resolvedPromise;\n      return fn ? p.then(this ? fn.bind(this) : fn) : p;\n  }\n  function queueJob(job) {\n      // the dedupe search uses the startIndex argument of Array.includes()\n      // by default the search index includes the current job that is being run\n      // so it cannot recursively trigger itself again.\n      // if the job is a watch() callback, the search will start with a +1 index to\n      // allow it recursively trigger itself - it is the user\'s responsibility to\n      // ensure it doesn\'t end up in an infinite loop.\n      if ((!queue.length ||\n          !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\n          job !== currentPreFlushParentJob) {\n          queue.push(job);\n          queueFlush();\n      }\n  }\n  function queueFlush() {\n      if (!isFlushing && !isFlushPending) {\n          isFlushPending = true;\n          currentFlushPromise = resolvedPromise.then(flushJobs);\n      }\n  }\n  function invalidateJob(job) {\n      const i = queue.indexOf(job);\n      if (i > -1) {\n          queue[i] = null;\n      }\n  }\n  function queueCb(cb, activeQueue, pendingQueue, index) {\n      if (!isArray(cb)) {\n          if (!activeQueue ||\n              !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\n              pendingQueue.push(cb);\n          }\n      }\n      else {\n          // if cb is an array, it is a component lifecycle hook which can only be\n          // triggered by a job, which is already deduped in the main queue, so\n          // we can skip duplicate check here to improve perf\n          pendingQueue.push(...cb);\n      }\n      queueFlush();\n  }\n  function queuePreFlushCb(cb) {\n      queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\n  }\n  function queuePostFlushCb(cb) {\n      queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\n  }\n  function flushPreFlushCbs(seen, parentJob = null) {\n      if (pendingPreFlushCbs.length) {\n          currentPreFlushParentJob = parentJob;\n          activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\n          pendingPreFlushCbs.length = 0;\n          {\n              seen = seen || new Map();\n          }\n          for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\n              {\n                  checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex]);\n              }\n              activePreFlushCbs[preFlushIndex]();\n          }\n          activePreFlushCbs = null;\n          preFlushIndex = 0;\n          currentPreFlushParentJob = null;\n          // recursively flush until it drains\n          flushPreFlushCbs(seen, parentJob);\n      }\n  }\n  function flushPostFlushCbs(seen) {\n      if (pendingPostFlushCbs.length) {\n          const deduped = [...new Set(pendingPostFlushCbs)];\n          pendingPostFlushCbs.length = 0;\n          // #1947 already has active queue, nested flushPostFlushCbs call\n          if (activePostFlushCbs) {\n              activePostFlushCbs.push(...deduped);\n              return;\n          }\n          activePostFlushCbs = deduped;\n          {\n              seen = seen || new Map();\n          }\n          activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\n          for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n              {\n                  checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex]);\n              }\n              activePostFlushCbs[postFlushIndex]();\n          }\n          activePostFlushCbs = null;\n          postFlushIndex = 0;\n      }\n  }\n  const getId = (job) => job.id == null ? Infinity : job.id;\n  function flushJobs(seen) {\n      isFlushPending = false;\n      isFlushing = true;\n      {\n          seen = seen || new Map();\n      }\n      flushPreFlushCbs(seen);\n      // Sort queue before flush.\n      // This ensures that:\n      // 1. Components are updated from parent to child. (because parent is always\n      //    created before the child so its render effect will have smaller\n      //    priority number)\n      // 2. If a component is unmounted during a parent component\'s update,\n      //    its update can be skipped.\n      // Jobs can never be null before flush starts, since they are only invalidated\n      // during execution of another flushed job.\n      queue.sort((a, b) => getId(a) - getId(b));\n      try {\n          for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n              const job = queue[flushIndex];\n              if (job) {\n                  if (true) {\n                      checkRecursiveUpdates(seen, job);\n                  }\n                  callWithErrorHandling(job, null, 14 /* SCHEDULER */);\n              }\n          }\n      }\n      finally {\n          flushIndex = 0;\n          queue.length = 0;\n          flushPostFlushCbs(seen);\n          isFlushing = false;\n          currentFlushPromise = null;\n          // some postFlushCb queued jobs!\n          // keep flushing until it drains.\n          if (queue.length || pendingPostFlushCbs.length) {\n              flushJobs(seen);\n          }\n      }\n  }\n  function checkRecursiveUpdates(seen, fn) {\n      if (!seen.has(fn)) {\n          seen.set(fn, 1);\n      }\n      else {\n          const count = seen.get(fn);\n          if (count > RECURSION_LIMIT) {\n              throw new Error(`Maximum recursive updates exceeded. ` +\n                  `This means you have a reactive effect that is mutating its own ` +\n                  `dependencies and thus recursively triggering itself. Possible sources ` +\n                  `include component template, render function, updated hook or ` +\n                  `watcher source function.`);\n          }\n          else {\n              seen.set(fn, count + 1);\n          }\n      }\n  }\n\n  /* eslint-disable no-restricted-globals */\n  let isHmrUpdating = false;\n  const hmrDirtyComponents = new Set();\n  // Expose the HMR runtime on the global object\n  // This makes it entirely tree-shakable without polluting the exports and makes\n  // it easier to be used in toolings like vue-loader\n  // Note: for a component to be eligible for HMR it also needs the __hmrId option\n  // to be set so that its instances can be registered / removed.\n  {\n      const globalObject = typeof global !== \'undefined\'\n          ? global\n          : typeof self !== \'undefined\'\n              ? self\n              : typeof window !== \'undefined\'\n                  ? window\n                  : {};\n      globalObject.__VUE_HMR_RUNTIME__ = {\n          createRecord: tryWrap(createRecord),\n          rerender: tryWrap(rerender),\n          reload: tryWrap(reload)\n      };\n  }\n  const map = new Map();\n  function registerHMR(instance) {\n      const id = instance.type.__hmrId;\n      let record = map.get(id);\n      if (!record) {\n          createRecord(id);\n          record = map.get(id);\n      }\n      record.add(instance);\n  }\n  function unregisterHMR(instance) {\n      map.get(instance.type.__hmrId).delete(instance);\n  }\n  function createRecord(id) {\n      if (map.has(id)) {\n          return false;\n      }\n      map.set(id, new Set());\n      return true;\n  }\n  function rerender(id, newRender) {\n      const record = map.get(id);\n      if (!record)\n          return;\n      // Array.from creates a snapshot which avoids the set being mutated during\n      // updates\n      Array.from(record).forEach(instance => {\n          if (newRender) {\n              instance.render = newRender;\n          }\n          instance.renderCache = [];\n          // this flag forces child components with slot content to update\n          isHmrUpdating = true;\n          instance.update();\n          isHmrUpdating = false;\n      });\n  }\n  function reload(id, newComp) {\n      const record = map.get(id);\n      if (!record)\n          return;\n      // Array.from creates a snapshot which avoids the set being mutated during\n      // updates\n      Array.from(record).forEach(instance => {\n          const comp = instance.type;\n          if (!hmrDirtyComponents.has(comp)) {\n              // 1. Update existing comp definition to match new one\n              newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;\n              extend(comp, newComp);\n              for (const key in comp) {\n                  if (!(key in newComp)) {\n                      delete comp[key];\n                  }\n              }\n              // 2. Mark component dirty. This forces the renderer to replace the component\n              // on patch.\n              hmrDirtyComponents.add(comp);\n              // 3. Make sure to unmark the component after the reload.\n              queuePostFlushCb(() => {\n                  hmrDirtyComponents.delete(comp);\n              });\n          }\n          if (instance.parent) {\n              // 4. Force the parent instance to re-render. This will cause all updated\n              // components to be unmounted and re-mounted. Queue the update so that we\n              // don\'t end up forcing the same parent to re-render multiple times.\n              queueJob(instance.parent.update);\n          }\n          else if (instance.appContext.reload) {\n              // root instance mounted via createApp() has a reload method\n              instance.appContext.reload();\n          }\n          else if (typeof window !== \'undefined\') {\n              // root instance inside tree created via raw render(). Force reload.\n              window.location.reload();\n          }\n          else {\n              console.warn(\'[HMR] Root or manually mounted instance modified. Full reload required.\');\n          }\n      });\n  }\n  function tryWrap(fn) {\n      return (id, arg) => {\n          try {\n              return fn(id, arg);\n          }\n          catch (e) {\n              console.error(e);\n              console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +\n                  `Full reload required.`);\n          }\n      };\n  }\n\n  function setDevtoolsHook(hook) {\n      exports.devtools = hook;\n  }\n  function devtoolsInitApp(app, version) {\n      // TODO queue if devtools is undefined\n      if (!exports.devtools)\n          return;\n      exports.devtools.emit("app:init" /* APP_INIT */, app, version, {\n          Fragment,\n          Text,\n          Comment,\n          Static\n      });\n  }\n  function devtoolsUnmountApp(app) {\n      if (!exports.devtools)\n          return;\n      exports.devtools.emit("app:unmount" /* APP_UNMOUNT */, app);\n  }\n  const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);\n  const devtoolsComponentUpdated = /*#__PURE__*/ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);\n  const devtoolsComponentRemoved = /*#__PURE__*/ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */);\n  function createDevtoolsComponentHook(hook) {\n      return (component) => {\n          if (!exports.devtools)\n              return;\n          exports.devtools.emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined);\n      };\n  }\n  function devtoolsComponentEmit(component, event, params) {\n      if (!exports.devtools)\n          return;\n      exports.devtools.emit("component:emit" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);\n  }\n\n  function emit(instance, event, ...rawArgs) {\n      const props = instance.vnode.props || EMPTY_OBJ;\n      {\n          const { emitsOptions, propsOptions: [propsOptions] } = instance;\n          if (emitsOptions) {\n              if (!(event in emitsOptions)) {\n                  if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {\n                      warn(`Component emitted event "${event}" but it is neither declared in ` +\n                          `the emits option nor as an "${toHandlerKey(event)}" prop.`);\n                  }\n              }\n              else {\n                  const validator = emitsOptions[event];\n                  if (isFunction(validator)) {\n                      const isValid = validator(...rawArgs);\n                      if (!isValid) {\n                          warn(`Invalid event arguments: event validation failed for event "${event}".`);\n                      }\n                  }\n              }\n          }\n      }\n      let args = rawArgs;\n      const isModelListener = event.startsWith(\'update:\');\n      // for v-model update:xxx events, apply modifiers on args\n      const modelArg = isModelListener && event.slice(7);\n      if (modelArg && modelArg in props) {\n          const modifiersKey = `${modelArg === \'modelValue\' ? \'model\' : modelArg}Modifiers`;\n          const { number, trim } = props[modifiersKey] || EMPTY_OBJ;\n          if (trim) {\n              args = rawArgs.map(a => a.trim());\n          }\n          else if (number) {\n              args = rawArgs.map(toNumber);\n          }\n      }\n      {\n          devtoolsComponentEmit(instance, event, args);\n      }\n      {\n          const lowerCaseEvent = event.toLowerCase();\n          if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {\n              warn(`Event "${lowerCaseEvent}" is emitted in component ` +\n                  `${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". ` +\n                  `Note that HTML attributes are case-insensitive and you cannot use ` +\n                  `v-on to listen to camelCase events when using in-DOM templates. ` +\n                  `You should probably use "${hyphenate(event)}" instead of "${event}".`);\n          }\n      }\n      // convert handler name to camelCase. See issue #2249\n      let handlerName = toHandlerKey(camelize(event));\n      let handler = props[handlerName];\n      // for v-model update:xxx events, also trigger kebab-case equivalent\n      // for props passed via kebab-case\n      if (!handler && isModelListener) {\n          handlerName = toHandlerKey(hyphenate(event));\n          handler = props[handlerName];\n      }\n      if (handler) {\n          callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\n      }\n      const onceHandler = props[handlerName + `Once`];\n      if (onceHandler) {\n          if (!instance.emitted) {\n              (instance.emitted = {})[handlerName] = true;\n          }\n          else if (instance.emitted[handlerName]) {\n              return;\n          }\n          callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\n      }\n  }\n  function normalizeEmitsOptions(comp, appContext, asMixin = false) {\n      if (!appContext.deopt && comp.__emits !== undefined) {\n          return comp.__emits;\n      }\n      const raw = comp.emits;\n      let normalized = {};\n      // apply mixin/extends props\n      let hasExtends = false;\n      if ( !isFunction(comp)) {\n          const extendEmits = (raw) => {\n              hasExtends = true;\n              extend(normalized, normalizeEmitsOptions(raw, appContext, true));\n          };\n          if (!asMixin && appContext.mixins.length) {\n              appContext.mixins.forEach(extendEmits);\n          }\n          if (comp.extends) {\n              extendEmits(comp.extends);\n          }\n          if (comp.mixins) {\n              comp.mixins.forEach(extendEmits);\n          }\n      }\n      if (!raw && !hasExtends) {\n          return (comp.__emits = null);\n      }\n      if (isArray(raw)) {\n          raw.forEach(key => (normalized[key] = null));\n      }\n      else {\n          extend(normalized, raw);\n      }\n      return (comp.__emits = normalized);\n  }\n  // Check if an incoming prop key is a declared emit event listener.\n  // e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\n  // both considered matched listeners.\n  function isEmitListener(options, key) {\n      if (!options || !isOn(key)) {\n          return false;\n      }\n      key = key.replace(/Once$/, \'\');\n      return (hasOwn(options, key[2].toLowerCase() + key.slice(3)) ||\n          hasOwn(options, key.slice(2)));\n  }\n\n  // mark the current rendering instance for asset resolution (e.g.\n  // resolveComponent, resolveDirective) during render\n  let currentRenderingInstance = null;\n  function setCurrentRenderingInstance(instance) {\n      currentRenderingInstance = instance;\n  }\n  // dev only flag to track whether $attrs was used during render.\n  // If $attrs was used during render then the warning for failed attrs\n  // fallthrough can be suppressed.\n  let accessedAttrs = false;\n  function markAttrsAccessed() {\n      accessedAttrs = true;\n  }\n  function renderComponentRoot(instance) {\n      const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx } = instance;\n      let result;\n      currentRenderingInstance = instance;\n      {\n          accessedAttrs = false;\n      }\n      try {\n          let fallthroughAttrs;\n          if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\n              // withProxy is a proxy with a different `has` trap only for\n              // runtime-compiled render functions using `with` block.\n              const proxyToUse = withProxy || proxy;\n              result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));\n              fallthroughAttrs = attrs;\n          }\n          else {\n              // functional\n              const render = Component;\n              // in dev, mark attrs accessed if optional props (attrs === props)\n              if (true && attrs === props) {\n                  markAttrsAccessed();\n              }\n              result = normalizeVNode(render.length > 1\n                  ? render(props, true\n                      ? {\n                          get attrs() {\n                              markAttrsAccessed();\n                              return attrs;\n                          },\n                          slots,\n                          emit\n                      }\n                      : { attrs, slots, emit })\n                  : render(props, null /* we know it doesn\'t need it */));\n              fallthroughAttrs = Component.props\n                  ? attrs\n                  : getFunctionalFallthrough(attrs);\n          }\n          // attr merging\n          // in dev mode, comments are preserved, and it\'s possible for a template\n          // to have comments along side the root element which makes it a fragment\n          let root = result;\n          let setRoot = undefined;\n          if (true) {\n              ;\n              [root, setRoot] = getChildRoot(result);\n          }\n          if (Component.inheritAttrs !== false && fallthroughAttrs) {\n              const keys = Object.keys(fallthroughAttrs);\n              const { shapeFlag } = root;\n              if (keys.length) {\n                  if (shapeFlag & 1 /* ELEMENT */ ||\n                      shapeFlag & 6 /* COMPONENT */) {\n                      if (propsOptions && keys.some(isModelListener)) {\n                          // If a v-model listener (onUpdate:xxx) has a corresponding declared\n                          // prop, it indicates this component expects to handle v-model and\n                          // it should not fallthrough.\n                          // related: #1543, #1643, #1989\n                          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);\n                      }\n                      root = cloneVNode(root, fallthroughAttrs);\n                  }\n                  else if (true && !accessedAttrs && root.type !== Comment) {\n                      const allAttrs = Object.keys(attrs);\n                      const eventAttrs = [];\n                      const extraAttrs = [];\n                      for (let i = 0, l = allAttrs.length; i < l; i++) {\n                          const key = allAttrs[i];\n                          if (isOn(key)) {\n                              // ignore v-model handlers when they fail to fallthrough\n                              if (!isModelListener(key)) {\n                                  // remove `on`, lowercase first letter to reflect event casing\n                                  // accurately\n                                  eventAttrs.push(key[2].toLowerCase() + key.slice(3));\n                              }\n                          }\n                          else {\n                              extraAttrs.push(key);\n                          }\n                      }\n                      if (extraAttrs.length) {\n                          warn(`Extraneous non-props attributes (` +\n                              `${extraAttrs.join(\', \')}) ` +\n                              `were passed to component but could not be automatically inherited ` +\n                              `because component renders fragment or text root nodes.`);\n                      }\n                      if (eventAttrs.length) {\n                          warn(`Extraneous non-emits event listeners (` +\n                              `${eventAttrs.join(\', \')}) ` +\n                              `were passed to component but could not be automatically inherited ` +\n                              `because component renders fragment or text root nodes. ` +\n                              `If the listener is intended to be a component custom event listener only, ` +\n                              `declare it using the "emits" option.`);\n                      }\n                  }\n              }\n          }\n          // inherit directives\n          if (vnode.dirs) {\n              if (true && !isElementRoot(root)) {\n                  warn(`Runtime directive used on component with non-element root node. ` +\n                      `The directives will not function as intended.`);\n              }\n              root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\n          }\n          // inherit transition data\n          if (vnode.transition) {\n              if (true && !isElementRoot(root)) {\n                  warn(`Component inside <Transition> renders non-element root node ` +\n                      `that cannot be animated.`);\n              }\n              root.transition = vnode.transition;\n          }\n          if (true && setRoot) {\n              setRoot(root);\n          }\n          else {\n              result = root;\n          }\n      }\n      catch (err) {\n          handleError(err, instance, 1 /* RENDER_FUNCTION */);\n          result = createVNode(Comment);\n      }\n      currentRenderingInstance = null;\n      return result;\n  }\n  /**\n   * dev only\n   * In dev mode, template root level comments are rendered, which turns the\n   * template into a fragment root, but we need to locate the single element\n   * root for attrs and scope id processing.\n   */\n  const getChildRoot = (vnode) => {\n      if (vnode.type !== Fragment) {\n          return [vnode, undefined];\n      }\n      const rawChildren = vnode.children;\n      const dynamicChildren = vnode.dynamicChildren;\n      const childRoot = filterSingleRoot(rawChildren);\n      if (!childRoot) {\n          return [vnode, undefined];\n      }\n      const index = rawChildren.indexOf(childRoot);\n      const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\n      const setRoot = (updatedRoot) => {\n          rawChildren[index] = updatedRoot;\n          if (dynamicChildren) {\n              if (dynamicIndex > -1) {\n                  dynamicChildren[dynamicIndex] = updatedRoot;\n              }\n              else if (updatedRoot.patchFlag > 0) {\n                  vnode.dynamicChildren = [...dynamicChildren, updatedRoot];\n              }\n          }\n      };\n      return [normalizeVNode(childRoot), setRoot];\n  };\n  /**\n   * dev only\n   */\n  function filterSingleRoot(children) {\n      const filtered = children.filter(child => {\n          return !(isVNode(child) &&\n              child.type === Comment &&\n              child.children !== \'v-if\');\n      });\n      return filtered.length === 1 && isVNode(filtered[0]) ? filtered[0] : null;\n  }\n  const getFunctionalFallthrough = (attrs) => {\n      let res;\n      for (const key in attrs) {\n          if (key === \'class\' || key === \'style\' || isOn(key)) {\n              (res || (res = {}))[key] = attrs[key];\n          }\n      }\n      return res;\n  };\n  const filterModelListeners = (attrs, props) => {\n      const res = {};\n      for (const key in attrs) {\n          if (!isModelListener(key) || !(key.slice(9) in props)) {\n              res[key] = attrs[key];\n          }\n      }\n      return res;\n  };\n  const isElementRoot = (vnode) => {\n      return (vnode.shapeFlag & 6 /* COMPONENT */ ||\n          vnode.shapeFlag & 1 /* ELEMENT */ ||\n          vnode.type === Comment // potential v-if branch switch\n      );\n  };\n  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {\n      const { props: prevProps, children: prevChildren, component } = prevVNode;\n      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;\n      const emits = component.emitsOptions;\n      // Parent component\'s render function was hot-updated. Since this may have\n      // caused the child component\'s slots content to have changed, we need to\n      // force the child to update as well.\n      if ( (prevChildren || nextChildren) && isHmrUpdating) {\n          return true;\n      }\n      // force child update for runtime directive or transition on component vnode.\n      if (nextVNode.dirs || nextVNode.transition) {\n          return true;\n      }\n      if (optimized && patchFlag > 0) {\n          if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {\n              // slot content that references values that might have changed,\n              // e.g. in a v-for\n              return true;\n          }\n          if (patchFlag & 16 /* FULL_PROPS */) {\n              if (!prevProps) {\n                  return !!nextProps;\n              }\n              // presence of this flag indicates props are always non-null\n              return hasPropsChanged(prevProps, nextProps, emits);\n          }\n          else if (patchFlag & 8 /* PROPS */) {\n              const dynamicProps = nextVNode.dynamicProps;\n              for (let i = 0; i < dynamicProps.length; i++) {\n                  const key = dynamicProps[i];\n                  if (nextProps[key] !== prevProps[key] &&\n                      !isEmitListener(emits, key)) {\n                      return true;\n                  }\n              }\n          }\n      }\n      else {\n          // this path is only taken by manually written render functions\n          // so presence of any children leads to a forced update\n          if (prevChildren || nextChildren) {\n              if (!nextChildren || !nextChildren.$stable) {\n                  return true;\n              }\n          }\n          if (prevProps === nextProps) {\n              return false;\n          }\n          if (!prevProps) {\n              return !!nextProps;\n          }\n          if (!nextProps) {\n              return true;\n          }\n          return hasPropsChanged(prevProps, nextProps, emits);\n      }\n      return false;\n  }\n  function hasPropsChanged(prevProps, nextProps, emitsOptions) {\n      const nextKeys = Object.keys(nextProps);\n      if (nextKeys.length !== Object.keys(prevProps).length) {\n          return true;\n      }\n      for (let i = 0; i < nextKeys.length; i++) {\n          const key = nextKeys[i];\n          if (nextProps[key] !== prevProps[key] &&\n              !isEmitListener(emitsOptions, key)) {\n              return true;\n          }\n      }\n      return false;\n  }\n  function updateHOCHostEl({ vnode, parent }, el // HostNode\n  ) {\n      while (parent && parent.subTree === vnode) {\n          (vnode = parent.vnode).el = el;\n          parent = parent.parent;\n      }\n  }\n\n  const isSuspense = (type) => type.__isSuspense;\n  // Suspense exposes a component-like API, and is treated like a component\n  // in the compiler, but internally it\'s a special built-in type that hooks\n  // directly into the renderer.\n  const SuspenseImpl = {\n      // In order to make Suspense tree-shakable, we need to avoid importing it\n      // directly in the renderer. The renderer checks for the __isSuspense flag\n      // on a vnode\'s type and calls the `process` method, passing in renderer\n      // internals.\n      __isSuspense: true,\n      process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, \n      // platform-specific impl passed from renderer\n      rendererInternals) {\n          if (n1 == null) {\n              mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals);\n          }\n          else {\n              patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, rendererInternals);\n          }\n      },\n      hydrate: hydrateSuspense,\n      create: createSuspenseBoundary\n  };\n  // Force-casted public typing for h and TSX props inference\n  const Suspense = ( SuspenseImpl\n      );\n  function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals) {\n      const { p: patch, o: { createElement } } = rendererInternals;\n      const hiddenContainer = createElement(\'div\');\n      const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals));\n      // start mounting the content subtree in an off-dom container\n      patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG);\n      // now check if we have encountered any async deps\n      if (suspense.deps > 0) {\n          // has async\n          // mount the fallback tree\n          patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\n          isSVG);\n          setActiveBranch(suspense, vnode.ssFallback);\n      }\n      else {\n          // Suspense has no async deps. Just resolve.\n          suspense.resolve();\n      }\n  }\n  function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, { p: patch, um: unmount, o: { createElement } }) {\n      const suspense = (n2.suspense = n1.suspense);\n      suspense.vnode = n2;\n      n2.el = n1.el;\n      const newBranch = n2.ssContent;\n      const newFallback = n2.ssFallback;\n      const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;\n      if (pendingBranch) {\n          suspense.pendingBranch = newBranch;\n          if (isSameVNodeType(newBranch, pendingBranch)) {\n              // same root type but content may have changed.\n              patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);\n              if (suspense.deps <= 0) {\n                  suspense.resolve();\n              }\n              else if (isInFallback) {\n                  patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\n                  isSVG);\n                  setActiveBranch(suspense, newFallback);\n              }\n          }\n          else {\n              // toggled before pending tree is resolved\n              suspense.pendingId++;\n              if (isHydrating) {\n                  // if toggled before hydration is finished, the current DOM tree is\n                  // no longer valid. set it as the active branch so it will be unmounted\n                  // when resolved\n                  suspense.isHydrating = false;\n                  suspense.activeBranch = pendingBranch;\n              }\n              else {\n                  unmount(pendingBranch, parentComponent, suspense);\n              }\n              // increment pending ID. this is used to invalidate async callbacks\n              // reset suspense state\n              suspense.deps = 0;\n              // discard effects from pending branch\n              suspense.effects.length = 0;\n              // discard previous container\n              suspense.hiddenContainer = createElement(\'div\');\n              if (isInFallback) {\n                  // already in fallback state\n                  patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);\n                  if (suspense.deps <= 0) {\n                      suspense.resolve();\n                  }\n                  else {\n                      patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\n                      isSVG);\n                      setActiveBranch(suspense, newFallback);\n                  }\n              }\n              else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n                  // toggled "back" to current active branch\n                  patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG);\n                  // force resolve\n                  suspense.resolve(true);\n              }\n              else {\n                  // switched to a 3rd branch\n                  patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);\n                  if (suspense.deps <= 0) {\n                      suspense.resolve();\n                  }\n              }\n          }\n      }\n      else {\n          if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n              // root did not change, just normal patch\n              patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG);\n              setActiveBranch(suspense, newBranch);\n          }\n          else {\n              // root node toggled\n              // invoke @pending event\n              const onPending = n2.props && n2.props.onPending;\n              if (isFunction(onPending)) {\n                  onPending();\n              }\n              // mount pending branch in off-dom container\n              suspense.pendingBranch = newBranch;\n              suspense.pendingId++;\n              patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG);\n              if (suspense.deps <= 0) {\n                  // incoming branch has no async deps, resolve now.\n                  suspense.resolve();\n              }\n              else {\n                  const { timeout, pendingId } = suspense;\n                  if (timeout > 0) {\n                      setTimeout(() => {\n                          if (suspense.pendingId === pendingId) {\n                              suspense.fallback(newFallback);\n                          }\n                      }, timeout);\n                  }\n                  else if (timeout === 0) {\n                      suspense.fallback(newFallback);\n                  }\n              }\n          }\n      }\n  }\n  let hasWarned = false;\n  function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals, isHydrating = false) {\n      /* istanbul ignore if */\n      if ( !hasWarned) {\n          hasWarned = true;\n          // @ts-ignore `console.info` cannot be null error\n          console[console.info ? \'info\' : \'log\'](`<Suspense> is an experimental feature and its API will likely change.`);\n      }\n      const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;\n      const timeout = toNumber(vnode.props && vnode.props.timeout);\n      const suspense = {\n          vnode,\n          parent,\n          parentComponent,\n          isSVG,\n          container,\n          hiddenContainer,\n          anchor,\n          deps: 0,\n          pendingId: 0,\n          timeout: typeof timeout === \'number\' ? timeout : -1,\n          activeBranch: null,\n          pendingBranch: null,\n          isInFallback: true,\n          isHydrating,\n          isUnmounted: false,\n          effects: [],\n          resolve(resume = false) {\n              {\n                  if (!resume && !suspense.pendingBranch) {\n                      throw new Error(`suspense.resolve() is called without a pending branch.`);\n                  }\n                  if (suspense.isUnmounted) {\n                      throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);\n                  }\n              }\n              const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;\n              if (suspense.isHydrating) {\n                  suspense.isHydrating = false;\n              }\n              else if (!resume) {\n                  const delayEnter = activeBranch &&\n                      pendingBranch.transition &&\n                      pendingBranch.transition.mode === \'out-in\';\n                  if (delayEnter) {\n                      activeBranch.transition.afterLeave = () => {\n                          if (pendingId === suspense.pendingId) {\n                              move(pendingBranch, container, anchor, 0 /* ENTER */);\n                          }\n                      };\n                  }\n                  // this is initial anchor on mount\n                  let { anchor } = suspense;\n                  // unmount current active tree\n                  if (activeBranch) {\n                      // if the fallback tree was mounted, it may have been moved\n                      // as part of a parent suspense. get the latest anchor for insertion\n                      anchor = next(activeBranch);\n                      unmount(activeBranch, parentComponent, suspense, true);\n                  }\n                  if (!delayEnter) {\n                      // move content from off-dom container to actual container\n                      move(pendingBranch, container, anchor, 0 /* ENTER */);\n                  }\n              }\n              setActiveBranch(suspense, pendingBranch);\n              suspense.pendingBranch = null;\n              suspense.isInFallback = false;\n              // flush buffered effects\n              // check if there is a pending parent suspense\n              let parent = suspense.parent;\n              let hasUnresolvedAncestor = false;\n              while (parent) {\n                  if (parent.pendingBranch) {\n                      // found a pending parent suspense, merge buffered post jobs\n                      // into that parent\n                      parent.effects.push(...effects);\n                      hasUnresolvedAncestor = true;\n                      break;\n                  }\n                  parent = parent.parent;\n              }\n              // no pending parent suspense, flush all jobs\n              if (!hasUnresolvedAncestor) {\n                  queuePostFlushCb(effects);\n              }\n              suspense.effects = [];\n              // invoke @resolve event\n              const onResolve = vnode.props && vnode.props.onResolve;\n              if (isFunction(onResolve)) {\n                  onResolve();\n              }\n          },\n          fallback(fallbackVNode) {\n              if (!suspense.pendingBranch) {\n                  return;\n              }\n              const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;\n              // invoke @fallback event\n              const onFallback = vnode.props && vnode.props.onFallback;\n              if (isFunction(onFallback)) {\n                  onFallback();\n              }\n              const anchor = next(activeBranch);\n              const mountFallback = () => {\n                  if (!suspense.isInFallback) {\n                      return;\n                  }\n                  // mount the fallback tree\n                  patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context\n                  isSVG);\n                  setActiveBranch(suspense, fallbackVNode);\n              };\n              const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === \'out-in\';\n              if (delayEnter) {\n                  activeBranch.transition.afterLeave = mountFallback;\n              }\n              // unmount current active branch\n              unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now\n              true // shouldRemove\n              );\n              suspense.isInFallback = true;\n              if (!delayEnter) {\n                  mountFallback();\n              }\n          },\n          move(container, anchor, type) {\n              suspense.activeBranch &&\n                  move(suspense.activeBranch, container, anchor, type);\n              suspense.container = container;\n          },\n          next() {\n              return suspense.activeBranch && next(suspense.activeBranch);\n          },\n          registerDep(instance, setupRenderEffect) {\n              if (!suspense.pendingBranch) {\n                  return;\n              }\n              const hydratedEl = instance.vnode.el;\n              suspense.deps++;\n              instance\n                  .asyncDep.catch(err => {\n                  handleError(err, instance, 0 /* SETUP_FUNCTION */);\n              })\n                  .then(asyncSetupResult => {\n                  // retry when the setup() promise resolves.\n                  // component may have been unmounted before resolve.\n                  if (instance.isUnmounted ||\n                      suspense.isUnmounted ||\n                      suspense.pendingId !== instance.suspenseId) {\n                      return;\n                  }\n                  suspense.deps--;\n                  // retry from this component\n                  instance.asyncResolved = true;\n                  const { vnode } = instance;\n                  {\n                      pushWarningContext(vnode);\n                  }\n                  handleSetupResult(instance, asyncSetupResult);\n                  if (hydratedEl) {\n                      // vnode may have been replaced if an update happened before the\n                      // async dep is resolved.\n                      vnode.el = hydratedEl;\n                  }\n                  const placeholder = !hydratedEl && instance.subTree.el;\n                  setupRenderEffect(instance, vnode, \n                  // component may have been moved before resolve.\n                  // if this is not a hydration, instance.subTree will be the comment\n                  // placeholder.\n                  parentNode(hydratedEl || instance.subTree.el), \n                  // anchor will not be used if this is hydration, so only need to\n                  // consider the comment placeholder case.\n                  hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);\n                  if (placeholder) {\n                      remove(placeholder);\n                  }\n                  updateHOCHostEl(instance, vnode.el);\n                  {\n                      popWarningContext();\n                  }\n                  if (suspense.deps === 0) {\n                      suspense.resolve();\n                  }\n              });\n          },\n          unmount(parentSuspense, doRemove) {\n              suspense.isUnmounted = true;\n              if (suspense.activeBranch) {\n                  unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);\n              }\n              if (suspense.pendingBranch) {\n                  unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);\n              }\n          }\n      };\n      return suspense;\n  }\n  function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, optimized, rendererInternals, hydrateNode) {\n      /* eslint-disable no-restricted-globals */\n      const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement(\'div\'), null, isSVG, optimized, rendererInternals, true /* hydrating */));\n      // there are two possible scenarios for server-rendered suspense:\n      // - success: ssr content should be fully resolved\n      // - failure: ssr content should be the fallback branch.\n      // however, on the client we don\'t really know if it has failed or not\n      // attempt to hydrate the DOM assuming it has succeeded, but we still\n      // need to construct a suspense boundary first\n      const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, optimized);\n      if (suspense.deps === 0) {\n          suspense.resolve();\n      }\n      return result;\n      /* eslint-enable no-restricted-globals */\n  }\n  function normalizeSuspenseChildren(vnode) {\n      const { shapeFlag, children } = vnode;\n      let content;\n      let fallback;\n      if (shapeFlag & 32 /* SLOTS_CHILDREN */) {\n          content = normalizeSuspenseSlot(children.default);\n          fallback = normalizeSuspenseSlot(children.fallback);\n      }\n      else {\n          content = normalizeSuspenseSlot(children);\n          fallback = normalizeVNode(null);\n      }\n      return {\n          content,\n          fallback\n      };\n  }\n  function normalizeSuspenseSlot(s) {\n      if (isFunction(s)) {\n          s = s();\n      }\n      if (isArray(s)) {\n          const singleChild = filterSingleRoot(s);\n          if ( !singleChild) {\n              warn(`<Suspense> slots expect a single root node.`);\n          }\n          s = singleChild;\n      }\n      return normalizeVNode(s);\n  }\n  function queueEffectWithSuspense(fn, suspense) {\n      if (suspense && suspense.pendingBranch) {\n          if (isArray(fn)) {\n              suspense.effects.push(...fn);\n          }\n          else {\n              suspense.effects.push(fn);\n          }\n      }\n      else {\n          queuePostFlushCb(fn);\n      }\n  }\n  function setActiveBranch(suspense, branch) {\n      suspense.activeBranch = branch;\n      const { vnode, parentComponent } = suspense;\n      const el = (vnode.el = branch.el);\n      // in case suspense is the root node of a component,\n      // recursively update the HOC el\n      if (parentComponent && parentComponent.subTree === vnode) {\n          parentComponent.vnode.el = el;\n          updateHOCHostEl(parentComponent, el);\n      }\n  }\n\n  let isRenderingCompiledSlot = 0;\n  const setCompiledSlotRendering = (n) => (isRenderingCompiledSlot += n);\n  /**\n   * Compiler runtime helper for rendering `<slot/>`\n   * @private\n   */\n  function renderSlot(slots, name, props = {}, \n  // this is not a user-facing function, so the fallback is always generated by\n  // the compiler and guaranteed to be a function returning an array\n  fallback) {\n      let slot = slots[name];\n      if ( slot && slot.length > 1) {\n          warn(`SSR-optimized slot function detected in a non-SSR-optimized render ` +\n              `function. You need to mark this component with $dynamic-slots in the ` +\n              `parent template.`);\n          slot = () => [];\n      }\n      // a compiled slot disables block tracking by default to avoid manual\n      // invocation interfering with template-based block tracking, but in\n      // `renderSlot` we can be sure that it\'s template-based so we can force\n      // enable it.\n      isRenderingCompiledSlot++;\n      const rendered = (openBlock(),\n          createBlock(Fragment, { key: props.key }, slot ? slot(props) : fallback ? fallback() : [], slots._ === 1 /* STABLE */\n              ? 64 /* STABLE_FRAGMENT */\n              : -2 /* BAIL */));\n      isRenderingCompiledSlot--;\n      return rendered;\n  }\n\n  /**\n   * Wrap a slot function to memoize current rendering instance\n   * @private\n   */\n  function withCtx(fn, ctx = currentRenderingInstance) {\n      if (!ctx)\n          return fn;\n      const renderFnWithContext = (...args) => {\n          // If a user calls a compiled slot inside a template expression (#1745), it\n          // can mess up block tracking, so by default we need to push a null block to\n          // avoid that. This isn\'t necessary if rendering a compiled `<slot>`.\n          if (!isRenderingCompiledSlot) {\n              openBlock(true /* null block that disables tracking */);\n          }\n          const owner = currentRenderingInstance;\n          setCurrentRenderingInstance(ctx);\n          const res = fn(...args);\n          setCurrentRenderingInstance(owner);\n          if (!isRenderingCompiledSlot) {\n              closeBlock();\n          }\n          return res;\n      };\n      renderFnWithContext._c = true;\n      return renderFnWithContext;\n  }\n\n  // SFC scoped style ID management.\n  let currentScopeId = null;\n  const scopeIdStack = [];\n  /**\n   * @private\n   */\n  function pushScopeId(id) {\n      scopeIdStack.push((currentScopeId = id));\n  }\n  /**\n   * @private\n   */\n  function popScopeId() {\n      scopeIdStack.pop();\n      currentScopeId = scopeIdStack[scopeIdStack.length - 1] || null;\n  }\n  /**\n   * @private\n   */\n  function withScopeId(id) {\n      return ((fn) => withCtx(function () {\n          pushScopeId(id);\n          const res = fn.apply(this, arguments);\n          popScopeId();\n          return res;\n      }));\n  }\n\n  function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison\n  isSSR = false) {\n      const props = {};\n      const attrs = {};\n      def(attrs, InternalObjectKey, 1);\n      setFullProps(instance, rawProps, props, attrs);\n      // validation\n      {\n          validateProps(props, instance);\n      }\n      if (isStateful) {\n          // stateful\n          instance.props = isSSR ? props : shallowReactive(props);\n      }\n      else {\n          if (!instance.type.props) {\n              // functional w/ optional props, props === attrs\n              instance.props = attrs;\n          }\n          else {\n              // functional w/ declared props\n              instance.props = props;\n          }\n      }\n      instance.attrs = attrs;\n  }\n  function updateProps(instance, rawProps, rawPrevProps, optimized) {\n      const { props, attrs, vnode: { patchFlag } } = instance;\n      const rawCurrentProps = toRaw(props);\n      const [options] = instance.propsOptions;\n      if (\n      // always force full diff in dev\n      // - #1942 if hmr is enabled with sfc component\n      // - vite#872 non-sfc component used by sfc component\n      !(\n          (instance.type.__hmrId ||\n              (instance.parent && instance.parent.type.__hmrId))) &&\n          (optimized || patchFlag > 0) &&\n          !(patchFlag & 16 /* FULL_PROPS */)) {\n          if (patchFlag & 8 /* PROPS */) {\n              // Compiler-generated props & no keys change, just set the updated\n              // the props.\n              const propsToUpdate = instance.vnode.dynamicProps;\n              for (let i = 0; i < propsToUpdate.length; i++) {\n                  const key = propsToUpdate[i];\n                  // PROPS flag guarantees rawProps to be non-null\n                  const value = rawProps[key];\n                  if (options) {\n                      // attr / props separation was done on init and will be consistent\n                      // in this code path, so just check if attrs have it.\n                      if (hasOwn(attrs, key)) {\n                          attrs[key] = value;\n                      }\n                      else {\n                          const camelizedKey = camelize(key);\n                          props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance);\n                      }\n                  }\n                  else {\n                      attrs[key] = value;\n                  }\n              }\n          }\n      }\n      else {\n          // full props update.\n          setFullProps(instance, rawProps, props, attrs);\n          // in case of dynamic props, check if we need to delete keys from\n          // the props object\n          let kebabKey;\n          for (const key in rawCurrentProps) {\n              if (!rawProps ||\n                  // for camelCase\n                  (!hasOwn(rawProps, key) &&\n                      // it\'s possible the original props was passed in as kebab-case\n                      // and converted to camelCase (#955)\n                      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey)))) {\n                  if (options) {\n                      if (rawPrevProps &&\n                          // for camelCase\n                          (rawPrevProps[key] !== undefined ||\n                              // for kebab-case\n                              rawPrevProps[kebabKey] !== undefined)) {\n                          props[key] = resolvePropValue(options, rawProps || EMPTY_OBJ, key, undefined, instance);\n                      }\n                  }\n                  else {\n                      delete props[key];\n                  }\n              }\n          }\n          // in the case of functional component w/o props declaration, props and\n          // attrs point to the same object so it should already have been updated.\n          if (attrs !== rawCurrentProps) {\n              for (const key in attrs) {\n                  if (!rawProps || !hasOwn(rawProps, key)) {\n                      delete attrs[key];\n                  }\n              }\n          }\n      }\n      // trigger updates for $attrs in case it\'s used in component slots\n      trigger(instance, "set" /* SET */, \'$attrs\');\n      if ( rawProps) {\n          validateProps(props, instance);\n      }\n  }\n  function setFullProps(instance, rawProps, props, attrs) {\n      const [options, needCastKeys] = instance.propsOptions;\n      if (rawProps) {\n          for (const key in rawProps) {\n              const value = rawProps[key];\n              // key, ref are reserved and never passed down\n              if (isReservedProp(key)) {\n                  continue;\n              }\n              // prop option names are camelized during normalization, so to support\n              // kebab -> camel conversion here we need to camelize the key.\n              let camelKey;\n              if (options && hasOwn(options, (camelKey = camelize(key)))) {\n                  props[camelKey] = value;\n              }\n              else if (!isEmitListener(instance.emitsOptions, key)) {\n                  // Any non-declared (either as a prop or an emitted event) props are put\n                  // into a separate `attrs` object for spreading. Make sure to preserve\n                  // original key casing\n                  attrs[key] = value;\n              }\n          }\n      }\n      if (needCastKeys) {\n          const rawCurrentProps = toRaw(props);\n          for (let i = 0; i < needCastKeys.length; i++) {\n              const key = needCastKeys[i];\n              props[key] = resolvePropValue(options, rawCurrentProps, key, rawCurrentProps[key], instance);\n          }\n      }\n  }\n  function resolvePropValue(options, props, key, value, instance) {\n      const opt = options[key];\n      if (opt != null) {\n          const hasDefault = hasOwn(opt, \'default\');\n          // default values\n          if (hasDefault && value === undefined) {\n              const defaultValue = opt.default;\n              if (opt.type !== Function && isFunction(defaultValue)) {\n                  setCurrentInstance(instance);\n                  value = defaultValue(props);\n                  setCurrentInstance(null);\n              }\n              else {\n                  value = defaultValue;\n              }\n          }\n          // boolean casting\n          if (opt[0 /* shouldCast */]) {\n              if (!hasOwn(props, key) && !hasDefault) {\n                  value = false;\n              }\n              else if (opt[1 /* shouldCastTrue */] &&\n                  (value === \'\' || value === hyphenate(key))) {\n                  value = true;\n              }\n          }\n      }\n      return value;\n  }\n  function normalizePropsOptions(comp, appContext, asMixin = false) {\n      if (!appContext.deopt && comp.__props) {\n          return comp.__props;\n      }\n      const raw = comp.props;\n      const normalized = {};\n      const needCastKeys = [];\n      // apply mixin/extends props\n      let hasExtends = false;\n      if ( !isFunction(comp)) {\n          const extendProps = (raw) => {\n              hasExtends = true;\n              const [props, keys] = normalizePropsOptions(raw, appContext, true);\n              extend(normalized, props);\n              if (keys)\n                  needCastKeys.push(...keys);\n          };\n          if (!asMixin && appContext.mixins.length) {\n              appContext.mixins.forEach(extendProps);\n          }\n          if (comp.extends) {\n              extendProps(comp.extends);\n          }\n          if (comp.mixins) {\n              comp.mixins.forEach(extendProps);\n          }\n      }\n      if (!raw && !hasExtends) {\n          return (comp.__props = EMPTY_ARR);\n      }\n      if (isArray(raw)) {\n          for (let i = 0; i < raw.length; i++) {\n              if ( !isString(raw[i])) {\n                  warn(`props must be strings when using array syntax.`, raw[i]);\n              }\n              const normalizedKey = camelize(raw[i]);\n              if (validatePropName(normalizedKey)) {\n                  normalized[normalizedKey] = EMPTY_OBJ;\n              }\n          }\n      }\n      else if (raw) {\n          if ( !isObject(raw)) {\n              warn(`invalid props options`, raw);\n          }\n          for (const key in raw) {\n              const normalizedKey = camelize(key);\n              if (validatePropName(normalizedKey)) {\n                  const opt = raw[key];\n                  const prop = (normalized[normalizedKey] =\n                      isArray(opt) || isFunction(opt) ? { type: opt } : opt);\n                  if (prop) {\n                      const booleanIndex = getTypeIndex(Boolean, prop.type);\n                      const stringIndex = getTypeIndex(String, prop.type);\n                      prop[0 /* shouldCast */] = booleanIndex > -1;\n                      prop[1 /* shouldCastTrue */] =\n                          stringIndex < 0 || booleanIndex < stringIndex;\n                      // if the prop needs boolean casting or default value\n                      if (booleanIndex > -1 || hasOwn(prop, \'default\')) {\n                          needCastKeys.push(normalizedKey);\n                      }\n                  }\n              }\n          }\n      }\n      return (comp.__props = [normalized, needCastKeys]);\n  }\n  function validatePropName(key) {\n      if (key[0] !== \'$\') {\n          return true;\n      }\n      else {\n          warn(`Invalid prop name: "${key}" is a reserved property.`);\n      }\n      return false;\n  }\n  // use function string name to check type constructors\n  // so that it works across vms / iframes.\n  function getType(ctor) {\n      const match = ctor && ctor.toString().match(/^\\s*function (\\w+)/);\n      return match ? match[1] : \'\';\n  }\n  function isSameType(a, b) {\n      return getType(a) === getType(b);\n  }\n  function getTypeIndex(type, expectedTypes) {\n      if (isArray(expectedTypes)) {\n          for (let i = 0, len = expectedTypes.length; i < len; i++) {\n              if (isSameType(expectedTypes[i], type)) {\n                  return i;\n              }\n          }\n      }\n      else if (isFunction(expectedTypes)) {\n          return isSameType(expectedTypes, type) ? 0 : -1;\n      }\n      return -1;\n  }\n  /**\n   * dev only\n   */\n  function validateProps(props, instance) {\n      const rawValues = toRaw(props);\n      const options = instance.propsOptions[0];\n      for (const key in options) {\n          let opt = options[key];\n          if (opt == null)\n              continue;\n          validateProp(key, rawValues[key], opt, !hasOwn(rawValues, key));\n      }\n  }\n  /**\n   * dev only\n   */\n  function validateProp(name, value, prop, isAbsent) {\n      const { type, required, validator } = prop;\n      // required!\n      if (required && isAbsent) {\n          warn(\'Missing required prop: "\' + name + \'"\');\n          return;\n      }\n      // missing but optional\n      if (value == null && !prop.required) {\n          return;\n      }\n      // type check\n      if (type != null && type !== true) {\n          let isValid = false;\n          const types = isArray(type) ? type : [type];\n          const expectedTypes = [];\n          // value is valid as long as one of the specified types match\n          for (let i = 0; i < types.length && !isValid; i++) {\n              const { valid, expectedType } = assertType(value, types[i]);\n              expectedTypes.push(expectedType || \'\');\n              isValid = valid;\n          }\n          if (!isValid) {\n              warn(getInvalidTypeMessage(name, value, expectedTypes));\n              return;\n          }\n      }\n      // custom validator\n      if (validator && !validator(value)) {\n          warn(\'Invalid prop: custom validator check failed for prop "\' + name + \'".\');\n      }\n  }\n  const isSimpleType = /*#__PURE__*/ makeMap(\'String,Number,Boolean,Function,Symbol\');\n  /**\n   * dev only\n   */\n  function assertType(value, type) {\n      let valid;\n      const expectedType = getType(type);\n      if (isSimpleType(expectedType)) {\n          const t = typeof value;\n          valid = t === expectedType.toLowerCase();\n          // for primitive wrapper objects\n          if (!valid && t === \'object\') {\n              valid = value instanceof type;\n          }\n      }\n      else if (expectedType === \'Object\') {\n          valid = isObject(value);\n      }\n      else if (expectedType === \'Array\') {\n          valid = isArray(value);\n      }\n      else {\n          valid = value instanceof type;\n      }\n      return {\n          valid,\n          expectedType\n      };\n  }\n  /**\n   * dev only\n   */\n  function getInvalidTypeMessage(name, value, expectedTypes) {\n      let message = `Invalid prop: type check failed for prop "${name}".` +\n          ` Expected ${expectedTypes.map(capitalize).join(\', \')}`;\n      const expectedType = expectedTypes[0];\n      const receivedType = toRawType(value);\n      const expectedValue = styleValue(value, expectedType);\n      const receivedValue = styleValue(value, receivedType);\n      // check if we need to specify expected value\n      if (expectedTypes.length === 1 &&\n          isExplicable(expectedType) &&\n          !isBoolean(expectedType, receivedType)) {\n          message += ` with value ${expectedValue}`;\n      }\n      message += `, got ${receivedType} `;\n      // check if we need to specify received value\n      if (isExplicable(receivedType)) {\n          message += `with value ${receivedValue}.`;\n      }\n      return message;\n  }\n  /**\n   * dev only\n   */\n  function styleValue(value, type) {\n      if (type === \'String\') {\n          return `"${value}"`;\n      }\n      else if (type === \'Number\') {\n          return `${Number(value)}`;\n      }\n      else {\n          return `${value}`;\n      }\n  }\n  /**\n   * dev only\n   */\n  function isExplicable(type) {\n      const explicitTypes = [\'string\', \'number\', \'boolean\'];\n      return explicitTypes.some(elem => type.toLowerCase() === elem);\n  }\n  /**\n   * dev only\n   */\n  function isBoolean(...args) {\n      return args.some(elem => elem.toLowerCase() === \'boolean\');\n  }\n\n  function injectHook(type, hook, target = currentInstance, prepend = false) {\n      if (target) {\n          const hooks = target[type] || (target[type] = []);\n          // cache the error handling wrapper for injected hooks so the same hook\n          // can be properly deduped by the scheduler. "__weh" stands for "with error\n          // handling".\n          const wrappedHook = hook.__weh ||\n              (hook.__weh = (...args) => {\n                  if (target.isUnmounted) {\n                      return;\n                  }\n                  // disable tracking inside all lifecycle hooks\n                  // since they can potentially be called inside effects.\n                  pauseTracking();\n                  // Set currentInstance during hook invocation.\n                  // This assumes the hook does not synchronously trigger other hooks, which\n                  // can only be false when the user does something really funky.\n                  setCurrentInstance(target);\n                  const res = callWithAsyncErrorHandling(hook, target, type, args);\n                  setCurrentInstance(null);\n                  resetTracking();\n                  return res;\n              });\n          if (prepend) {\n              hooks.unshift(wrappedHook);\n          }\n          else {\n              hooks.push(wrappedHook);\n          }\n          return wrappedHook;\n      }\n      else {\n          const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, \'\'));\n          warn(`${apiName} is called when there is no active component instance to be ` +\n              `associated with. ` +\n              `Lifecycle injection APIs can only be used during execution of setup().` +\n              ( ` If you are using async setup(), make sure to register lifecycle ` +\n                      `hooks before the first await statement.`\n                  ));\n      }\n  }\n  const createHook = (lifecycle) => (hook, target = currentInstance) => \n  // post-create lifecycle registrations are noops during SSR\n  !isInSSRComponentSetup && injectHook(lifecycle, hook, target);\n  const onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);\n  const onMounted = createHook("m" /* MOUNTED */);\n  const onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);\n  const onUpdated = createHook("u" /* UPDATED */);\n  const onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);\n  const onUnmounted = createHook("um" /* UNMOUNTED */);\n  const onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);\n  const onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);\n  const onErrorCaptured = (hook, target = currentInstance) => {\n      injectHook("ec" /* ERROR_CAPTURED */, hook, target);\n  };\n\n  // Simple effect.\n  function watchEffect(effect, options) {\n      return doWatch(effect, null, options);\n  }\n  // initial value for watchers to trigger on undefined initial values\n  const INITIAL_WATCHER_VALUE = {};\n  // implementation\n  function watch(source, cb, options) {\n      if ( !isFunction(cb)) {\n          warn(`\\`watch(fn, options?)\\` signature has been moved to a separate API. ` +\n              `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` +\n              `supports \\`watch(source, cb, options?) signature.`);\n      }\n      return doWatch(source, cb, options);\n  }\n  function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ, instance = currentInstance) {\n      if ( !cb) {\n          if (immediate !== undefined) {\n              warn(`watch() "immediate" option is only respected when using the ` +\n                  `watch(source, callback, options?) signature.`);\n          }\n          if (deep !== undefined) {\n              warn(`watch() "deep" option is only respected when using the ` +\n                  `watch(source, callback, options?) signature.`);\n          }\n      }\n      const warnInvalidSource = (s) => {\n          warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +\n              `a reactive object, or an array of these types.`);\n      };\n      let getter;\n      let forceTrigger = false;\n      if (isRef(source)) {\n          getter = () => source.value;\n          forceTrigger = !!source._shallow;\n      }\n      else if (isReactive(source)) {\n          getter = () => source;\n          deep = true;\n      }\n      else if (isArray(source)) {\n          getter = () => source.map(s => {\n              if (isRef(s)) {\n                  return s.value;\n              }\n              else if (isReactive(s)) {\n                  return traverse(s);\n              }\n              else if (isFunction(s)) {\n                  return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);\n              }\n              else {\n                   warnInvalidSource(s);\n              }\n          });\n      }\n      else if (isFunction(source)) {\n          if (cb) {\n              // getter with cb\n              getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);\n          }\n          else {\n              // no cb -> simple effect\n              getter = () => {\n                  if (instance && instance.isUnmounted) {\n                      return;\n                  }\n                  if (cleanup) {\n                      cleanup();\n                  }\n                  return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);\n              };\n          }\n      }\n      else {\n          getter = NOOP;\n           warnInvalidSource(source);\n      }\n      if (cb && deep) {\n          const baseGetter = getter;\n          getter = () => traverse(baseGetter());\n      }\n      let cleanup;\n      const onInvalidate = (fn) => {\n          cleanup = runner.options.onStop = () => {\n              callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\n          };\n      };\n      let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE;\n      const job = () => {\n          if (!runner.active) {\n              return;\n          }\n          if (cb) {\n              // watch(source, cb)\n              const newValue = runner();\n              if (deep || forceTrigger || hasChanged(newValue, oldValue)) {\n                  // cleanup before running cb again\n                  if (cleanup) {\n                      cleanup();\n                  }\n                  callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\n                      newValue,\n                      // pass undefined as the old value when it\'s changed for the first time\n                      oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\n                      onInvalidate\n                  ]);\n                  oldValue = newValue;\n              }\n          }\n          else {\n              // watchEffect\n              runner();\n          }\n      };\n      // important: mark the job as a watcher callback so that scheduler knows\n      // it is allowed to self-trigger (#1727)\n      job.allowRecurse = !!cb;\n      let scheduler;\n      if (flush === \'sync\') {\n          scheduler = job;\n      }\n      else if (flush === \'post\') {\n          scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\n      }\n      else {\n          // default: \'pre\'\n          scheduler = () => {\n              if (!instance || instance.isMounted) {\n                  queuePreFlushCb(job);\n              }\n              else {\n                  // with \'pre\' option, the first call must happen before\n                  // the component is mounted so it is called synchronously.\n                  job();\n              }\n          };\n      }\n      const runner = effect(getter, {\n          lazy: true,\n          onTrack,\n          onTrigger,\n          scheduler\n      });\n      recordInstanceBoundEffect(runner);\n      // initial run\n      if (cb) {\n          if (immediate) {\n              job();\n          }\n          else {\n              oldValue = runner();\n          }\n      }\n      else if (flush === \'post\') {\n          queuePostRenderEffect(runner, instance && instance.suspense);\n      }\n      else {\n          runner();\n      }\n      return () => {\n          stop(runner);\n          if (instance) {\n              remove(instance.effects, runner);\n          }\n      };\n  }\n  // this.$watch\n  function instanceWatch(source, cb, options) {\n      const publicThis = this.proxy;\n      const getter = isString(source)\n          ? () => publicThis[source]\n          : source.bind(publicThis);\n      return doWatch(getter, cb.bind(publicThis), options, this);\n  }\n  function traverse(value, seen = new Set()) {\n      if (!isObject(value) || seen.has(value)) {\n          return value;\n      }\n      seen.add(value);\n      if (isRef(value)) {\n          traverse(value.value, seen);\n      }\n      else if (isArray(value)) {\n          for (let i = 0; i < value.length; i++) {\n              traverse(value[i], seen);\n          }\n      }\n      else if (isSet(value) || isMap(value)) {\n          value.forEach((v) => {\n              traverse(v, seen);\n          });\n      }\n      else {\n          for (const key in value) {\n              traverse(value[key], seen);\n          }\n      }\n      return value;\n  }\n\n  function useTransitionState() {\n      const state = {\n          isMounted: false,\n          isLeaving: false,\n          isUnmounting: false,\n          leavingVNodes: new Map()\n      };\n      onMounted(() => {\n          state.isMounted = true;\n      });\n      onBeforeUnmount(() => {\n          state.isUnmounting = true;\n      });\n      return state;\n  }\n  const TransitionHookValidator = [Function, Array];\n  const BaseTransitionImpl = {\n      name: `BaseTransition`,\n      props: {\n          mode: String,\n          appear: Boolean,\n          persisted: Boolean,\n          // enter\n          onBeforeEnter: TransitionHookValidator,\n          onEnter: TransitionHookValidator,\n          onAfterEnter: TransitionHookValidator,\n          onEnterCancelled: TransitionHookValidator,\n          // leave\n          onBeforeLeave: TransitionHookValidator,\n          onLeave: TransitionHookValidator,\n          onAfterLeave: TransitionHookValidator,\n          onLeaveCancelled: TransitionHookValidator,\n          // appear\n          onBeforeAppear: TransitionHookValidator,\n          onAppear: TransitionHookValidator,\n          onAfterAppear: TransitionHookValidator,\n          onAppearCancelled: TransitionHookValidator\n      },\n      setup(props, { slots }) {\n          const instance = getCurrentInstance();\n          const state = useTransitionState();\n          let prevTransitionKey;\n          return () => {\n              const children = slots.default && getTransitionRawChildren(slots.default(), true);\n              if (!children || !children.length) {\n                  return;\n              }\n              // warn multiple elements\n              if ( children.length > 1) {\n                  warn(\'<transition> can only be used on a single element or component. Use \' +\n                      \'<transition-group> for lists.\');\n              }\n              // there\'s no need to track reactivity for these props so use the raw\n              // props for a bit better perf\n              const rawProps = toRaw(props);\n              const { mode } = rawProps;\n              // check mode\n              if ( mode && ![\'in-out\', \'out-in\', \'default\'].includes(mode)) {\n                  warn(`invalid <transition> mode: ${mode}`);\n              }\n              // at this point children has a guaranteed length of 1.\n              const child = children[0];\n              if (state.isLeaving) {\n                  return emptyPlaceholder(child);\n              }\n              // in the case of <transition><keep-alive/></transition>, we need to\n              // compare the type of the kept-alive children.\n              const innerChild = getKeepAliveChild(child);\n              if (!innerChild) {\n                  return emptyPlaceholder(child);\n              }\n              const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);\n              setTransitionHooks(innerChild, enterHooks);\n              const oldChild = instance.subTree;\n              const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\n              let transitionKeyChanged = false;\n              const { getTransitionKey } = innerChild.type;\n              if (getTransitionKey) {\n                  const key = getTransitionKey();\n                  if (prevTransitionKey === undefined) {\n                      prevTransitionKey = key;\n                  }\n                  else if (key !== prevTransitionKey) {\n                      prevTransitionKey = key;\n                      transitionKeyChanged = true;\n                  }\n              }\n              // handle mode\n              if (oldInnerChild &&\n                  oldInnerChild.type !== Comment &&\n                  (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {\n                  const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);\n                  // update old tree\'s hooks in case of dynamic transition\n                  setTransitionHooks(oldInnerChild, leavingHooks);\n                  // switching between different views\n                  if (mode === \'out-in\') {\n                      state.isLeaving = true;\n                      // return placeholder node and queue update when leave finishes\n                      leavingHooks.afterLeave = () => {\n                          state.isLeaving = false;\n                          instance.update();\n                      };\n                      return emptyPlaceholder(child);\n                  }\n                  else if (mode === \'in-out\') {\n                      leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\n                          const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);\n                          leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\n                          // early removal callback\n                          el._leaveCb = () => {\n                              earlyRemove();\n                              el._leaveCb = undefined;\n                              delete enterHooks.delayedLeave;\n                          };\n                          enterHooks.delayedLeave = delayedLeave;\n                      };\n                  }\n              }\n              return child;\n          };\n      }\n  };\n  // export the public type for h/tsx inference\n  // also to avoid inline import() in generated d.ts files\n  const BaseTransition = BaseTransitionImpl;\n  function getLeavingNodesForType(state, vnode) {\n      const { leavingVNodes } = state;\n      let leavingVNodesCache = leavingVNodes.get(vnode.type);\n      if (!leavingVNodesCache) {\n          leavingVNodesCache = Object.create(null);\n          leavingVNodes.set(vnode.type, leavingVNodesCache);\n      }\n      return leavingVNodesCache;\n  }\n  // The transition hooks are attached to the vnode as vnode.transition\n  // and will be called at appropriate timing in the renderer.\n  function resolveTransitionHooks(vnode, props, state, instance) {\n      const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;\n      const key = String(vnode.key);\n      const leavingVNodesCache = getLeavingNodesForType(state, vnode);\n      const callHook = (hook, args) => {\n          hook &&\n              callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);\n      };\n      const hooks = {\n          mode,\n          persisted,\n          beforeEnter(el) {\n              let hook = onBeforeEnter;\n              if (!state.isMounted) {\n                  if (appear) {\n                      hook = onBeforeAppear || onBeforeEnter;\n                  }\n                  else {\n                      return;\n                  }\n              }\n              // for same element (v-show)\n              if (el._leaveCb) {\n                  el._leaveCb(true /* cancelled */);\n              }\n              // for toggled element with same key (v-if)\n              const leavingVNode = leavingVNodesCache[key];\n              if (leavingVNode &&\n                  isSameVNodeType(vnode, leavingVNode) &&\n                  leavingVNode.el._leaveCb) {\n                  // force early removal (not cancelled)\n                  leavingVNode.el._leaveCb();\n              }\n              callHook(hook, [el]);\n          },\n          enter(el) {\n              let hook = onEnter;\n              let afterHook = onAfterEnter;\n              let cancelHook = onEnterCancelled;\n              if (!state.isMounted) {\n                  if (appear) {\n                      hook = onAppear || onEnter;\n                      afterHook = onAfterAppear || onAfterEnter;\n                      cancelHook = onAppearCancelled || onEnterCancelled;\n                  }\n                  else {\n                      return;\n                  }\n              }\n              let called = false;\n              const done = (el._enterCb = (cancelled) => {\n                  if (called)\n                      return;\n                  called = true;\n                  if (cancelled) {\n                      callHook(cancelHook, [el]);\n                  }\n                  else {\n                      callHook(afterHook, [el]);\n                  }\n                  if (hooks.delayedLeave) {\n                      hooks.delayedLeave();\n                  }\n                  el._enterCb = undefined;\n              });\n              if (hook) {\n                  hook(el, done);\n                  if (hook.length <= 1) {\n                      done();\n                  }\n              }\n              else {\n                  done();\n              }\n          },\n          leave(el, remove) {\n              const key = String(vnode.key);\n              if (el._enterCb) {\n                  el._enterCb(true /* cancelled */);\n              }\n              if (state.isUnmounting) {\n                  return remove();\n              }\n              callHook(onBeforeLeave, [el]);\n              let called = false;\n              const done = (el._leaveCb = (cancelled) => {\n                  if (called)\n                      return;\n                  called = true;\n                  remove();\n                  if (cancelled) {\n                      callHook(onLeaveCancelled, [el]);\n                  }\n                  else {\n                      callHook(onAfterLeave, [el]);\n                  }\n                  el._leaveCb = undefined;\n                  if (leavingVNodesCache[key] === vnode) {\n                      delete leavingVNodesCache[key];\n                  }\n              });\n              leavingVNodesCache[key] = vnode;\n              if (onLeave) {\n                  onLeave(el, done);\n                  if (onLeave.length <= 1) {\n                      done();\n                  }\n              }\n              else {\n                  done();\n              }\n          },\n          clone(vnode) {\n              return resolveTransitionHooks(vnode, props, state, instance);\n          }\n      };\n      return hooks;\n  }\n  // the placeholder really only handles one special case: KeepAlive\n  // in the case of a KeepAlive in a leave phase we need to return a KeepAlive\n  // placeholder with empty content to avoid the KeepAlive instance from being\n  // unmounted.\n  function emptyPlaceholder(vnode) {\n      if (isKeepAlive(vnode)) {\n          vnode = cloneVNode(vnode);\n          vnode.children = null;\n          return vnode;\n      }\n  }\n  function getKeepAliveChild(vnode) {\n      return isKeepAlive(vnode)\n          ? vnode.children\n              ? vnode.children[0]\n              : undefined\n          : vnode;\n  }\n  function setTransitionHooks(vnode, hooks) {\n      if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {\n          setTransitionHooks(vnode.component.subTree, hooks);\n      }\n      else if ( vnode.shapeFlag & 128 /* SUSPENSE */) {\n          vnode.ssContent.transition = hooks.clone(vnode.ssContent);\n          vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\n      }\n      else {\n          vnode.transition = hooks;\n      }\n  }\n  function getTransitionRawChildren(children, keepComment = false) {\n      let ret = [];\n      let keyedFragmentCount = 0;\n      for (let i = 0; i < children.length; i++) {\n          const child = children[i];\n          // handle fragment children case, e.g. v-for\n          if (child.type === Fragment) {\n              if (child.patchFlag & 128 /* KEYED_FRAGMENT */)\n                  keyedFragmentCount++;\n              ret = ret.concat(getTransitionRawChildren(child.children, keepComment));\n          }\n          // comment placeholders should be skipped, e.g. v-if\n          else if (keepComment || child.type !== Comment) {\n              ret.push(child);\n          }\n      }\n      // #1126 if a transition children list contains multiple sub fragments, these\n      // fragments will be merged into a flat children array. Since each v-for\n      // fragment may contain different static bindings inside, we need to de-top\n      // these children to force full diffs to ensure correct behavior.\n      if (keyedFragmentCount > 1) {\n          for (let i = 0; i < ret.length; i++) {\n              ret[i].patchFlag = -2 /* BAIL */;\n          }\n      }\n      return ret;\n  }\n\n  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;\n  const KeepAliveImpl = {\n      name: `KeepAlive`,\n      // Marker for special handling inside the renderer. We are not using a ===\n      // check directly on KeepAlive in the renderer, because importing it directly\n      // would prevent it from being tree-shaken.\n      __isKeepAlive: true,\n      inheritRef: true,\n      props: {\n          include: [String, RegExp, Array],\n          exclude: [String, RegExp, Array],\n          max: [String, Number]\n      },\n      setup(props, { slots }) {\n          const cache = new Map();\n          const keys = new Set();\n          let current = null;\n          const instance = getCurrentInstance();\n          const parentSuspense = instance.suspense;\n          // KeepAlive communicates with the instantiated renderer via the\n          // ctx where the renderer passes in its internals,\n          // and the KeepAlive instance exposes activate/deactivate implementations.\n          // The whole point of this is to avoid importing KeepAlive directly in the\n          // renderer to facilitate tree-shaking.\n          const sharedContext = instance.ctx;\n          const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;\n          const storageContainer = createElement(\'div\');\n          sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\n              const instance = vnode.component;\n              move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);\n              // in case props have changed\n              patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, optimized);\n              queuePostRenderEffect(() => {\n                  instance.isDeactivated = false;\n                  if (instance.a) {\n                      invokeArrayFns(instance.a);\n                  }\n                  const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\n                  if (vnodeHook) {\n                      invokeVNodeHook(vnodeHook, instance.parent, vnode);\n                  }\n              }, parentSuspense);\n          };\n          sharedContext.deactivate = (vnode) => {\n              const instance = vnode.component;\n              move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);\n              queuePostRenderEffect(() => {\n                  if (instance.da) {\n                      invokeArrayFns(instance.da);\n                  }\n                  const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\n                  if (vnodeHook) {\n                      invokeVNodeHook(vnodeHook, instance.parent, vnode);\n                  }\n                  instance.isDeactivated = true;\n              }, parentSuspense);\n          };\n          function unmount(vnode) {\n              // reset the shapeFlag so it can be properly unmounted\n              resetShapeFlag(vnode);\n              _unmount(vnode, instance, parentSuspense);\n          }\n          function pruneCache(filter) {\n              cache.forEach((vnode, key) => {\n                  const name = getName(vnode.type);\n                  if (name && (!filter || !filter(name))) {\n                      pruneCacheEntry(key);\n                  }\n              });\n          }\n          function pruneCacheEntry(key) {\n              const cached = cache.get(key);\n              if (!current || cached.type !== current.type) {\n                  unmount(cached);\n              }\n              else if (current) {\n                  // current active instance should no longer be kept-alive.\n                  // we can\'t unmount it now but it might be later, so reset its flag now.\n                  resetShapeFlag(current);\n              }\n              cache.delete(key);\n              keys.delete(key);\n          }\n          // prune cache on include/exclude prop change\n          watch(() => [props.include, props.exclude], ([include, exclude]) => {\n              include && pruneCache(name => matches(include, name));\n              exclude && pruneCache(name => !matches(exclude, name));\n          }, \n          // prune post-render after `current` has been updated\n          { flush: \'post\' });\n          // cache sub tree after render\n          let pendingCacheKey = null;\n          const cacheSubtree = () => {\n              // fix #1621, the pendingCacheKey could be 0\n              if (pendingCacheKey != null) {\n                  cache.set(pendingCacheKey, getInnerChild(instance.subTree));\n              }\n          };\n          onMounted(cacheSubtree);\n          onUpdated(cacheSubtree);\n          onBeforeUnmount(() => {\n              cache.forEach(cached => {\n                  const { subTree, suspense } = instance;\n                  const vnode = getInnerChild(subTree);\n                  if (cached.type === vnode.type) {\n                      // current instance will be unmounted as part of keep-alive\'s unmount\n                      resetShapeFlag(vnode);\n                      // but invoke its deactivated hook here\n                      const da = vnode.component.da;\n                      da && queuePostRenderEffect(da, suspense);\n                      return;\n                  }\n                  unmount(cached);\n              });\n          });\n          return () => {\n              pendingCacheKey = null;\n              if (!slots.default) {\n                  return null;\n              }\n              const children = slots.default();\n              const rawVNode = children[0];\n              if (children.length > 1) {\n                  {\n                      warn(`KeepAlive should contain exactly one component child.`);\n                  }\n                  current = null;\n                  return children;\n              }\n              else if (!isVNode(rawVNode) ||\n                  (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&\n                      !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {\n                  current = null;\n                  return rawVNode;\n              }\n              let vnode = getInnerChild(rawVNode);\n              const comp = vnode.type;\n              const name = getName(comp);\n              const { include, exclude, max } = props;\n              if ((include && (!name || !matches(include, name))) ||\n                  (exclude && name && matches(exclude, name))) {\n                  current = vnode;\n                  return rawVNode;\n              }\n              const key = vnode.key == null ? comp : vnode.key;\n              const cachedVNode = cache.get(key);\n              // clone vnode if it\'s reused because we are going to mutate it\n              if (vnode.el) {\n                  vnode = cloneVNode(vnode);\n                  if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {\n                      rawVNode.ssContent = vnode;\n                  }\n              }\n              // #1513 it\'s possible for the returned vnode to be cloned due to attr\n              // fallthrough or scopeId, so the vnode here may not be the final vnode\n              // that is mounted. Instead of caching it directly, we store the pending\n              // key and cache `instance.subTree` (the normalized vnode) in\n              // beforeMount/beforeUpdate hooks.\n              pendingCacheKey = key;\n              if (cachedVNode) {\n                  // copy over mounted state\n                  vnode.el = cachedVNode.el;\n                  vnode.component = cachedVNode.component;\n                  if (vnode.transition) {\n                      // recursively update transition hooks on subTree\n                      setTransitionHooks(vnode, vnode.transition);\n                  }\n                  // avoid vnode being mounted as fresh\n                  vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;\n                  // make this key the freshest\n                  keys.delete(key);\n                  keys.add(key);\n              }\n              else {\n                  keys.add(key);\n                  // prune oldest entry\n                  if (max && keys.size > parseInt(max, 10)) {\n                      pruneCacheEntry(keys.values().next().value);\n                  }\n              }\n              // avoid vnode being unmounted\n              vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\n              current = vnode;\n              return rawVNode;\n          };\n      }\n  };\n  // export the public type for h/tsx inference\n  // also to avoid inline import() in generated d.ts files\n  const KeepAlive = KeepAliveImpl;\n  function getName(comp) {\n      return comp.displayName || comp.name;\n  }\n  function matches(pattern, name) {\n      if (isArray(pattern)) {\n          return pattern.some((p) => matches(p, name));\n      }\n      else if (isString(pattern)) {\n          return pattern.split(\',\').indexOf(name) > -1;\n      }\n      else if (pattern.test) {\n          return pattern.test(name);\n      }\n      /* istanbul ignore next */\n      return false;\n  }\n  function onActivated(hook, target) {\n      registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);\n  }\n  function onDeactivated(hook, target) {\n      registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);\n  }\n  function registerKeepAliveHook(hook, type, target = currentInstance) {\n      // cache the deactivate branch check wrapper for injected hooks so the same\n      // hook can be properly deduped by the scheduler. "__wdc" stands for "with\n      // deactivation check".\n      const wrappedHook = hook.__wdc ||\n          (hook.__wdc = () => {\n              // only fire the hook if the target instance is NOT in a deactivated branch.\n              let current = target;\n              while (current) {\n                  if (current.isDeactivated) {\n                      return;\n                  }\n                  current = current.parent;\n              }\n              hook();\n          });\n      injectHook(type, wrappedHook, target);\n      // In addition to registering it on the target instance, we walk up the parent\n      // chain and register it on all ancestor instances that are keep-alive roots.\n      // This avoids the need to walk the entire component tree when invoking these\n      // hooks, and more importantly, avoids the need to track child components in\n      // arrays.\n      if (target) {\n          let current = target.parent;\n          while (current && current.parent) {\n              if (isKeepAlive(current.parent.vnode)) {\n                  injectToKeepAliveRoot(wrappedHook, type, target, current);\n              }\n              current = current.parent;\n          }\n      }\n  }\n  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\n      // injectHook wraps the original for error handling, so make sure to remove\n      // the wrapped version.\n      const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);\n      onUnmounted(() => {\n          remove(keepAliveRoot[type], injected);\n      }, target);\n  }\n  function resetShapeFlag(vnode) {\n      let shapeFlag = vnode.shapeFlag;\n      if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\n          shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\n      }\n      if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\n          shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;\n      }\n      vnode.shapeFlag = shapeFlag;\n  }\n  function getInnerChild(vnode) {\n      return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;\n  }\n\n  const isInternalKey = (key) => key[0] === \'_\' || key === \'$stable\';\n  const normalizeSlotValue = (value) => isArray(value)\n      ? value.map(normalizeVNode)\n      : [normalizeVNode(value)];\n  const normalizeSlot = (key, rawSlot, ctx) => withCtx((props) => {\n      if ( currentInstance) {\n          warn(`Slot "${key}" invoked outside of the render function: ` +\n              `this will not track dependencies used in the slot. ` +\n              `Invoke the slot function inside the render function instead.`);\n      }\n      return normalizeSlotValue(rawSlot(props));\n  }, ctx);\n  const normalizeObjectSlots = (rawSlots, slots) => {\n      const ctx = rawSlots._ctx;\n      for (const key in rawSlots) {\n          if (isInternalKey(key))\n              continue;\n          const value = rawSlots[key];\n          if (isFunction(value)) {\n              slots[key] = normalizeSlot(key, value, ctx);\n          }\n          else if (value != null) {\n              {\n                  warn(`Non-function value encountered for slot "${key}". ` +\n                      `Prefer function slots for better performance.`);\n              }\n              const normalized = normalizeSlotValue(value);\n              slots[key] = () => normalized;\n          }\n      }\n  };\n  const normalizeVNodeSlots = (instance, children) => {\n      if ( !isKeepAlive(instance.vnode)) {\n          warn(`Non-function value encountered for default slot. ` +\n              `Prefer function slots for better performance.`);\n      }\n      const normalized = normalizeSlotValue(children);\n      instance.slots.default = () => normalized;\n  };\n  const initSlots = (instance, children) => {\n      if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\n          const type = children._;\n          if (type) {\n              instance.slots = children;\n              // make compiler marker non-enumerable\n              def(children, \'_\', type);\n          }\n          else {\n              normalizeObjectSlots(children, (instance.slots = {}));\n          }\n      }\n      else {\n          instance.slots = {};\n          if (children) {\n              normalizeVNodeSlots(instance, children);\n          }\n      }\n      def(instance.slots, InternalObjectKey, 1);\n  };\n  const updateSlots = (instance, children) => {\n      const { vnode, slots } = instance;\n      let needDeletionCheck = true;\n      let deletionComparisonTarget = EMPTY_OBJ;\n      if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\n          const type = children._;\n          if (type) {\n              // compiled slots.\n              if ( isHmrUpdating) {\n                  // Parent was HMR updated so slot content may have changed.\n                  // force update slots and mark instance for hmr as well\n                  extend(slots, children);\n              }\n              else if (type === 1 /* STABLE */) {\n                  // compiled AND stable.\n                  // no need to update, and skip stale slots removal.\n                  needDeletionCheck = false;\n              }\n              else {\n                  // compiled but dynamic (v-if/v-for on slots) - update slots, but skip\n                  // normalization.\n                  extend(slots, children);\n              }\n          }\n          else {\n              needDeletionCheck = !children.$stable;\n              normalizeObjectSlots(children, slots);\n          }\n          deletionComparisonTarget = children;\n      }\n      else if (children) {\n          // non slot object children (direct value) passed to a component\n          normalizeVNodeSlots(instance, children);\n          deletionComparisonTarget = { default: 1 };\n      }\n      // delete stale slots\n      if (needDeletionCheck) {\n          for (const key in slots) {\n              if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {\n                  delete slots[key];\n              }\n          }\n      }\n  };\n\n  /**\n  Runtime helper for applying directives to a vnode. Example usage:\n\n  const comp = resolveComponent(\'comp\')\n  const foo = resolveDirective(\'foo\')\n  const bar = resolveDirective(\'bar\')\n\n  return withDirectives(h(comp), [\n    [foo, this.x],\n    [bar, this.y]\n  ])\n  */\n  const isBuiltInDirective = /*#__PURE__*/ makeMap(\'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text\');\n  function validateDirectiveName(name) {\n      if (isBuiltInDirective(name)) {\n          warn(\'Do not use built-in directive ids as custom directive id: \' + name);\n      }\n  }\n  /**\n   * Adds directives to a VNode.\n   */\n  function withDirectives(vnode, directives) {\n      const internalInstance = currentRenderingInstance;\n      if (internalInstance === null) {\n           warn(`withDirectives can only be used inside render functions.`);\n          return vnode;\n      }\n      const instance = internalInstance.proxy;\n      const bindings = vnode.dirs || (vnode.dirs = []);\n      for (let i = 0; i < directives.length; i++) {\n          let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];\n          if (isFunction(dir)) {\n              dir = {\n                  mounted: dir,\n                  updated: dir\n              };\n          }\n          bindings.push({\n              dir,\n              instance,\n              value,\n              oldValue: void 0,\n              arg,\n              modifiers\n          });\n      }\n      return vnode;\n  }\n  function invokeDirectiveHook(vnode, prevVNode, instance, name) {\n      const bindings = vnode.dirs;\n      const oldBindings = prevVNode && prevVNode.dirs;\n      for (let i = 0; i < bindings.length; i++) {\n          const binding = bindings[i];\n          if (oldBindings) {\n              binding.oldValue = oldBindings[i].value;\n          }\n          const hook = binding.dir[name];\n          if (hook) {\n              callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [\n                  vnode.el,\n                  binding,\n                  vnode,\n                  prevVNode\n              ]);\n          }\n      }\n  }\n\n  function createAppContext() {\n      return {\n          app: null,\n          config: {\n              isNativeTag: NO,\n              performance: false,\n              globalProperties: {},\n              optionMergeStrategies: {},\n              isCustomElement: NO,\n              errorHandler: undefined,\n              warnHandler: undefined\n          },\n          mixins: [],\n          components: {},\n          directives: {},\n          provides: Object.create(null)\n      };\n  }\n  let uid$1 = 0;\n  function createAppAPI(render, hydrate) {\n      return function createApp(rootComponent, rootProps = null) {\n          if (rootProps != null && !isObject(rootProps)) {\n               warn(`root props passed to app.mount() must be an object.`);\n              rootProps = null;\n          }\n          const context = createAppContext();\n          const installedPlugins = new Set();\n          let isMounted = false;\n          const app = (context.app = {\n              _uid: uid$1++,\n              _component: rootComponent,\n              _props: rootProps,\n              _container: null,\n              _context: context,\n              version,\n              get config() {\n                  return context.config;\n              },\n              set config(v) {\n                  {\n                      warn(`app.config cannot be replaced. Modify individual options instead.`);\n                  }\n              },\n              use(plugin, ...options) {\n                  if (installedPlugins.has(plugin)) {\n                       warn(`Plugin has already been applied to target app.`);\n                  }\n                  else if (plugin && isFunction(plugin.install)) {\n                      installedPlugins.add(plugin);\n                      plugin.install(app, ...options);\n                  }\n                  else if (isFunction(plugin)) {\n                      installedPlugins.add(plugin);\n                      plugin(app, ...options);\n                  }\n                  else {\n                      warn(`A plugin must either be a function or an object with an "install" ` +\n                          `function.`);\n                  }\n                  return app;\n              },\n              mixin(mixin) {\n                  {\n                      if (!context.mixins.includes(mixin)) {\n                          context.mixins.push(mixin);\n                          // global mixin with props/emits de-optimizes props/emits\n                          // normalization caching.\n                          if (mixin.props || mixin.emits) {\n                              context.deopt = true;\n                          }\n                      }\n                      else {\n                          warn(\'Mixin has already been applied to target app\' +\n                              (mixin.name ? `: ${mixin.name}` : \'\'));\n                      }\n                  }\n                  return app;\n              },\n              component(name, component) {\n                  {\n                      validateComponentName(name, context.config);\n                  }\n                  if (!component) {\n                      return context.components[name];\n                  }\n                  if ( context.components[name]) {\n                      warn(`Component "${name}" has already been registered in target app.`);\n                  }\n                  context.components[name] = component;\n                  return app;\n              },\n              directive(name, directive) {\n                  {\n                      validateDirectiveName(name);\n                  }\n                  if (!directive) {\n                      return context.directives[name];\n                  }\n                  if ( context.directives[name]) {\n                      warn(`Directive "${name}" has already been registered in target app.`);\n                  }\n                  context.directives[name] = directive;\n                  return app;\n              },\n              mount(rootContainer, isHydrate) {\n                  if (!isMounted) {\n                      const vnode = createVNode(rootComponent, rootProps);\n                      // store app context on the root VNode.\n                      // this will be set on the root instance on initial mount.\n                      vnode.appContext = context;\n                      // HMR root reload\n                      {\n                          context.reload = () => {\n                              render(cloneVNode(vnode), rootContainer);\n                          };\n                      }\n                      if (isHydrate && hydrate) {\n                          hydrate(vnode, rootContainer);\n                      }\n                      else {\n                          render(vnode, rootContainer);\n                      }\n                      isMounted = true;\n                      app._container = rootContainer;\n                      rootContainer.__vue_app__ = app;\n                      {\n                          devtoolsInitApp(app, version);\n                      }\n                      return vnode.component.proxy;\n                  }\n                  else {\n                      warn(`App has already been mounted.\\n` +\n                          `If you want to remount the same app, move your app creation logic ` +\n                          `into a factory function and create fresh app instances for each ` +\n                          `mount - e.g. \\`const createMyApp = () => createApp(App)\\``);\n                  }\n              },\n              unmount() {\n                  if (isMounted) {\n                      render(null, app._container);\n                      {\n                          devtoolsUnmountApp(app);\n                      }\n                  }\n                  else {\n                      warn(`Cannot unmount an app that is not mounted.`);\n                  }\n              },\n              provide(key, value) {\n                  if ( key in context.provides) {\n                      warn(`App already provides property with key "${String(key)}". ` +\n                          `It will be overwritten with the new value.`);\n                  }\n                  // TypeScript doesn\'t allow symbols as index type\n                  // https://github.com/Microsoft/TypeScript/issues/24587\n                  context.provides[key] = value;\n                  return app;\n              }\n          });\n          return app;\n      };\n  }\n\n  let hasMismatch = false;\n  const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== \'foreignObject\';\n  const isComment = (node) => node.nodeType === 8 /* COMMENT */;\n  // Note: hydration is DOM-specific\n  // But we have to place it in core due to tight coupling with core - splitting\n  // it out creates a ton of unnecessary complexity.\n  // Hydration also depends on some renderer internal logic which needs to be\n  // passed in via arguments.\n  function createHydrationFunctions(rendererInternals) {\n      const { mt: mountComponent, p: patch, o: { patchProp, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;\n      const hydrate = (vnode, container) => {\n          if ( !container.hasChildNodes()) {\n              warn(`Attempting to hydrate existing markup but container is empty. ` +\n                  `Performing full mount instead.`);\n              patch(null, vnode, container);\n              return;\n          }\n          hasMismatch = false;\n          hydrateNode(container.firstChild, vnode, null, null);\n          flushPostFlushCbs();\n          if (hasMismatch && !false) {\n              // this error should show up in production\n              console.error(`Hydration completed but contains mismatches.`);\n          }\n      };\n      const hydrateNode = (node, vnode, parentComponent, parentSuspense, optimized = false) => {\n          const isFragmentStart = isComment(node) && node.data === \'[\';\n          const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, isFragmentStart);\n          const { type, ref, shapeFlag } = vnode;\n          const domType = node.nodeType;\n          vnode.el = node;\n          let nextNode = null;\n          switch (type) {\n              case Text:\n                  if (domType !== 3 /* TEXT */) {\n                      nextNode = onMismatch();\n                  }\n                  else {\n                      if (node.data !== vnode.children) {\n                          hasMismatch = true;\n                          \n                              warn(`Hydration text mismatch:` +\n                                  `\\n- Client: ${JSON.stringify(node.data)}` +\n                                  `\\n- Server: ${JSON.stringify(vnode.children)}`);\n                          node.data = vnode.children;\n                      }\n                      nextNode = nextSibling(node);\n                  }\n                  break;\n              case Comment:\n                  if (domType !== 8 /* COMMENT */ || isFragmentStart) {\n                      nextNode = onMismatch();\n                  }\n                  else {\n                      nextNode = nextSibling(node);\n                  }\n                  break;\n              case Static:\n                  if (domType !== 1 /* ELEMENT */) {\n                      nextNode = onMismatch();\n                  }\n                  else {\n                      // determine anchor, adopt content\n                      nextNode = node;\n                      // if the static vnode has its content stripped during build,\n                      // adopt it from the server-rendered HTML.\n                      const needToAdoptContent = !vnode.children.length;\n                      for (let i = 0; i < vnode.staticCount; i++) {\n                          if (needToAdoptContent)\n                              vnode.children += nextNode.outerHTML;\n                          if (i === vnode.staticCount - 1) {\n                              vnode.anchor = nextNode;\n                          }\n                          nextNode = nextSibling(nextNode);\n                      }\n                      return nextNode;\n                  }\n                  break;\n              case Fragment:\n                  if (!isFragmentStart) {\n                      nextNode = onMismatch();\n                  }\n                  else {\n                      nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, optimized);\n                  }\n                  break;\n              default:\n                  if (shapeFlag & 1 /* ELEMENT */) {\n                      if (domType !== 1 /* ELEMENT */ ||\n                          vnode.type !== node.tagName.toLowerCase()) {\n                          nextNode = onMismatch();\n                      }\n                      else {\n                          nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, optimized);\n                      }\n                  }\n                  else if (shapeFlag & 6 /* COMPONENT */) {\n                      // when setting up the render effect, if the initial vnode already\n                      // has .el set, the component will perform hydration instead of mount\n                      // on its sub-tree.\n                      const container = parentNode(node);\n                      const hydrateComponent = () => {\n                          mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);\n                      };\n                      // async component\n                      const loadAsync = vnode.type.__asyncLoader;\n                      if (loadAsync) {\n                          loadAsync().then(hydrateComponent);\n                      }\n                      else {\n                          hydrateComponent();\n                      }\n                      // component may be async, so in the case of fragments we cannot rely\n                      // on component\'s rendered output to determine the end of the fragment\n                      // instead, we do a lookahead to find the end anchor node.\n                      nextNode = isFragmentStart\n                          ? locateClosingAsyncAnchor(node)\n                          : nextSibling(node);\n                  }\n                  else if (shapeFlag & 64 /* TELEPORT */) {\n                      if (domType !== 8 /* COMMENT */) {\n                          nextNode = onMismatch();\n                      }\n                      else {\n                          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, optimized, rendererInternals, hydrateChildren);\n                      }\n                  }\n                  else if ( shapeFlag & 128 /* SUSPENSE */) {\n                      nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), optimized, rendererInternals, hydrateNode);\n                  }\n                  else {\n                      warn(\'Invalid HostVNode type:\', type, `(${typeof type})`);\n                  }\n          }\n          if (ref != null && parentComponent) {\n              setRef(ref, null, parentComponent, parentSuspense, vnode);\n          }\n          return nextNode;\n      };\n      const hydrateElement = (el, vnode, parentComponent, parentSuspense, optimized) => {\n          optimized = optimized || !!vnode.dynamicChildren;\n          const { props, patchFlag, shapeFlag, dirs } = vnode;\n          // skip props & children if this is hoisted static nodes\n          if (patchFlag !== -1 /* HOISTED */) {\n              if (dirs) {\n                  invokeDirectiveHook(vnode, null, parentComponent, \'created\');\n              }\n              // props\n              if (props) {\n                  if (!optimized ||\n                      (patchFlag & 16 /* FULL_PROPS */ ||\n                          patchFlag & 32 /* HYDRATE_EVENTS */)) {\n                      for (const key in props) {\n                          if (!isReservedProp(key) && isOn(key)) {\n                              patchProp(el, key, null, props[key]);\n                          }\n                      }\n                  }\n                  else if (props.onClick) {\n                      // Fast path for click listeners (which is most often) to avoid\n                      // iterating through props.\n                      patchProp(el, \'onClick\', null, props.onClick);\n                  }\n              }\n              // vnode / directive hooks\n              let vnodeHooks;\n              if ((vnodeHooks = props && props.onVnodeBeforeMount)) {\n                  invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n              }\n              if (dirs) {\n                  invokeDirectiveHook(vnode, null, parentComponent, \'beforeMount\');\n              }\n              if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {\n                  queueEffectWithSuspense(() => {\n                      vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n                      dirs && invokeDirectiveHook(vnode, null, parentComponent, \'mounted\');\n                  }, parentSuspense);\n              }\n              // children\n              if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&\n                  // skip if element has innerHTML / textContent\n                  !(props && (props.innerHTML || props.textContent))) {\n                  let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, optimized);\n                  let hasWarned = false;\n                  while (next) {\n                      hasMismatch = true;\n                      if ( !hasWarned) {\n                          warn(`Hydration children mismatch in <${vnode.type}>: ` +\n                              `server rendered element contains more child nodes than client vdom.`);\n                          hasWarned = true;\n                      }\n                      // The SSRed DOM contains more nodes than it should. Remove them.\n                      const cur = next;\n                      next = next.nextSibling;\n                      remove(cur);\n                  }\n              }\n              else if (shapeFlag & 8 /* TEXT_CHILDREN */) {\n                  if (el.textContent !== vnode.children) {\n                      hasMismatch = true;\n                      \n                          warn(`Hydration text content mismatch in <${vnode.type}>:\\n` +\n                              `- Client: ${el.textContent}\\n` +\n                              `- Server: ${vnode.children}`);\n                      el.textContent = vnode.children;\n                  }\n              }\n          }\n          return el.nextSibling;\n      };\n      const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, optimized) => {\n          optimized = optimized || !!parentVNode.dynamicChildren;\n          const children = parentVNode.children;\n          const l = children.length;\n          let hasWarned = false;\n          for (let i = 0; i < l; i++) {\n              const vnode = optimized\n                  ? children[i]\n                  : (children[i] = normalizeVNode(children[i]));\n              if (node) {\n                  node = hydrateNode(node, vnode, parentComponent, parentSuspense, optimized);\n              }\n              else {\n                  hasMismatch = true;\n                  if ( !hasWarned) {\n                      warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +\n                          `server rendered element contains fewer child nodes than client vdom.`);\n                      hasWarned = true;\n                  }\n                  // the SSRed DOM didn\'t contain enough nodes. Mount the missing ones.\n                  patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container));\n              }\n          }\n          return node;\n      };\n      const hydrateFragment = (node, vnode, parentComponent, parentSuspense, optimized) => {\n          const container = parentNode(node);\n          const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, optimized);\n          if (next && isComment(next) && next.data === \']\') {\n              return nextSibling((vnode.anchor = next));\n          }\n          else {\n              // fragment didn\'t hydrate successfully, since we didn\'t get a end anchor\n              // back. This should have led to node/children mismatch warnings.\n              hasMismatch = true;\n              // since the anchor is missing, we need to create one and insert it\n              insert((vnode.anchor = createComment(`]`)), container, next);\n              return next;\n          }\n      };\n      const handleMismatch = (node, vnode, parentComponent, parentSuspense, isFragment) => {\n          hasMismatch = true;\n          \n              warn(`Hydration node mismatch:\\n- Client vnode:`, vnode.type, `\\n- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */\n                  ? `(text)`\n                  : isComment(node) && node.data === \'[\'\n                      ? `(start of fragment)`\n                      : ``);\n          vnode.el = null;\n          if (isFragment) {\n              // remove excessive fragment nodes\n              const end = locateClosingAsyncAnchor(node);\n              while (true) {\n                  const next = nextSibling(node);\n                  if (next && next !== end) {\n                      remove(next);\n                  }\n                  else {\n                      break;\n                  }\n              }\n          }\n          const next = nextSibling(node);\n          const container = parentNode(node);\n          remove(node);\n          patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container));\n          return next;\n      };\n      const locateClosingAsyncAnchor = (node) => {\n          let match = 0;\n          while (node) {\n              node = nextSibling(node);\n              if (node && isComment(node)) {\n                  if (node.data === \'[\')\n                      match++;\n                  if (node.data === \']\') {\n                      if (match === 0) {\n                          return nextSibling(node);\n                      }\n                      else {\n                          match--;\n                      }\n                  }\n              }\n          }\n          return node;\n      };\n      return [hydrate, hydrateNode];\n  }\n\n  let supported;\n  let perf;\n  function startMeasure(instance, type) {\n      if (instance.appContext.config.performance && isSupported()) {\n          perf.mark(`vue-${type}-${instance.uid}`);\n      }\n  }\n  function endMeasure(instance, type) {\n      if (instance.appContext.config.performance && isSupported()) {\n          const startTag = `vue-${type}-${instance.uid}`;\n          const endTag = startTag + `:end`;\n          perf.mark(endTag);\n          perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);\n          perf.clearMarks(startTag);\n          perf.clearMarks(endTag);\n      }\n  }\n  function isSupported() {\n      if (supported !== undefined) {\n          return supported;\n      }\n      /* eslint-disable no-restricted-globals */\n      if (typeof window !== \'undefined\' && window.performance) {\n          supported = true;\n          perf = window.performance;\n      }\n      else {\n          supported = false;\n      }\n      /* eslint-enable no-restricted-globals */\n      return supported;\n  }\n\n  function createDevEffectOptions(instance) {\n      return {\n          scheduler: queueJob,\n          allowRecurse: true,\n          onTrack: instance.rtc ? e => invokeArrayFns(instance.rtc, e) : void 0,\n          onTrigger: instance.rtg ? e => invokeArrayFns(instance.rtg, e) : void 0\n      };\n  }\n  const queuePostRenderEffect =  queueEffectWithSuspense\n      ;\n  const setRef = (rawRef, oldRawRef, parentComponent, parentSuspense, vnode) => {\n      if (isArray(rawRef)) {\n          rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentComponent, parentSuspense, vnode));\n          return;\n      }\n      let value;\n      if (!vnode) {\n          value = null;\n      }\n      else {\n          if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\n              value = vnode.component.proxy;\n          }\n          else {\n              value = vnode.el;\n          }\n      }\n      const { i: owner, r: ref } = rawRef;\n      if ( !owner) {\n          warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +\n              `A vnode with ref must be created inside the render function.`);\n          return;\n      }\n      const oldRef = oldRawRef && oldRawRef.r;\n      const refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs;\n      const setupState = owner.setupState;\n      // unset old ref\n      if (oldRef != null && oldRef !== ref) {\n          if (isString(oldRef)) {\n              refs[oldRef] = null;\n              if (hasOwn(setupState, oldRef)) {\n                  setupState[oldRef] = null;\n              }\n          }\n          else if (isRef(oldRef)) {\n              oldRef.value = null;\n          }\n      }\n      if (isString(ref)) {\n          const doSet = () => {\n              refs[ref] = value;\n              if (hasOwn(setupState, ref)) {\n                  setupState[ref] = value;\n              }\n          };\n          // #1789: for non-null values, set them after render\n          // null values means this is unmount and it should not overwrite another\n          // ref with the same key\n          if (value) {\n              doSet.id = -1;\n              queuePostRenderEffect(doSet, parentSuspense);\n          }\n          else {\n              doSet();\n          }\n      }\n      else if (isRef(ref)) {\n          const doSet = () => {\n              ref.value = value;\n          };\n          if (value) {\n              doSet.id = -1;\n              queuePostRenderEffect(doSet, parentSuspense);\n          }\n          else {\n              doSet();\n          }\n      }\n      else if (isFunction(ref)) {\n          callWithErrorHandling(ref, parentComponent, 12 /* FUNCTION_REF */, [\n              value,\n              refs\n          ]);\n      }\n      else {\n          warn(\'Invalid template ref type:\', value, `(${typeof value})`);\n      }\n  };\n  /**\n   * The createRenderer function accepts two generic arguments:\n   * HostNode and HostElement, corresponding to Node and Element types in the\n   * host environment. For example, for runtime-dom, HostNode would be the DOM\n   * `Node` interface and HostElement would be the DOM `Element` interface.\n   *\n   * Custom renderers can pass in the platform specific types like this:\n   *\n   * ``` js\n   * const { render, createApp } = createRenderer<Node, Element>({\n   *   patchProp,\n   *   ...nodeOps\n   * })\n   * ```\n   */\n  function createRenderer(options) {\n      return baseCreateRenderer(options);\n  }\n  // Separate API for creating hydration-enabled renderer.\n  // Hydration logic is only used when calling this function, making it\n  // tree-shakable.\n  function createHydrationRenderer(options) {\n      return baseCreateRenderer(options, createHydrationFunctions);\n  }\n  // implementation\n  function baseCreateRenderer(options, createHydrationFns) {\n      const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, forcePatchProp: hostForcePatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;\n      // Note: functions inside this closure should use `const xxx = () => {}`\n      // style in order to prevent being inlined by minifiers.\n      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) => {\n          // patching & not same type, unmount old tree\n          if (n1 && !isSameVNodeType(n1, n2)) {\n              anchor = getNextHostNode(n1);\n              unmount(n1, parentComponent, parentSuspense, true);\n              n1 = null;\n          }\n          if (n2.patchFlag === -2 /* BAIL */) {\n              optimized = false;\n              n2.dynamicChildren = null;\n          }\n          const { type, ref, shapeFlag } = n2;\n          switch (type) {\n              case Text:\n                  processText(n1, n2, container, anchor);\n                  break;\n              case Comment:\n                  processCommentNode(n1, n2, container, anchor);\n                  break;\n              case Static:\n                  if (n1 == null) {\n                      mountStaticNode(n2, container, anchor, isSVG);\n                  }\n                  else {\n                      patchStaticNode(n1, n2, container, isSVG);\n                  }\n                  break;\n              case Fragment:\n                  processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n                  break;\n              default:\n                  if (shapeFlag & 1 /* ELEMENT */) {\n                      processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n                  }\n                  else if (shapeFlag & 6 /* COMPONENT */) {\n                      processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n                  }\n                  else if (shapeFlag & 64 /* TELEPORT */) {\n                      type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);\n                  }\n                  else if ( shapeFlag & 128 /* SUSPENSE */) {\n                      type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);\n                  }\n                  else {\n                      warn(\'Invalid VNode type:\', type, `(${typeof type})`);\n                  }\n          }\n          // set ref\n          if (ref != null && parentComponent) {\n              setRef(ref, n1 && n1.ref, parentComponent, parentSuspense, n2);\n          }\n      };\n      const processText = (n1, n2, container, anchor) => {\n          if (n1 == null) {\n              hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);\n          }\n          else {\n              const el = (n2.el = n1.el);\n              if (n2.children !== n1.children) {\n                  hostSetText(el, n2.children);\n              }\n          }\n      };\n      const processCommentNode = (n1, n2, container, anchor) => {\n          if (n1 == null) {\n              hostInsert((n2.el = hostCreateComment(n2.children || \'\')), container, anchor);\n          }\n          else {\n              // there\'s no support for dynamic comments\n              n2.el = n1.el;\n          }\n      };\n      const mountStaticNode = (n2, container, anchor, isSVG) => {\n          [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\n      };\n      /**\n       * Dev / HMR only\n       */\n      const patchStaticNode = (n1, n2, container, isSVG) => {\n          // static nodes are only patched during dev for HMR\n          if (n2.children !== n1.children) {\n              const anchor = hostNextSibling(n1.anchor);\n              // remove existing\n              removeStaticNode(n1);\n              [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\n          }\n          else {\n              n2.el = n1.el;\n              n2.anchor = n1.anchor;\n          }\n      };\n      /**\n       * Dev / HMR only\n       */\n      const moveStaticNode = (vnode, container, anchor) => {\n          let cur = vnode.el;\n          const end = vnode.anchor;\n          while (cur && cur !== end) {\n              const next = hostNextSibling(cur);\n              hostInsert(cur, container, anchor);\n              cur = next;\n          }\n          hostInsert(end, container, anchor);\n      };\n      /**\n       * Dev / HMR only\n       */\n      const removeStaticNode = (vnode) => {\n          let cur = vnode.el;\n          while (cur && cur !== vnode.anchor) {\n              const next = hostNextSibling(cur);\n              hostRemove(cur);\n              cur = next;\n          }\n          hostRemove(vnode.anchor);\n      };\n      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n          isSVG = isSVG || n2.type === \'svg\';\n          if (n1 == null) {\n              mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n          }\n          else {\n              patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);\n          }\n      };\n      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n          let el;\n          let vnodeHook;\n          const { type, props, shapeFlag, transition, scopeId, patchFlag, dirs } = vnode;\n          {\n              el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is);\n              // mount children first, since some props may rely on child content\n              // being already rendered, e.g. `<select value>`\n              if (shapeFlag & 8 /* TEXT_CHILDREN */) {\n                  hostSetElementText(el, vnode.children);\n              }\n              else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\n                  mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== \'foreignObject\', optimized || !!vnode.dynamicChildren);\n              }\n              if (dirs) {\n                  invokeDirectiveHook(vnode, null, parentComponent, \'created\');\n              }\n              // props\n              if (props) {\n                  for (const key in props) {\n                      if (!isReservedProp(key)) {\n                          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n                      }\n                  }\n                  if ((vnodeHook = props.onVnodeBeforeMount)) {\n                      invokeVNodeHook(vnodeHook, parentComponent, vnode);\n                  }\n              }\n              // scopeId\n              setScopeId(el, scopeId, vnode, parentComponent);\n          }\n          {\n              Object.defineProperty(el, \'__vnode\', {\n                  value: vnode,\n                  enumerable: false\n              });\n              Object.defineProperty(el, \'__vueParentComponent\', {\n                  value: parentComponent,\n                  enumerable: false\n              });\n          }\n          if (dirs) {\n              invokeDirectiveHook(vnode, null, parentComponent, \'beforeMount\');\n          }\n          // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\n          // #1689 For inside suspense + suspense resolved case, just call it\n          const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&\n              transition &&\n              !transition.persisted;\n          if (needCallTransitionHooks) {\n              transition.beforeEnter(el);\n          }\n          hostInsert(el, container, anchor);\n          if ((vnodeHook = props && props.onVnodeMounted) ||\n              needCallTransitionHooks ||\n              dirs) {\n              queuePostRenderEffect(() => {\n                  vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n                  needCallTransitionHooks && transition.enter(el);\n                  dirs && invokeDirectiveHook(vnode, null, parentComponent, \'mounted\');\n              }, parentSuspense);\n          }\n      };\n      const setScopeId = (el, scopeId, vnode, parentComponent) => {\n          if (scopeId) {\n              hostSetScopeId(el, scopeId);\n          }\n          if (parentComponent) {\n              const treeOwnerId = parentComponent.type.__scopeId;\n              // vnode\'s own scopeId and the current patched component\'s scopeId is\n              // different - this is a slot content node.\n              if (treeOwnerId && treeOwnerId !== scopeId) {\n                  hostSetScopeId(el, treeOwnerId + \'-s\');\n              }\n              let subTree = parentComponent.subTree;\n              if ( subTree.type === Fragment) {\n                  subTree =\n                      filterSingleRoot(subTree.children) || subTree;\n              }\n              if (vnode === subTree) {\n                  setScopeId(el, parentComponent.vnode.scopeId, parentComponent.vnode, parentComponent.parent);\n              }\n          }\n      };\n      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = 0) => {\n          for (let i = start; i < children.length; i++) {\n              const child = (children[i] = optimized\n                  ? cloneIfMounted(children[i])\n                  : normalizeVNode(children[i]));\n              patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n          }\n      };\n      const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, optimized) => {\n          const el = (n2.el = n1.el);\n          let { patchFlag, dynamicChildren, dirs } = n2;\n          // #1426 take the old vnode\'s patch flag into account since user may clone a\n          // compiler-generated vnode, which de-opts to FULL_PROPS\n          patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;\n          const oldProps = n1.props || EMPTY_OBJ;\n          const newProps = n2.props || EMPTY_OBJ;\n          let vnodeHook;\n          if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {\n              invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n          }\n          if (dirs) {\n              invokeDirectiveHook(n2, n1, parentComponent, \'beforeUpdate\');\n          }\n          if ( isHmrUpdating) {\n              // HMR updated, force full diff\n              patchFlag = 0;\n              optimized = false;\n              dynamicChildren = null;\n          }\n          if (patchFlag > 0) {\n              // the presence of a patchFlag means this element\'s render code was\n              // generated by the compiler and can take the fast path.\n              // in this path old node and new node are guaranteed to have the same shape\n              // (i.e. at the exact same position in the source template)\n              if (patchFlag & 16 /* FULL_PROPS */) {\n                  // element props contain dynamic keys, full diff needed\n                  patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\n              }\n              else {\n                  // class\n                  // this flag is matched when the element has dynamic class bindings.\n                  if (patchFlag & 2 /* CLASS */) {\n                      if (oldProps.class !== newProps.class) {\n                          hostPatchProp(el, \'class\', null, newProps.class, isSVG);\n                      }\n                  }\n                  // style\n                  // this flag is matched when the element has dynamic style bindings\n                  if (patchFlag & 4 /* STYLE */) {\n                      hostPatchProp(el, \'style\', oldProps.style, newProps.style, isSVG);\n                  }\n                  // props\n                  // This flag is matched when the element has dynamic prop/attr bindings\n                  // other than class and style. The keys of dynamic prop/attrs are saved for\n                  // faster iteration.\n                  // Note dynamic keys like :[foo]="bar" will cause this optimization to\n                  // bail out and go through a full diff because we need to unset the old key\n                  if (patchFlag & 8 /* PROPS */) {\n                      // if the flag is present then dynamicProps must be non-null\n                      const propsToUpdate = n2.dynamicProps;\n                      for (let i = 0; i < propsToUpdate.length; i++) {\n                          const key = propsToUpdate[i];\n                          const prev = oldProps[key];\n                          const next = newProps[key];\n                          if (next !== prev ||\n                              (hostForcePatchProp && hostForcePatchProp(el, key))) {\n                              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);\n                          }\n                      }\n                  }\n              }\n              // text\n              // This flag is matched when the element has only dynamic text children.\n              if (patchFlag & 1 /* TEXT */) {\n                  if (n1.children !== n2.children) {\n                      hostSetElementText(el, n2.children);\n                  }\n              }\n          }\n          else if (!optimized && dynamicChildren == null) {\n              // unoptimized, full diff\n              patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\n          }\n          const areChildrenSVG = isSVG && n2.type !== \'foreignObject\';\n          if (dynamicChildren) {\n              patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG);\n              if (\n                  parentComponent &&\n                  parentComponent.type.__hmrId) {\n                  traverseStaticChildren(n1, n2);\n              }\n          }\n          else if (!optimized) {\n              // full diff\n              patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG);\n          }\n          if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\n              queuePostRenderEffect(() => {\n                  vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n                  dirs && invokeDirectiveHook(n2, n1, parentComponent, \'updated\');\n              }, parentSuspense);\n          }\n      };\n      // The fast path for blocks.\n      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG) => {\n          for (let i = 0; i < newChildren.length; i++) {\n              const oldVNode = oldChildren[i];\n              const newVNode = newChildren[i];\n              // Determine the container (parent element) for the patch.\n              const container = \n              // - In the case of a Fragment, we need to provide the actual parent\n              // of the Fragment itself so it can move its children.\n              oldVNode.type === Fragment ||\n                  // - In the case of different nodes, there is going to be a replacement\n                  // which also requires the correct parent container\n                  !isSameVNodeType(oldVNode, newVNode) ||\n                  // - In the case of a component, it could contain anything.\n                  oldVNode.shapeFlag & 6 /* COMPONENT */ ||\n                  oldVNode.shapeFlag & 64 /* TELEPORT */\n                  ? hostParentNode(oldVNode.el)\n                  : // In other cases, the parent container is not actually used so we\n                      // just pass the block element here to avoid a DOM parentNode call.\n                      fallbackContainer;\n              patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, true);\n          }\n      };\n      const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {\n          if (oldProps !== newProps) {\n              for (const key in newProps) {\n                  // empty string is not valid prop\n                  if (isReservedProp(key))\n                      continue;\n                  const next = newProps[key];\n                  const prev = oldProps[key];\n                  if (next !== prev ||\n                      (hostForcePatchProp && hostForcePatchProp(el, key))) {\n                      hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n                  }\n              }\n              if (oldProps !== EMPTY_OBJ) {\n                  for (const key in oldProps) {\n                      if (!isReservedProp(key) && !(key in newProps)) {\n                          hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n                      }\n                  }\n              }\n          }\n      };\n      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n          const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(\'\'));\n          const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(\'\'));\n          let { patchFlag, dynamicChildren } = n2;\n          if (patchFlag > 0) {\n              optimized = true;\n          }\n          if ( isHmrUpdating) {\n              // HMR updated, force full diff\n              patchFlag = 0;\n              optimized = false;\n              dynamicChildren = null;\n          }\n          if (n1 == null) {\n              hostInsert(fragmentStartAnchor, container, anchor);\n              hostInsert(fragmentEndAnchor, container, anchor);\n              // a fragment can only have array children\n              // since they are either generated by the compiler, or implicitly created\n              // from arrays.\n              mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);\n          }\n          else {\n              if (patchFlag > 0 &&\n                  patchFlag & 64 /* STABLE_FRAGMENT */ &&\n                  dynamicChildren) {\n                  // a stable fragment (template root or <template v-for>) doesn\'t need to\n                  // patch children order, but it may contain dynamicChildren.\n                  patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG);\n                  if ( parentComponent && parentComponent.type.__hmrId) {\n                      traverseStaticChildren(n1, n2);\n                  }\n                  else if (\n                  // #2080 if the stable fragment has a key, it\'s a <template v-for> that may\n                  //  get moved around. Make sure all root level vnodes inherit el.\n                  // #2134 or if it\'s a component root, it may also get moved around\n                  // as the component is being moved.\n                  n2.key != null ||\n                      (parentComponent && n2 === parentComponent.subTree)) {\n                      traverseStaticChildren(n1, n2, true /* shallow */);\n                  }\n              }\n              else {\n                  // keyed / unkeyed, or manual fragments.\n                  // for keyed & unkeyed, since they are compiler generated from v-for,\n                  // each child is guaranteed to be a block so the fragment will never\n                  // have dynamicChildren.\n                  patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);\n              }\n          }\n      };\n      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n          if (n1 == null) {\n              if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\n                  parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);\n              }\n              else {\n                  mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n              }\n          }\n          else {\n              updateComponent(n1, n2, optimized);\n          }\n      };\n      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n          const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));\n          if ( instance.type.__hmrId) {\n              registerHMR(instance);\n          }\n          {\n              pushWarningContext(initialVNode);\n              startMeasure(instance, `mount`);\n          }\n          // inject renderer internals for keepAlive\n          if (isKeepAlive(initialVNode)) {\n              instance.ctx.renderer = internals;\n          }\n          // resolve props and slots for setup context\n          {\n              startMeasure(instance, `init`);\n          }\n          setupComponent(instance);\n          {\n              endMeasure(instance, `init`);\n          }\n          // setup() is async. This component relies on async logic to be resolved\n          // before proceeding\n          if ( instance.asyncDep) {\n              parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\n              // Give it a placeholder if this is not hydration\n              // TODO handle self-defined fallback\n              if (!initialVNode.el) {\n                  const placeholder = (instance.subTree = createVNode(Comment));\n                  processCommentNode(null, placeholder, container, anchor);\n              }\n              return;\n          }\n          setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);\n          {\n              popWarningContext();\n              endMeasure(instance, `mount`);\n          }\n      };\n      const updateComponent = (n1, n2, optimized) => {\n          const instance = (n2.component = n1.component);\n          if (shouldUpdateComponent(n1, n2, optimized)) {\n              if (\n                  instance.asyncDep &&\n                  !instance.asyncResolved) {\n                  // async & still pending - just update props and slots\n                  // since the component\'s reactive effect for render isn\'t set-up yet\n                  {\n                      pushWarningContext(n2);\n                  }\n                  updateComponentPreRender(instance, n2, optimized);\n                  {\n                      popWarningContext();\n                  }\n                  return;\n              }\n              else {\n                  // normal update\n                  instance.next = n2;\n                  // in case the child component is also queued, remove it to avoid\n                  // double updating the same child component in the same flush.\n                  invalidateJob(instance.update);\n                  // instance.update is the reactive effect runner.\n                  instance.update();\n              }\n          }\n          else {\n              // no update needed. just copy over properties\n              n2.component = n1.component;\n              n2.el = n1.el;\n              instance.vnode = n2;\n          }\n      };\n      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n          // create reactive effect for rendering\n          instance.update = effect(function componentEffect() {\n              if (!instance.isMounted) {\n                  let vnodeHook;\n                  const { el, props } = initialVNode;\n                  const { bm, m, parent } = instance;\n                  // beforeMount hook\n                  if (bm) {\n                      invokeArrayFns(bm);\n                  }\n                  // onVnodeBeforeMount\n                  if ((vnodeHook = props && props.onVnodeBeforeMount)) {\n                      invokeVNodeHook(vnodeHook, parent, initialVNode);\n                  }\n                  // render\n                  {\n                      startMeasure(instance, `render`);\n                  }\n                  const subTree = (instance.subTree = renderComponentRoot(instance));\n                  {\n                      endMeasure(instance, `render`);\n                  }\n                  if (el && hydrateNode) {\n                      {\n                          startMeasure(instance, `hydrate`);\n                      }\n                      // vnode has adopted host node - perform hydration instead of mount.\n                      hydrateNode(initialVNode.el, subTree, instance, parentSuspense);\n                      {\n                          endMeasure(instance, `hydrate`);\n                      }\n                  }\n                  else {\n                      {\n                          startMeasure(instance, `patch`);\n                      }\n                      patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);\n                      {\n                          endMeasure(instance, `patch`);\n                      }\n                      initialVNode.el = subTree.el;\n                  }\n                  // mounted hook\n                  if (m) {\n                      queuePostRenderEffect(m, parentSuspense);\n                  }\n                  // onVnodeMounted\n                  if ((vnodeHook = props && props.onVnodeMounted)) {\n                      queuePostRenderEffect(() => {\n                          invokeVNodeHook(vnodeHook, parent, initialVNode);\n                      }, parentSuspense);\n                  }\n                  // activated hook for keep-alive roots.\n                  // #1742 activated hook must be accessed after first render\n                  // since the hook may be injected by a child keep-alive\n                  const { a } = instance;\n                  if (a &&\n                      initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\n                      queuePostRenderEffect(a, parentSuspense);\n                  }\n                  instance.isMounted = true;\n              }\n              else {\n                  // updateComponent\n                  // This is triggered by mutation of component\'s own state (next: null)\n                  // OR parent calling processComponent (next: VNode)\n                  let { next, bu, u, parent, vnode } = instance;\n                  let originNext = next;\n                  let vnodeHook;\n                  {\n                      pushWarningContext(next || instance.vnode);\n                  }\n                  if (next) {\n                      next.el = vnode.el;\n                      updateComponentPreRender(instance, next, optimized);\n                  }\n                  else {\n                      next = vnode;\n                  }\n                  // beforeUpdate hook\n                  if (bu) {\n                      invokeArrayFns(bu);\n                  }\n                  // onVnodeBeforeUpdate\n                  if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {\n                      invokeVNodeHook(vnodeHook, parent, next, vnode);\n                  }\n                  // render\n                  {\n                      startMeasure(instance, `render`);\n                  }\n                  const nextTree = renderComponentRoot(instance);\n                  {\n                      endMeasure(instance, `render`);\n                  }\n                  const prevTree = instance.subTree;\n                  instance.subTree = nextTree;\n                  {\n                      startMeasure(instance, `patch`);\n                  }\n                  patch(prevTree, nextTree, \n                  // parent may have changed if it\'s in a teleport\n                  hostParentNode(prevTree.el), \n                  // anchor may have changed if it\'s in a fragment\n                  getNextHostNode(prevTree), instance, parentSuspense, isSVG);\n                  {\n                      endMeasure(instance, `patch`);\n                  }\n                  next.el = nextTree.el;\n                  if (originNext === null) {\n                      // self-triggered update. In case of HOC, update parent component\n                      // vnode el. HOC is indicated by parent instance\'s subTree pointing\n                      // to child component\'s vnode\n                      updateHOCHostEl(instance, nextTree.el);\n                  }\n                  // updated hook\n                  if (u) {\n                      queuePostRenderEffect(u, parentSuspense);\n                  }\n                  // onVnodeUpdated\n                  if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {\n                      queuePostRenderEffect(() => {\n                          invokeVNodeHook(vnodeHook, parent, next, vnode);\n                      }, parentSuspense);\n                  }\n                  {\n                      devtoolsComponentUpdated(instance);\n                  }\n                  {\n                      popWarningContext();\n                  }\n              }\n          },  createDevEffectOptions(instance) );\n      };\n      const updateComponentPreRender = (instance, nextVNode, optimized) => {\n          nextVNode.component = instance;\n          const prevProps = instance.vnode.props;\n          instance.vnode = nextVNode;\n          instance.next = null;\n          updateProps(instance, nextVNode.props, prevProps, optimized);\n          updateSlots(instance, nextVNode.children);\n          // props update may have triggered pre-flush watchers.\n          // flush them before the render update.\n          flushPreFlushCbs(undefined, instance.update);\n      };\n      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) => {\n          const c1 = n1 && n1.children;\n          const prevShapeFlag = n1 ? n1.shapeFlag : 0;\n          const c2 = n2.children;\n          const { patchFlag, shapeFlag } = n2;\n          // fast path\n          if (patchFlag > 0) {\n              if (patchFlag & 128 /* KEYED_FRAGMENT */) {\n                  // this could be either fully-keyed or mixed (some keyed some not)\n                  // presence of patchFlag means children are guaranteed to be arrays\n                  patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n                  return;\n              }\n              else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {\n                  // unkeyed\n                  patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n                  return;\n              }\n          }\n          // children has 3 possibilities: text, array or no children.\n          if (shapeFlag & 8 /* TEXT_CHILDREN */) {\n              // text children fast path\n              if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\n                  unmountChildren(c1, parentComponent, parentSuspense);\n              }\n              if (c2 !== c1) {\n                  hostSetElementText(container, c2);\n              }\n          }\n          else {\n              if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\n                  // prev children was array\n                  if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\n                      // two arrays, cannot assume anything, do full diff\n                      patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n                  }\n                  else {\n                      // no new children, just unmount old\n                      unmountChildren(c1, parentComponent, parentSuspense, true);\n                  }\n              }\n              else {\n                  // prev children was text OR null\n                  // new children is array OR null\n                  if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {\n                      hostSetElementText(container, \'\');\n                  }\n                  // mount new if array\n                  if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\n                      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n                  }\n              }\n          }\n      };\n      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n          c1 = c1 || EMPTY_ARR;\n          c2 = c2 || EMPTY_ARR;\n          const oldLength = c1.length;\n          const newLength = c2.length;\n          const commonLength = Math.min(oldLength, newLength);\n          let i;\n          for (i = 0; i < commonLength; i++) {\n              const nextChild = (c2[i] = optimized\n                  ? cloneIfMounted(c2[i])\n                  : normalizeVNode(c2[i]));\n              patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, optimized);\n          }\n          if (oldLength > newLength) {\n              // remove old\n              unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);\n          }\n          else {\n              // mount new\n              mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, commonLength);\n          }\n      };\n      // can be all-keyed or mixed\n      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {\n          let i = 0;\n          const l2 = c2.length;\n          let e1 = c1.length - 1; // prev ending index\n          let e2 = l2 - 1; // next ending index\n          // 1. sync from start\n          // (a b) c\n          // (a b) d e\n          while (i <= e1 && i <= e2) {\n              const n1 = c1[i];\n              const n2 = (c2[i] = optimized\n                  ? cloneIfMounted(c2[i])\n                  : normalizeVNode(c2[i]));\n              if (isSameVNodeType(n1, n2)) {\n                  patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);\n              }\n              else {\n                  break;\n              }\n              i++;\n          }\n          // 2. sync from end\n          // a (b c)\n          // d e (b c)\n          while (i <= e1 && i <= e2) {\n              const n1 = c1[e1];\n              const n2 = (c2[e2] = optimized\n                  ? cloneIfMounted(c2[e2])\n                  : normalizeVNode(c2[e2]));\n              if (isSameVNodeType(n1, n2)) {\n                  patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);\n              }\n              else {\n                  break;\n              }\n              e1--;\n              e2--;\n          }\n          // 3. common sequence + mount\n          // (a b)\n          // (a b) c\n          // i = 2, e1 = 1, e2 = 2\n          // (a b)\n          // c (a b)\n          // i = 0, e1 = -1, e2 = 0\n          if (i > e1) {\n              if (i <= e2) {\n                  const nextPos = e2 + 1;\n                  const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\n                  while (i <= e2) {\n                      patch(null, (c2[i] = optimized\n                          ? cloneIfMounted(c2[i])\n                          : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG);\n                      i++;\n                  }\n              }\n          }\n          // 4. common sequence + unmount\n          // (a b) c\n          // (a b)\n          // i = 2, e1 = 2, e2 = 1\n          // a (b c)\n          // (b c)\n          // i = 0, e1 = 0, e2 = -1\n          else if (i > e2) {\n              while (i <= e1) {\n                  unmount(c1[i], parentComponent, parentSuspense, true);\n                  i++;\n              }\n          }\n          // 5. unknown sequence\n          // [i ... e1 + 1]: a b [c d e] f g\n          // [i ... e2 + 1]: a b [e d c h] f g\n          // i = 2, e1 = 4, e2 = 5\n          else {\n              const s1 = i; // prev starting index\n              const s2 = i; // next starting index\n              // 5.1 build key:index map for newChildren\n              const keyToNewIndexMap = new Map();\n              for (i = s2; i <= e2; i++) {\n                  const nextChild = (c2[i] = optimized\n                      ? cloneIfMounted(c2[i])\n                      : normalizeVNode(c2[i]));\n                  if (nextChild.key != null) {\n                      if ( keyToNewIndexMap.has(nextChild.key)) {\n                          warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);\n                      }\n                      keyToNewIndexMap.set(nextChild.key, i);\n                  }\n              }\n              // 5.2 loop through old children left to be patched and try to patch\n              // matching nodes & remove nodes that are no longer present\n              let j;\n              let patched = 0;\n              const toBePatched = e2 - s2 + 1;\n              let moved = false;\n              // used to track whether any node has moved\n              let maxNewIndexSoFar = 0;\n              // works as Map<newIndex, oldIndex>\n              // Note that oldIndex is offset by +1\n              // and oldIndex = 0 is a special value indicating the new node has\n              // no corresponding old node.\n              // used for determining longest stable subsequence\n              const newIndexToOldIndexMap = new Array(toBePatched);\n              for (i = 0; i < toBePatched; i++)\n                  newIndexToOldIndexMap[i] = 0;\n              for (i = s1; i <= e1; i++) {\n                  const prevChild = c1[i];\n                  if (patched >= toBePatched) {\n                      // all new children have been patched so this can only be a removal\n                      unmount(prevChild, parentComponent, parentSuspense, true);\n                      continue;\n                  }\n                  let newIndex;\n                  if (prevChild.key != null) {\n                      newIndex = keyToNewIndexMap.get(prevChild.key);\n                  }\n                  else {\n                      // key-less node, try to locate a key-less node of the same type\n                      for (j = s2; j <= e2; j++) {\n                          if (newIndexToOldIndexMap[j - s2] === 0 &&\n                              isSameVNodeType(prevChild, c2[j])) {\n                              newIndex = j;\n                              break;\n                          }\n                      }\n                  }\n                  if (newIndex === undefined) {\n                      unmount(prevChild, parentComponent, parentSuspense, true);\n                  }\n                  else {\n                      newIndexToOldIndexMap[newIndex - s2] = i + 1;\n                      if (newIndex >= maxNewIndexSoFar) {\n                          maxNewIndexSoFar = newIndex;\n                      }\n                      else {\n                          moved = true;\n                      }\n                      patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, optimized);\n                      patched++;\n                  }\n              }\n              // 5.3 move and mount\n              // generate longest stable subsequence only when nodes have moved\n              const increasingNewIndexSequence = moved\n                  ? getSequence(newIndexToOldIndexMap)\n                  : EMPTY_ARR;\n              j = increasingNewIndexSequence.length - 1;\n              // looping backwards so that we can use last patched node as anchor\n              for (i = toBePatched - 1; i >= 0; i--) {\n                  const nextIndex = s2 + i;\n                  const nextChild = c2[nextIndex];\n                  const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\n                  if (newIndexToOldIndexMap[i] === 0) {\n                      // mount new\n                      patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG);\n                  }\n                  else if (moved) {\n                      // move if:\n                      // There is no stable subsequence (e.g. a reverse)\n                      // OR current node is not among the stable sequence\n                      if (j < 0 || i !== increasingNewIndexSequence[j]) {\n                          move(nextChild, container, anchor, 2 /* REORDER */);\n                      }\n                      else {\n                          j--;\n                      }\n                  }\n              }\n          }\n      };\n      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\n          const { el, type, transition, children, shapeFlag } = vnode;\n          if (shapeFlag & 6 /* COMPONENT */) {\n              move(vnode.component.subTree, container, anchor, moveType);\n              return;\n          }\n          if ( shapeFlag & 128 /* SUSPENSE */) {\n              vnode.suspense.move(container, anchor, moveType);\n              return;\n          }\n          if (shapeFlag & 64 /* TELEPORT */) {\n              type.move(vnode, container, anchor, internals);\n              return;\n          }\n          if (type === Fragment) {\n              hostInsert(el, container, anchor);\n              for (let i = 0; i < children.length; i++) {\n                  move(children[i], container, anchor, moveType);\n              }\n              hostInsert(vnode.anchor, container, anchor);\n              return;\n          }\n          // static node move can only happen when force updating HMR\n          if ( type === Static) {\n              moveStaticNode(vnode, container, anchor);\n              return;\n          }\n          // single nodes\n          const needTransition = moveType !== 2 /* REORDER */ &&\n              shapeFlag & 1 /* ELEMENT */ &&\n              transition;\n          if (needTransition) {\n              if (moveType === 0 /* ENTER */) {\n                  transition.beforeEnter(el);\n                  hostInsert(el, container, anchor);\n                  queuePostRenderEffect(() => transition.enter(el), parentSuspense);\n              }\n              else {\n                  const { leave, delayLeave, afterLeave } = transition;\n                  const remove = () => hostInsert(el, container, anchor);\n                  const performLeave = () => {\n                      leave(el, () => {\n                          remove();\n                          afterLeave && afterLeave();\n                      });\n                  };\n                  if (delayLeave) {\n                      delayLeave(el, remove, performLeave);\n                  }\n                  else {\n                      performLeave();\n                  }\n              }\n          }\n          else {\n              hostInsert(el, container, anchor);\n          }\n      };\n      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\n          const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;\n          // unset ref\n          if (ref != null && parentComponent) {\n              setRef(ref, null, parentComponent, parentSuspense, null);\n          }\n          if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\n              parentComponent.ctx.deactivate(vnode);\n              return;\n          }\n          const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;\n          let vnodeHook;\n          if ((vnodeHook = props && props.onVnodeBeforeUnmount)) {\n              invokeVNodeHook(vnodeHook, parentComponent, vnode);\n          }\n          if (shapeFlag & 6 /* COMPONENT */) {\n              unmountComponent(vnode.component, parentSuspense, doRemove);\n          }\n          else {\n              if ( shapeFlag & 128 /* SUSPENSE */) {\n                  vnode.suspense.unmount(parentSuspense, doRemove);\n                  return;\n              }\n              if (shouldInvokeDirs) {\n                  invokeDirectiveHook(vnode, null, parentComponent, \'beforeUnmount\');\n              }\n              if (dynamicChildren &&\n                  // #1153: fast path should not be taken for non-stable (v-for) fragments\n                  (type !== Fragment ||\n                      (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {\n                  // fast path for block nodes: only need to unmount dynamic children.\n                  unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);\n              }\n              else if ((type === Fragment &&\n                  (patchFlag & 128 /* KEYED_FRAGMENT */ ||\n                      patchFlag & 256 /* UNKEYED_FRAGMENT */)) ||\n                  (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {\n                  unmountChildren(children, parentComponent, parentSuspense);\n              }\n              // an unmounted teleport should always remove its children if not disabled\n              if (shapeFlag & 64 /* TELEPORT */ &&\n                  (doRemove || !isTeleportDisabled(vnode.props))) {\n                  vnode.type.remove(vnode, internals);\n              }\n              if (doRemove) {\n                  remove(vnode);\n              }\n          }\n          if ((vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {\n              queuePostRenderEffect(() => {\n                  vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n                  shouldInvokeDirs &&\n                      invokeDirectiveHook(vnode, null, parentComponent, \'unmounted\');\n              }, parentSuspense);\n          }\n      };\n      const remove = vnode => {\n          const { type, el, anchor, transition } = vnode;\n          if (type === Fragment) {\n              removeFragment(el, anchor);\n              return;\n          }\n          if ( type === Static) {\n              removeStaticNode(vnode);\n              return;\n          }\n          const performRemove = () => {\n              hostRemove(el);\n              if (transition && !transition.persisted && transition.afterLeave) {\n                  transition.afterLeave();\n              }\n          };\n          if (vnode.shapeFlag & 1 /* ELEMENT */ &&\n              transition &&\n              !transition.persisted) {\n              const { leave, delayLeave } = transition;\n              const performLeave = () => leave(el, performRemove);\n              if (delayLeave) {\n                  delayLeave(vnode.el, performRemove, performLeave);\n              }\n              else {\n                  performLeave();\n              }\n          }\n          else {\n              performRemove();\n          }\n      };\n      const removeFragment = (cur, end) => {\n          // For fragments, directly remove all contained DOM nodes.\n          // (fragment child nodes cannot have transition)\n          let next;\n          while (cur !== end) {\n              next = hostNextSibling(cur);\n              hostRemove(cur);\n              cur = next;\n          }\n          hostRemove(end);\n      };\n      const unmountComponent = (instance, parentSuspense, doRemove) => {\n          if ( instance.type.__hmrId) {\n              unregisterHMR(instance);\n          }\n          const { bum, effects, update, subTree, um } = instance;\n          // beforeUnmount hook\n          if (bum) {\n              invokeArrayFns(bum);\n          }\n          if (effects) {\n              for (let i = 0; i < effects.length; i++) {\n                  stop(effects[i]);\n              }\n          }\n          // update may be null if a component is unmounted before its async\n          // setup has resolved.\n          if (update) {\n              stop(update);\n              unmount(subTree, instance, parentSuspense, doRemove);\n          }\n          // unmounted hook\n          if (um) {\n              queuePostRenderEffect(um, parentSuspense);\n          }\n          queuePostRenderEffect(() => {\n              instance.isUnmounted = true;\n          }, parentSuspense);\n          // A component with async dep inside a pending suspense is unmounted before\n          // its async dep resolves. This should remove the dep from the suspense, and\n          // cause the suspense to resolve immediately if that was the last dep.\n          if (\n              parentSuspense &&\n              parentSuspense.pendingBranch &&\n              !parentSuspense.isUnmounted &&\n              instance.asyncDep &&\n              !instance.asyncResolved &&\n              instance.suspenseId === parentSuspense.pendingId) {\n              parentSuspense.deps--;\n              if (parentSuspense.deps === 0) {\n                  parentSuspense.resolve();\n              }\n          }\n          {\n              devtoolsComponentRemoved(instance);\n          }\n      };\n      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\n          for (let i = start; i < children.length; i++) {\n              unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\n          }\n      };\n      const getNextHostNode = vnode => {\n          if (vnode.shapeFlag & 6 /* COMPONENT */) {\n              return getNextHostNode(vnode.component.subTree);\n          }\n          if ( vnode.shapeFlag & 128 /* SUSPENSE */) {\n              return vnode.suspense.next();\n          }\n          return hostNextSibling((vnode.anchor || vnode.el));\n      };\n      const render = (vnode, container) => {\n          if (vnode == null) {\n              if (container._vnode) {\n                  unmount(container._vnode, null, null, true);\n              }\n          }\n          else {\n              patch(container._vnode || null, vnode, container);\n          }\n          flushPostFlushCbs();\n          container._vnode = vnode;\n      };\n      const internals = {\n          p: patch,\n          um: unmount,\n          m: move,\n          r: remove,\n          mt: mountComponent,\n          mc: mountChildren,\n          pc: patchChildren,\n          pbc: patchBlockChildren,\n          n: getNextHostNode,\n          o: options\n      };\n      let hydrate;\n      let hydrateNode;\n      if (createHydrationFns) {\n          [hydrate, hydrateNode] = createHydrationFns(internals);\n      }\n      return {\n          render,\n          hydrate,\n          createApp: createAppAPI(render, hydrate)\n      };\n  }\n  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\n      callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [\n          vnode,\n          prevVNode\n      ]);\n  }\n  /**\n   * #1156\n   * When a component is HMR-enabled, we need to make sure that all static nodes\n   * inside a block also inherit the DOM element from the previous tree so that\n   * HMR updates (which are full updates) can retrieve the element for patching.\n   *\n   * #2080\n   * Inside keyed `template` fragment static children, if a fragment is moved,\n   * the children will always moved so that need inherit el form previous nodes\n   * to ensure correct moved position.\n   */\n  function traverseStaticChildren(n1, n2, shallow = false) {\n      const ch1 = n1.children;\n      const ch2 = n2.children;\n      if (isArray(ch1) && isArray(ch2)) {\n          for (let i = 0; i < ch1.length; i++) {\n              // this is only called in the optimized path so array children are\n              // guaranteed to be vnodes\n              const c1 = ch1[i];\n              let c2 = ch2[i];\n              if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {\n                  if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {\n                      c2 = ch2[i] = cloneIfMounted(ch2[i]);\n                      c2.el = c1.el;\n                  }\n                  if (!shallow)\n                      traverseStaticChildren(c1, c2);\n              }\n              // also inherit for comment nodes, but not placeholders (e.g. v-if which\n              // would have received .el during block patch)\n              if ( c2.type === Comment && !c2.el) {\n                  c2.el = c1.el;\n              }\n          }\n      }\n  }\n  // https://en.wikipedia.org/wiki/Longest_increasing_subsequence\n  function getSequence(arr) {\n      const p = arr.slice();\n      const result = [0];\n      let i, j, u, v, c;\n      const len = arr.length;\n      for (i = 0; i < len; i++) {\n          const arrI = arr[i];\n          if (arrI !== 0) {\n              j = result[result.length - 1];\n              if (arr[j] < arrI) {\n                  p[i] = j;\n                  result.push(i);\n                  continue;\n              }\n              u = 0;\n              v = result.length - 1;\n              while (u < v) {\n                  c = ((u + v) / 2) | 0;\n                  if (arr[result[c]] < arrI) {\n                      u = c + 1;\n                  }\n                  else {\n                      v = c;\n                  }\n              }\n              if (arrI < arr[result[u]]) {\n                  if (u > 0) {\n                      p[i] = result[u - 1];\n                  }\n                  result[u] = i;\n              }\n          }\n      }\n      u = result.length;\n      v = result[u - 1];\n      while (u-- > 0) {\n          result[u] = v;\n          v = p[v];\n      }\n      return result;\n  }\n\n  const isTeleport = (type) => type.__isTeleport;\n  const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === \'\');\n  const resolveTarget = (props, select) => {\n      const targetSelector = props && props.to;\n      if (isString(targetSelector)) {\n          if (!select) {\n              \n                  warn(`Current renderer does not support string target for Teleports. ` +\n                      `(missing querySelector renderer option)`);\n              return null;\n          }\n          else {\n              const target = select(targetSelector);\n              if (!target) {\n                  \n                      warn(`Failed to locate Teleport target with selector "${targetSelector}". ` +\n                          `Note the target element must exist before the component is mounted - ` +\n                          `i.e. the target cannot be rendered by the component itself, and ` +\n                          `ideally should be outside of the entire Vue component tree.`);\n              }\n              return target;\n          }\n      }\n      else {\n          if ( !targetSelector && !isTeleportDisabled(props)) {\n              warn(`Invalid Teleport target: ${targetSelector}`);\n          }\n          return targetSelector;\n      }\n  };\n  const TeleportImpl = {\n      __isTeleport: true,\n      process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals) {\n          const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;\n          const disabled = isTeleportDisabled(n2.props);\n          const { shapeFlag, children } = n2;\n          if (n1 == null) {\n              // insert anchors in the main view\n              const placeholder = (n2.el =  createComment(\'teleport start\')\n                  );\n              const mainAnchor = (n2.anchor =  createComment(\'teleport end\')\n                  );\n              insert(placeholder, container, anchor);\n              insert(mainAnchor, container, anchor);\n              const target = (n2.target = resolveTarget(n2.props, querySelector));\n              const targetAnchor = (n2.targetAnchor = createText(\'\'));\n              if (target) {\n                  insert(targetAnchor, target);\n              }\n              else if ( !disabled) {\n                  warn(\'Invalid Teleport target on mount:\', target, `(${typeof target})`);\n              }\n              const mount = (container, anchor) => {\n                  // Teleport *always* has Array children. This is enforced in both the\n                  // compiler and vnode children normalization.\n                  if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\n                      mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n                  }\n              };\n              if (disabled) {\n                  mount(container, mainAnchor);\n              }\n              else if (target) {\n                  mount(target, targetAnchor);\n              }\n          }\n          else {\n              // update content\n              n2.el = n1.el;\n              const mainAnchor = (n2.anchor = n1.anchor);\n              const target = (n2.target = n1.target);\n              const targetAnchor = (n2.targetAnchor = n1.targetAnchor);\n              const wasDisabled = isTeleportDisabled(n1.props);\n              const currentContainer = wasDisabled ? container : target;\n              const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\n              if (n2.dynamicChildren) {\n                  // fast path when the teleport happens to be a block root\n                  patchBlockChildren(n1.dynamicChildren, n2.dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG);\n                  // even in block tree mode we need to make sure all root-level nodes\n                  // in the teleport inherit previous DOM references so that they can\n                  // be moved in future patches.\n                  traverseStaticChildren(n1, n2, true);\n              }\n              else if (!optimized) {\n                  patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG);\n              }\n              if (disabled) {\n                  if (!wasDisabled) {\n                      // enabled -> disabled\n                      // move into main container\n                      moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);\n                  }\n              }\n              else {\n                  // target changed\n                  if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\n                      const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));\n                      if (nextTarget) {\n                          moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);\n                      }\n                      else {\n                          warn(\'Invalid Teleport target on update:\', target, `(${typeof target})`);\n                      }\n                  }\n                  else if (wasDisabled) {\n                      // disabled -> enabled\n                      // move into teleport target\n                      moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);\n                  }\n              }\n          }\n      },\n      remove(vnode, { r: remove, o: { remove: hostRemove } }) {\n          const { shapeFlag, children, anchor } = vnode;\n          hostRemove(anchor);\n          if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\n              for (let i = 0; i < children.length; i++) {\n                  remove(children[i]);\n              }\n          }\n      },\n      move: moveTeleport,\n      hydrate: hydrateTeleport\n  };\n  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {\n      // move target anchor if this is a target change.\n      if (moveType === 0 /* TARGET_CHANGE */) {\n          insert(vnode.targetAnchor, container, parentAnchor);\n      }\n      const { el, anchor, shapeFlag, children, props } = vnode;\n      const isReorder = moveType === 2 /* REORDER */;\n      // move main view anchor if this is a re-order.\n      if (isReorder) {\n          insert(el, container, parentAnchor);\n      }\n      // if this is a re-order and teleport is enabled (content is in target)\n      // do not move children. So the opposite is: only move children if this\n      // is not a reorder, or the teleport is disabled\n      if (!isReorder || isTeleportDisabled(props)) {\n          // Teleport has either Array children or no children.\n          if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\n              for (let i = 0; i < children.length; i++) {\n                  move(children[i], container, parentAnchor, 2 /* REORDER */);\n              }\n          }\n      }\n      // move main view anchor if this is a re-order.\n      if (isReorder) {\n          insert(anchor, container, parentAnchor);\n      }\n  }\n  function hydrateTeleport(node, vnode, parentComponent, parentSuspense, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {\n      const target = (vnode.target = resolveTarget(vnode.props, querySelector));\n      if (target) {\n          // if multiple teleports rendered to the same target element, we need to\n          // pick up from where the last teleport finished instead of the first node\n          const targetNode = target._lpa || target.firstChild;\n          if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {\n              if (isTeleportDisabled(vnode.props)) {\n                  vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, optimized);\n                  vnode.targetAnchor = targetNode;\n              }\n              else {\n                  vnode.anchor = nextSibling(node);\n                  vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, optimized);\n              }\n              target._lpa =\n                  vnode.targetAnchor && nextSibling(vnode.targetAnchor);\n          }\n      }\n      return vnode.anchor && nextSibling(vnode.anchor);\n  }\n  // Force-casted public typing for h and TSX props inference\n  const Teleport = TeleportImpl;\n\n  const COMPONENTS = \'components\';\n  const DIRECTIVES = \'directives\';\n  /**\n   * @private\n   */\n  function resolveComponent(name) {\n      return resolveAsset(COMPONENTS, name) || name;\n  }\n  const NULL_DYNAMIC_COMPONENT = Symbol();\n  /**\n   * @private\n   */\n  function resolveDynamicComponent(component) {\n      if (isString(component)) {\n          return resolveAsset(COMPONENTS, component, false) || component;\n      }\n      else {\n          // invalid types will fallthrough to createVNode and raise warning\n          return (component || NULL_DYNAMIC_COMPONENT);\n      }\n  }\n  /**\n   * @private\n   */\n  function resolveDirective(name) {\n      return resolveAsset(DIRECTIVES, name);\n  }\n  // implementation\n  function resolveAsset(type, name, warnMissing = true) {\n      const instance = currentRenderingInstance || currentInstance;\n      if (instance) {\n          const Component = instance.type;\n          // self name has highest priority\n          if (type === COMPONENTS) {\n              const selfName = Component.displayName || Component.name;\n              if (selfName &&\n                  (selfName === name ||\n                      selfName === camelize(name) ||\n                      selfName === capitalize(camelize(name)))) {\n                  return Component;\n              }\n          }\n          const res = \n          // local registration\n          // check instance[type] first for components with mixin or extends.\n          resolve(instance[type] || Component[type], name) ||\n              // global registration\n              resolve(instance.appContext[type], name);\n          if ( warnMissing && !res) {\n              warn(`Failed to resolve ${type.slice(0, -1)}: ${name}`);\n          }\n          return res;\n      }\n      else {\n          warn(`resolve${capitalize(type.slice(0, -1))} ` +\n              `can only be used in render() or setup().`);\n      }\n  }\n  function resolve(registry, name) {\n      return (registry &&\n          (registry[name] ||\n              registry[camelize(name)] ||\n              registry[capitalize(camelize(name))]));\n  }\n\n  const Fragment = Symbol( \'Fragment\' );\n  const Text = Symbol( \'Text\' );\n  const Comment = Symbol( \'Comment\' );\n  const Static = Symbol( \'Static\' );\n  // Since v-if and v-for are the two possible ways node structure can dynamically\n  // change, once we consider v-if branches and each v-for fragment a block, we\n  // can divide a template into nested blocks, and within each block the node\n  // structure would be stable. This allows us to skip most children diffing\n  // and only worry about the dynamic nodes (indicated by patch flags).\n  const blockStack = [];\n  let currentBlock = null;\n  /**\n   * Open a block.\n   * This must be called before `createBlock`. It cannot be part of `createBlock`\n   * because the children of the block are evaluated before `createBlock` itself\n   * is called. The generated code typically looks like this:\n   *\n   * ```js\n   * function render() {\n   *   return (openBlock(),createBlock(\'div\', null, [...]))\n   * }\n   * ```\n   * disableTracking is true when creating a v-for fragment block, since a v-for\n   * fragment always diffs its children.\n   *\n   * @private\n   */\n  function openBlock(disableTracking = false) {\n      blockStack.push((currentBlock = disableTracking ? null : []));\n  }\n  function closeBlock() {\n      blockStack.pop();\n      currentBlock = blockStack[blockStack.length - 1] || null;\n  }\n  // Whether we should be tracking dynamic child nodes inside a block.\n  // Only tracks when this value is > 0\n  // We are not using a simple boolean because this value may need to be\n  // incremented/decremented by nested usage of v-once (see below)\n  let shouldTrack$1 = 1;\n  /**\n   * Block tracking sometimes needs to be disabled, for example during the\n   * creation of a tree that needs to be cached by v-once. The compiler generates\n   * code like this:\n   *\n   * ``` js\n   * _cache[1] || (\n   *   setBlockTracking(-1),\n   *   _cache[1] = createVNode(...),\n   *   setBlockTracking(1),\n   *   _cache[1]\n   * )\n   * ```\n   *\n   * @private\n   */\n  function setBlockTracking(value) {\n      shouldTrack$1 += value;\n  }\n  /**\n   * Create a block root vnode. Takes the same exact arguments as `createVNode`.\n   * A block root keeps track of dynamic nodes within the block in the\n   * `dynamicChildren` array.\n   *\n   * @private\n   */\n  function createBlock(type, props, children, patchFlag, dynamicProps) {\n      const vnode = createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */);\n      // save current block children on the block vnode\n      vnode.dynamicChildren = currentBlock || EMPTY_ARR;\n      // close block\n      closeBlock();\n      // a block is always going to be patched, so track it as a child of its\n      // parent block\n      if (shouldTrack$1 > 0 && currentBlock) {\n          currentBlock.push(vnode);\n      }\n      return vnode;\n  }\n  function isVNode(value) {\n      return value ? value.__v_isVNode === true : false;\n  }\n  function isSameVNodeType(n1, n2) {\n      if (\n          n2.shapeFlag & 6 /* COMPONENT */ &&\n          hmrDirtyComponents.has(n2.type)) {\n          // HMR only: if the component has been hot-updated, force a reload.\n          return false;\n      }\n      return n1.type === n2.type && n1.key === n2.key;\n  }\n  let vnodeArgsTransformer;\n  /**\n   * Internal API for registering an arguments transform for createVNode\n   * used for creating stubs in the test-utils\n   * It is *internal* but needs to be exposed for test-utils to pick up proper\n   * typings\n   */\n  function transformVNodeArgs(transformer) {\n      vnodeArgsTransformer = transformer;\n  }\n  const createVNodeWithArgsTransform = (...args) => {\n      return _createVNode(...(vnodeArgsTransformer\n          ? vnodeArgsTransformer(args, currentRenderingInstance)\n          : args));\n  };\n  const InternalObjectKey = `__vInternal`;\n  const normalizeKey = ({ key }) => key != null ? key : null;\n  const normalizeRef = ({ ref }) => {\n      return (ref != null\n          ? isArray(ref)\n              ? ref\n              : { i: currentRenderingInstance, r: ref }\n          : null);\n  };\n  const createVNode = ( createVNodeWithArgsTransform\n      );\n  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\n      if (!type || type === NULL_DYNAMIC_COMPONENT) {\n          if ( !type) {\n              warn(`Invalid vnode type when creating vnode: ${type}.`);\n          }\n          type = Comment;\n      }\n      if (isVNode(type)) {\n          // createVNode receiving an existing vnode. This happens in cases like\n          // <component :is="vnode"/>\n          // #2078 make sure to merge refs during the clone instead of overwriting it\n          const cloned = cloneVNode(type, props, true /* mergeRef: true */);\n          if (children) {\n              normalizeChildren(cloned, children);\n          }\n          return cloned;\n      }\n      // class component normalization.\n      if (isClassComponent(type)) {\n          type = type.__vccOpts;\n      }\n      // class & style normalization.\n      if (props) {\n          // for reactive or proxy objects, we need to clone it to enable mutation.\n          if (isProxy(props) || InternalObjectKey in props) {\n              props = extend({}, props);\n          }\n          let { class: klass, style } = props;\n          if (klass && !isString(klass)) {\n              props.class = normalizeClass(klass);\n          }\n          if (isObject(style)) {\n              // reactive state objects need to be cloned since they are likely to be\n              // mutated\n              if (isProxy(style) && !isArray(style)) {\n                  style = extend({}, style);\n              }\n              props.style = normalizeStyle(style);\n          }\n      }\n      // encode the vnode type information into a bitmap\n      const shapeFlag = isString(type)\n          ? 1 /* ELEMENT */\n          :  isSuspense(type)\n              ? 128 /* SUSPENSE */\n              : isTeleport(type)\n                  ? 64 /* TELEPORT */\n                  : isObject(type)\n                      ? 4 /* STATEFUL_COMPONENT */\n                      : isFunction(type)\n                          ? 2 /* FUNCTIONAL_COMPONENT */\n                          : 0;\n      if ( shapeFlag & 4 /* STATEFUL_COMPONENT */ && isProxy(type)) {\n          type = toRaw(type);\n          warn(`Vue received a Component which was made a reactive object. This can ` +\n              `lead to unnecessary performance overhead, and should be avoided by ` +\n              `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` +\n              `instead of \\`ref\\`.`, `\\nComponent that was made reactive: `, type);\n      }\n      const vnode = {\n          __v_isVNode: true,\n          ["__v_skip" /* SKIP */]: true,\n          type,\n          props,\n          key: props && normalizeKey(props),\n          ref: props && normalizeRef(props),\n          scopeId: currentScopeId,\n          children: null,\n          component: null,\n          suspense: null,\n          ssContent: null,\n          ssFallback: null,\n          dirs: null,\n          transition: null,\n          el: null,\n          anchor: null,\n          target: null,\n          targetAnchor: null,\n          staticCount: 0,\n          shapeFlag,\n          patchFlag,\n          dynamicProps,\n          dynamicChildren: null,\n          appContext: null\n      };\n      // validate key\n      if ( vnode.key !== vnode.key) {\n          warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\n      }\n      normalizeChildren(vnode, children);\n      // normalize suspense children\n      if ( shapeFlag & 128 /* SUSPENSE */) {\n          const { content, fallback } = normalizeSuspenseChildren(vnode);\n          vnode.ssContent = content;\n          vnode.ssFallback = fallback;\n      }\n      if (shouldTrack$1 > 0 &&\n          // avoid a block node from tracking itself\n          !isBlockNode &&\n          // has current parent block\n          currentBlock &&\n          // presence of a patch flag indicates this node needs patching on updates.\n          // component nodes also should always be patched, because even if the\n          // component doesn\'t need to update, it needs to persist the instance on to\n          // the next vnode so that it can be properly unmounted later.\n          (patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\n          // the EVENTS flag is only for hydration and if it is the only flag, the\n          // vnode should not be considered dynamic due to handler caching.\n          patchFlag !== 32 /* HYDRATE_EVENTS */) {\n          currentBlock.push(vnode);\n      }\n      return vnode;\n  }\n  function cloneVNode(vnode, extraProps, mergeRef = false) {\n      // This is intentionally NOT using spread or extend to avoid the runtime\n      // key enumeration cost.\n      const { props, ref, patchFlag } = vnode;\n      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\n      return {\n          __v_isVNode: true,\n          ["__v_skip" /* SKIP */]: true,\n          type: vnode.type,\n          props: mergedProps,\n          key: mergedProps && normalizeKey(mergedProps),\n          ref: extraProps && extraProps.ref\n              ? // #2078 in the case of <component :is="vnode" ref="extra"/>\n                  // if the vnode itself already has a ref, cloneVNode will need to merge\n                  // the refs so the single vnode can be set on multiple refs\n                  mergeRef && ref\n                      ? isArray(ref)\n                          ? ref.concat(normalizeRef(extraProps))\n                          : [ref, normalizeRef(extraProps)]\n                      : normalizeRef(extraProps)\n              : ref,\n          scopeId: vnode.scopeId,\n          children: vnode.children,\n          target: vnode.target,\n          targetAnchor: vnode.targetAnchor,\n          staticCount: vnode.staticCount,\n          shapeFlag: vnode.shapeFlag,\n          // if the vnode is cloned with extra props, we can no longer assume its\n          // existing patch flag to be reliable and need to add the FULL_PROPS flag.\n          // note: perserve flag for fragments since they use the flag for children\n          // fast paths only.\n          patchFlag: extraProps && vnode.type !== Fragment\n              ? patchFlag === -1 // hoisted node\n                  ? 16 /* FULL_PROPS */\n                  : patchFlag | 16 /* FULL_PROPS */\n              : patchFlag,\n          dynamicProps: vnode.dynamicProps,\n          dynamicChildren: vnode.dynamicChildren,\n          appContext: vnode.appContext,\n          dirs: vnode.dirs,\n          transition: vnode.transition,\n          // These should technically only be non-null on mounted VNodes. However,\n          // they *should* be copied for kept-alive vnodes. So we just always copy\n          // them since them being non-null during a mount doesn\'t affect the logic as\n          // they will simply be overwritten.\n          component: vnode.component,\n          suspense: vnode.suspense,\n          ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\n          ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\n          el: vnode.el,\n          anchor: vnode.anchor\n      };\n  }\n  /**\n   * @private\n   */\n  function createTextVNode(text = \' \', flag = 0) {\n      return createVNode(Text, null, text, flag);\n  }\n  /**\n   * @private\n   */\n  function createStaticVNode(content, numberOfNodes) {\n      // A static vnode can contain multiple stringified elements, and the number\n      // of elements is necessary for hydration.\n      const vnode = createVNode(Static, null, content);\n      vnode.staticCount = numberOfNodes;\n      return vnode;\n  }\n  /**\n   * @private\n   */\n  function createCommentVNode(text = \'\', \n  // when used as the v-else branch, the comment node must be created as a\n  // block to ensure correct updates.\n  asBlock = false) {\n      return asBlock\n          ? (openBlock(), createBlock(Comment, null, text))\n          : createVNode(Comment, null, text);\n  }\n  function normalizeVNode(child) {\n      if (child == null || typeof child === \'boolean\') {\n          // empty placeholder\n          return createVNode(Comment);\n      }\n      else if (isArray(child)) {\n          // fragment\n          return createVNode(Fragment, null, child);\n      }\n      else if (typeof child === \'object\') {\n          // already vnode, this should be the most common since compiled templates\n          // always produce all-vnode children arrays\n          return child.el === null ? child : cloneVNode(child);\n      }\n      else {\n          // strings and numbers\n          return createVNode(Text, null, String(child));\n      }\n  }\n  // optimized normalization for template-compiled render fns\n  function cloneIfMounted(child) {\n      return child.el === null ? child : cloneVNode(child);\n  }\n  function normalizeChildren(vnode, children) {\n      let type = 0;\n      const { shapeFlag } = vnode;\n      if (children == null) {\n          children = null;\n      }\n      else if (isArray(children)) {\n          type = 16 /* ARRAY_CHILDREN */;\n      }\n      else if (typeof children === \'object\') {\n          if (shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) {\n              // Normalize slot to plain children for plain element and Teleport\n              const slot = children.default;\n              if (slot) {\n                  // _c marker is added by withCtx() indicating this is a compiled slot\n                  slot._c && setCompiledSlotRendering(1);\n                  normalizeChildren(vnode, slot());\n                  slot._c && setCompiledSlotRendering(-1);\n              }\n              return;\n          }\n          else {\n              type = 32 /* SLOTS_CHILDREN */;\n              const slotFlag = children._;\n              if (!slotFlag && !(InternalObjectKey in children)) {\n                  children._ctx = currentRenderingInstance;\n              }\n              else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\n                  // a child component receives forwarded slots from the parent.\n                  // its slot type is determined by its parent\'s slot type.\n                  if (currentRenderingInstance.vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) {\n                      children._ = 2 /* DYNAMIC */;\n                      vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\n                  }\n                  else {\n                      children._ = 1 /* STABLE */;\n                  }\n              }\n          }\n      }\n      else if (isFunction(children)) {\n          children = { default: children, _ctx: currentRenderingInstance };\n          type = 32 /* SLOTS_CHILDREN */;\n      }\n      else {\n          children = String(children);\n          // force teleport children to array so it can be moved around\n          if (shapeFlag & 64 /* TELEPORT */) {\n              type = 16 /* ARRAY_CHILDREN */;\n              children = [createTextVNode(children)];\n          }\n          else {\n              type = 8 /* TEXT_CHILDREN */;\n          }\n      }\n      vnode.children = children;\n      vnode.shapeFlag |= type;\n  }\n  function mergeProps(...args) {\n      const ret = extend({}, args[0]);\n      for (let i = 1; i < args.length; i++) {\n          const toMerge = args[i];\n          for (const key in toMerge) {\n              if (key === \'class\') {\n                  if (ret.class !== toMerge.class) {\n                      ret.class = normalizeClass([ret.class, toMerge.class]);\n                  }\n              }\n              else if (key === \'style\') {\n                  ret.style = normalizeStyle([ret.style, toMerge.style]);\n              }\n              else if (isOn(key)) {\n                  const existing = ret[key];\n                  const incoming = toMerge[key];\n                  if (existing !== incoming) {\n                      ret[key] = existing\n                          ? [].concat(existing, toMerge[key])\n                          : incoming;\n                  }\n              }\n              else if (key !== \'\') {\n                  ret[key] = toMerge[key];\n              }\n          }\n      }\n      return ret;\n  }\n\n  function provide(key, value) {\n      if (!currentInstance) {\n          {\n              warn(`provide() can only be used inside setup().`);\n          }\n      }\n      else {\n          let provides = currentInstance.provides;\n          // by default an instance inherits its parent\'s provides object\n          // but when it needs to provide values of its own, it creates its\n          // own provides object using parent provides object as prototype.\n          // this way in `inject` we can simply look up injections from direct\n          // parent and let the prototype chain do the work.\n          const parentProvides = currentInstance.parent && currentInstance.parent.provides;\n          if (parentProvides === provides) {\n              provides = currentInstance.provides = Object.create(parentProvides);\n          }\n          // TS doesn\'t allow symbol as index type\n          provides[key] = value;\n      }\n  }\n  function inject(key, defaultValue, treatDefaultAsFactory = false) {\n      // fallback to `currentRenderingInstance` so that this can be called in\n      // a functional component\n      const instance = currentInstance || currentRenderingInstance;\n      if (instance) {\n          // #2400\n          // to support `app.use` plugins,\n          // fallback to appContext\'s `provides` if the intance is at root\n          const provides = instance.parent == null\n              ? instance.vnode.appContext && instance.vnode.appContext.provides\n              : instance.parent.provides;\n          if (provides && key in provides) {\n              // TS doesn\'t allow symbol as index type\n              return provides[key];\n          }\n          else if (arguments.length > 1) {\n              return treatDefaultAsFactory && isFunction(defaultValue)\n                  ? defaultValue()\n                  : defaultValue;\n          }\n          else {\n              warn(`injection "${String(key)}" not found.`);\n          }\n      }\n      else {\n          warn(`inject() can only be used inside setup() or functional components.`);\n      }\n  }\n\n  function createDuplicateChecker() {\n      const cache = Object.create(null);\n      return (type, key) => {\n          if (cache[key]) {\n              warn(`${type} property "${key}" is already defined in ${cache[key]}.`);\n          }\n          else {\n              cache[key] = type;\n          }\n      };\n  }\n  let isInBeforeCreate = false;\n  function applyOptions(instance, options, deferredData = [], deferredWatch = [], deferredProvide = [], asMixin = false) {\n      const { \n      // composition\n      mixins, extends: extendsOptions, \n      // state\n      data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, \n      // assets\n      components, directives, \n      // lifecycle\n      beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured } = options;\n      const publicThis = instance.proxy;\n      const ctx = instance.ctx;\n      const globalMixins = instance.appContext.mixins;\n      if (asMixin && render && instance.render === NOOP) {\n          instance.render = render;\n      }\n      // applyOptions is called non-as-mixin once per instance\n      if (!asMixin) {\n          isInBeforeCreate = true;\n          callSyncHook(\'beforeCreate\', "bc" /* BEFORE_CREATE */, options, instance, globalMixins);\n          isInBeforeCreate = false;\n          // global mixins are applied first\n          applyMixins(instance, globalMixins, deferredData, deferredWatch, deferredProvide);\n      }\n      // extending a base component...\n      if (extendsOptions) {\n          applyOptions(instance, extendsOptions, deferredData, deferredWatch, deferredProvide, true);\n      }\n      // local mixins\n      if (mixins) {\n          applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide);\n      }\n      const checkDuplicateProperties =  createDuplicateChecker() ;\n      {\n          const [propsOptions] = instance.propsOptions;\n          if (propsOptions) {\n              for (const key in propsOptions) {\n                  checkDuplicateProperties("Props" /* PROPS */, key);\n              }\n          }\n      }\n      // options initialization order (to be consistent with Vue 2):\n      // - props (already done outside of this function)\n      // - inject\n      // - methods\n      // - data (deferred since it relies on `this` access)\n      // - computed\n      // - watch (deferred since it relies on `this` access)\n      if (injectOptions) {\n          if (isArray(injectOptions)) {\n              for (let i = 0; i < injectOptions.length; i++) {\n                  const key = injectOptions[i];\n                  ctx[key] = inject(key);\n                  {\n                      checkDuplicateProperties("Inject" /* INJECT */, key);\n                  }\n              }\n          }\n          else {\n              for (const key in injectOptions) {\n                  const opt = injectOptions[key];\n                  if (isObject(opt)) {\n                      ctx[key] = inject(opt.from || key, opt.default, true /* treat default function as factory */);\n                  }\n                  else {\n                      ctx[key] = inject(opt);\n                  }\n                  {\n                      checkDuplicateProperties("Inject" /* INJECT */, key);\n                  }\n              }\n          }\n      }\n      if (methods) {\n          for (const key in methods) {\n              const methodHandler = methods[key];\n              if (isFunction(methodHandler)) {\n                  ctx[key] = methodHandler.bind(publicThis);\n                  {\n                      checkDuplicateProperties("Methods" /* METHODS */, key);\n                  }\n              }\n              else {\n                  warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. ` +\n                      `Did you reference the function correctly?`);\n              }\n          }\n      }\n      if (!asMixin) {\n          if (deferredData.length) {\n              deferredData.forEach(dataFn => resolveData(instance, dataFn, publicThis));\n          }\n          if (dataOptions) {\n              resolveData(instance, dataOptions, publicThis);\n          }\n          {\n              const rawData = toRaw(instance.data);\n              for (const key in rawData) {\n                  checkDuplicateProperties("Data" /* DATA */, key);\n                  // expose data on ctx during dev\n                  if (key[0] !== \'$\' && key[0] !== \'_\') {\n                      Object.defineProperty(ctx, key, {\n                          configurable: true,\n                          enumerable: true,\n                          get: () => rawData[key],\n                          set: NOOP\n                      });\n                  }\n              }\n          }\n      }\n      else if (dataOptions) {\n          deferredData.push(dataOptions);\n      }\n      if (computedOptions) {\n          for (const key in computedOptions) {\n              const opt = computedOptions[key];\n              const get = isFunction(opt)\n                  ? opt.bind(publicThis, publicThis)\n                  : isFunction(opt.get)\n                      ? opt.get.bind(publicThis, publicThis)\n                      : NOOP;\n              if ( get === NOOP) {\n                  warn(`Computed property "${key}" has no getter.`);\n              }\n              const set = !isFunction(opt) && isFunction(opt.set)\n                  ? opt.set.bind(publicThis)\n                  :  () => {\n                          warn(`Write operation failed: computed property "${key}" is readonly.`);\n                      }\n                      ;\n              const c = computed$1({\n                  get,\n                  set\n              });\n              Object.defineProperty(ctx, key, {\n                  enumerable: true,\n                  configurable: true,\n                  get: () => c.value,\n                  set: v => (c.value = v)\n              });\n              {\n                  checkDuplicateProperties("Computed" /* COMPUTED */, key);\n              }\n          }\n      }\n      if (watchOptions) {\n          deferredWatch.push(watchOptions);\n      }\n      if (!asMixin && deferredWatch.length) {\n          deferredWatch.forEach(watchOptions => {\n              for (const key in watchOptions) {\n                  createWatcher(watchOptions[key], ctx, publicThis, key);\n              }\n          });\n      }\n      if (provideOptions) {\n          deferredProvide.push(provideOptions);\n      }\n      if (!asMixin && deferredProvide.length) {\n          deferredProvide.forEach(provideOptions => {\n              const provides = isFunction(provideOptions)\n                  ? provideOptions.call(publicThis)\n                  : provideOptions;\n              for (const key in provides) {\n                  provide(key, provides[key]);\n              }\n          });\n      }\n      // asset options.\n      // To reduce memory usage, only components with mixins or extends will have\n      // resolved asset registry attached to instance.\n      if (asMixin) {\n          if (components) {\n              extend(instance.components ||\n                  (instance.components = extend({}, instance.type.components)), components);\n          }\n          if (directives) {\n              extend(instance.directives ||\n                  (instance.directives = extend({}, instance.type.directives)), directives);\n          }\n      }\n      // lifecycle options\n      if (!asMixin) {\n          callSyncHook(\'created\', "c" /* CREATED */, options, instance, globalMixins);\n      }\n      if (beforeMount) {\n          onBeforeMount(beforeMount.bind(publicThis));\n      }\n      if (mounted) {\n          onMounted(mounted.bind(publicThis));\n      }\n      if (beforeUpdate) {\n          onBeforeUpdate(beforeUpdate.bind(publicThis));\n      }\n      if (updated) {\n          onUpdated(updated.bind(publicThis));\n      }\n      if (activated) {\n          onActivated(activated.bind(publicThis));\n      }\n      if (deactivated) {\n          onDeactivated(deactivated.bind(publicThis));\n      }\n      if (errorCaptured) {\n          onErrorCaptured(errorCaptured.bind(publicThis));\n      }\n      if (renderTracked) {\n          onRenderTracked(renderTracked.bind(publicThis));\n      }\n      if (renderTriggered) {\n          onRenderTriggered(renderTriggered.bind(publicThis));\n      }\n      if ( beforeDestroy) {\n          warn(`\\`beforeDestroy\\` has been renamed to \\`beforeUnmount\\`.`);\n      }\n      if (beforeUnmount) {\n          onBeforeUnmount(beforeUnmount.bind(publicThis));\n      }\n      if ( destroyed) {\n          warn(`\\`destroyed\\` has been renamed to \\`unmounted\\`.`);\n      }\n      if (unmounted) {\n          onUnmounted(unmounted.bind(publicThis));\n      }\n  }\n  function callSyncHook(name, type, options, instance, globalMixins) {\n      callHookFromMixins(name, type, globalMixins, instance);\n      const { extends: base, mixins } = options;\n      if (base) {\n          callHookFromExtends(name, type, base, instance);\n      }\n      if (mixins) {\n          callHookFromMixins(name, type, mixins, instance);\n      }\n      const selfHook = options[name];\n      if (selfHook) {\n          callWithAsyncErrorHandling(selfHook.bind(instance.proxy), instance, type);\n      }\n  }\n  function callHookFromExtends(name, type, base, instance) {\n      if (base.extends) {\n          callHookFromExtends(name, type, base.extends, instance);\n      }\n      const baseHook = base[name];\n      if (baseHook) {\n          callWithAsyncErrorHandling(baseHook.bind(instance.proxy), instance, type);\n      }\n  }\n  function callHookFromMixins(name, type, mixins, instance) {\n      for (let i = 0; i < mixins.length; i++) {\n          const chainedMixins = mixins[i].mixins;\n          if (chainedMixins) {\n              callHookFromMixins(name, type, chainedMixins, instance);\n          }\n          const fn = mixins[i][name];\n          if (fn) {\n              callWithAsyncErrorHandling(fn.bind(instance.proxy), instance, type);\n          }\n      }\n  }\n  function applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide) {\n      for (let i = 0; i < mixins.length; i++) {\n          applyOptions(instance, mixins[i], deferredData, deferredWatch, deferredProvide, true);\n      }\n  }\n  function resolveData(instance, dataFn, publicThis) {\n      if ( !isFunction(dataFn)) {\n          warn(`The data option must be a function. ` +\n              `Plain object usage is no longer supported.`);\n      }\n      const data = dataFn.call(publicThis, publicThis);\n      if ( isPromise(data)) {\n          warn(`data() returned a Promise - note data() cannot be async; If you ` +\n              `intend to perform data fetching before component renders, use ` +\n              `async setup() + <Suspense>.`);\n      }\n      if (!isObject(data)) {\n           warn(`data() should return an object.`);\n      }\n      else if (instance.data === EMPTY_OBJ) {\n          instance.data = reactive(data);\n      }\n      else {\n          // existing data: this is a mixin or extends.\n          extend(instance.data, data);\n      }\n  }\n  function createWatcher(raw, ctx, publicThis, key) {\n      const getter = key.includes(\'.\')\n          ? createPathGetter(publicThis, key)\n          : () => publicThis[key];\n      if (isString(raw)) {\n          const handler = ctx[raw];\n          if (isFunction(handler)) {\n              watch(getter, handler);\n          }\n          else {\n              warn(`Invalid watch handler specified by key "${raw}"`, handler);\n          }\n      }\n      else if (isFunction(raw)) {\n          watch(getter, raw.bind(publicThis));\n      }\n      else if (isObject(raw)) {\n          if (isArray(raw)) {\n              raw.forEach(r => createWatcher(r, ctx, publicThis, key));\n          }\n          else {\n              const handler = isFunction(raw.handler)\n                  ? raw.handler.bind(publicThis)\n                  : ctx[raw.handler];\n              if (isFunction(handler)) {\n                  watch(getter, handler, raw);\n              }\n              else {\n                  warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);\n              }\n          }\n      }\n      else {\n          warn(`Invalid watch option: "${key}"`, raw);\n      }\n  }\n  function createPathGetter(ctx, path) {\n      const segments = path.split(\'.\');\n      return () => {\n          let cur = ctx;\n          for (let i = 0; i < segments.length && cur; i++) {\n              cur = cur[segments[i]];\n          }\n          return cur;\n      };\n  }\n  function resolveMergedOptions(instance) {\n      const raw = instance.type;\n      const { __merged, mixins, extends: extendsOptions } = raw;\n      if (__merged)\n          return __merged;\n      const globalMixins = instance.appContext.mixins;\n      if (!globalMixins.length && !mixins && !extendsOptions)\n          return raw;\n      const options = {};\n      globalMixins.forEach(m => mergeOptions(options, m, instance));\n      mergeOptions(options, raw, instance);\n      return (raw.__merged = options);\n  }\n  function mergeOptions(to, from, instance) {\n      const strats = instance.appContext.config.optionMergeStrategies;\n      const { mixins, extends: extendsOptions } = from;\n      extendsOptions && mergeOptions(to, extendsOptions, instance);\n      mixins &&\n          mixins.forEach((m) => mergeOptions(to, m, instance));\n      for (const key in from) {\n          if (strats && hasOwn(strats, key)) {\n              to[key] = strats[key](to[key], from[key], instance.proxy, key);\n          }\n          else {\n              to[key] = from[key];\n          }\n      }\n  }\n\n  const publicPropertiesMap = extend(Object.create(null), {\n      $: i => i,\n      $el: i => i.vnode.el,\n      $data: i => i.data,\n      $props: i => ( shallowReadonly(i.props) ),\n      $attrs: i => ( shallowReadonly(i.attrs) ),\n      $slots: i => ( shallowReadonly(i.slots) ),\n      $refs: i => ( shallowReadonly(i.refs) ),\n      $parent: i => i.parent && i.parent.proxy,\n      $root: i => i.root && i.root.proxy,\n      $emit: i => i.emit,\n      $options: i => ( resolveMergedOptions(i) ),\n      $forceUpdate: i => () => queueJob(i.update),\n      $nextTick: i => nextTick.bind(i.proxy),\n      $watch: i => ( instanceWatch.bind(i) )\n  });\n  const PublicInstanceProxyHandlers = {\n      get({ _: instance }, key) {\n          const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\n          // let @vue/reactivity know it should never observe Vue public instances.\n          if (key === "__v_skip" /* SKIP */) {\n              return true;\n          }\n          // for internal formatters to know that this is a Vue instance\n          if ( key === \'__isVue\') {\n              return true;\n          }\n          // data / props / ctx\n          // This getter gets called for every property access on the render context\n          // during render and is a major hotspot. The most expensive part of this\n          // is the multiple hasOwn() calls. It\'s much faster to do a simple property\n          // access on a plain object, so we use an accessCache object (with null\n          // prototype) to memoize what access type a key corresponds to.\n          let normalizedProps;\n          if (key[0] !== \'$\') {\n              const n = accessCache[key];\n              if (n !== undefined) {\n                  switch (n) {\n                      case 0 /* SETUP */:\n                          return setupState[key];\n                      case 1 /* DATA */:\n                          return data[key];\n                      case 3 /* CONTEXT */:\n                          return ctx[key];\n                      case 2 /* PROPS */:\n                          return props[key];\n                      // default: just fallthrough\n                  }\n              }\n              else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\n                  accessCache[key] = 0 /* SETUP */;\n                  return setupState[key];\n              }\n              else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n                  accessCache[key] = 1 /* DATA */;\n                  return data[key];\n              }\n              else if (\n              // only cache other properties when instance has declared (thus stable)\n              // props\n              (normalizedProps = instance.propsOptions[0]) &&\n                  hasOwn(normalizedProps, key)) {\n                  accessCache[key] = 2 /* PROPS */;\n                  return props[key];\n              }\n              else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n                  accessCache[key] = 3 /* CONTEXT */;\n                  return ctx[key];\n              }\n              else if ( !isInBeforeCreate) {\n                  accessCache[key] = 4 /* OTHER */;\n              }\n          }\n          const publicGetter = publicPropertiesMap[key];\n          let cssModule, globalProperties;\n          // public $xxx properties\n          if (publicGetter) {\n              if (key === \'$attrs\') {\n                  track(instance, "get" /* GET */, key);\n                   markAttrsAccessed();\n              }\n              return publicGetter(instance);\n          }\n          else if (\n          // css module (injected by vue-loader)\n          (cssModule = type.__cssModules) &&\n              (cssModule = cssModule[key])) {\n              return cssModule;\n          }\n          else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n              // user may set custom properties to `this` that start with `$`\n              accessCache[key] = 3 /* CONTEXT */;\n              return ctx[key];\n          }\n          else if (\n          // global properties\n          ((globalProperties = appContext.config.globalProperties),\n              hasOwn(globalProperties, key))) {\n              return globalProperties[key];\n          }\n          else if (\n              currentRenderingInstance &&\n              (!isString(key) ||\n                  // #1091 avoid internal isRef/isVNode checks on component instance leading\n                  // to infinite warning loop\n                  key.indexOf(\'__v\') !== 0)) {\n              if (data !== EMPTY_OBJ &&\n                  (key[0] === \'$\' || key[0] === \'_\') &&\n                  hasOwn(data, key)) {\n                  warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +\n                      `character ("$" or "_") and is not proxied on the render context.`);\n              }\n              else {\n                  warn(`Property ${JSON.stringify(key)} was accessed during render ` +\n                      `but is not defined on instance.`);\n              }\n          }\n      },\n      set({ _: instance }, key, value) {\n          const { data, setupState, ctx } = instance;\n          if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\n              setupState[key] = value;\n          }\n          else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n              data[key] = value;\n          }\n          else if (key in instance.props) {\n              \n                  warn(`Attempting to mutate prop "${key}". Props are readonly.`, instance);\n              return false;\n          }\n          if (key[0] === \'$\' && key.slice(1) in instance) {\n              \n                  warn(`Attempting to mutate public property "${key}". ` +\n                      `Properties starting with $ are reserved and readonly.`, instance);\n              return false;\n          }\n          else {\n              if ( key in instance.appContext.config.globalProperties) {\n                  Object.defineProperty(ctx, key, {\n                      enumerable: true,\n                      configurable: true,\n                      value\n                  });\n              }\n              else {\n                  ctx[key] = value;\n              }\n          }\n          return true;\n      },\n      has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\n          let normalizedProps;\n          return (accessCache[key] !== undefined ||\n              (data !== EMPTY_OBJ && hasOwn(data, key)) ||\n              (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||\n              ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\n              hasOwn(ctx, key) ||\n              hasOwn(publicPropertiesMap, key) ||\n              hasOwn(appContext.config.globalProperties, key));\n      }\n  };\n  {\n      PublicInstanceProxyHandlers.ownKeys = (target) => {\n          warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +\n              `The keys will be empty in production mode to avoid performance overhead.`);\n          return Reflect.ownKeys(target);\n      };\n  }\n  const RuntimeCompiledPublicInstanceProxyHandlers = extend({}, PublicInstanceProxyHandlers, {\n      get(target, key) {\n          // fast path for unscopables when using `with` block\n          if (key === Symbol.unscopables) {\n              return;\n          }\n          return PublicInstanceProxyHandlers.get(target, key, target);\n      },\n      has(_, key) {\n          const has = key[0] !== \'_\' && !isGloballyWhitelisted(key);\n          if ( !has && PublicInstanceProxyHandlers.has(_, key)) {\n              warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);\n          }\n          return has;\n      }\n  });\n  // In dev mode, the proxy target exposes the same properties as seen on `this`\n  // for easier console inspection. In prod mode it will be an empty object so\n  // these properties definitions can be skipped.\n  function createRenderContext(instance) {\n      const target = {};\n      // expose internal instance for proxy handlers\n      Object.defineProperty(target, `_`, {\n          configurable: true,\n          enumerable: false,\n          get: () => instance\n      });\n      // expose public properties\n      Object.keys(publicPropertiesMap).forEach(key => {\n          Object.defineProperty(target, key, {\n              configurable: true,\n              enumerable: false,\n              get: () => publicPropertiesMap[key](instance),\n              // intercepted by the proxy so no need for implementation,\n              // but needed to prevent set errors\n              set: NOOP\n          });\n      });\n      // expose global properties\n      const { globalProperties } = instance.appContext.config;\n      Object.keys(globalProperties).forEach(key => {\n          Object.defineProperty(target, key, {\n              configurable: true,\n              enumerable: false,\n              get: () => globalProperties[key],\n              set: NOOP\n          });\n      });\n      return target;\n  }\n  // dev only\n  function exposePropsOnRenderContext(instance) {\n      const { ctx, propsOptions: [propsOptions] } = instance;\n      if (propsOptions) {\n          Object.keys(propsOptions).forEach(key => {\n              Object.defineProperty(ctx, key, {\n                  enumerable: true,\n                  configurable: true,\n                  get: () => instance.props[key],\n                  set: NOOP\n              });\n          });\n      }\n  }\n  // dev only\n  function exposeSetupStateOnRenderContext(instance) {\n      const { ctx, setupState } = instance;\n      Object.keys(toRaw(setupState)).forEach(key => {\n          if (key[0] === \'$\' || key[0] === \'_\') {\n              warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` +\n                  `which are reserved prefixes for Vue internals.`);\n              return;\n          }\n          Object.defineProperty(ctx, key, {\n              enumerable: true,\n              configurable: true,\n              get: () => setupState[key],\n              set: NOOP\n          });\n      });\n  }\n\n  const emptyAppContext = createAppContext();\n  let uid$2 = 0;\n  function createComponentInstance(vnode, parent, suspense) {\n      const type = vnode.type;\n      // inherit parent app context - or - if root, adopt from root vnode\n      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\n      const instance = {\n          uid: uid$2++,\n          vnode,\n          type,\n          parent,\n          appContext,\n          root: null,\n          next: null,\n          subTree: null,\n          update: null,\n          render: null,\n          proxy: null,\n          withProxy: null,\n          effects: null,\n          provides: parent ? parent.provides : Object.create(appContext.provides),\n          accessCache: null,\n          renderCache: [],\n          // local resovled assets\n          components: null,\n          directives: null,\n          // resolved props and emits options\n          propsOptions: normalizePropsOptions(type, appContext),\n          emitsOptions: normalizeEmitsOptions(type, appContext),\n          // emit\n          emit: null,\n          emitted: null,\n          // state\n          ctx: EMPTY_OBJ,\n          data: EMPTY_OBJ,\n          props: EMPTY_OBJ,\n          attrs: EMPTY_OBJ,\n          slots: EMPTY_OBJ,\n          refs: EMPTY_OBJ,\n          setupState: EMPTY_OBJ,\n          setupContext: null,\n          // suspense related\n          suspense,\n          suspenseId: suspense ? suspense.pendingId : 0,\n          asyncDep: null,\n          asyncResolved: false,\n          // lifecycle hooks\n          // not using enums here because it results in computed properties\n          isMounted: false,\n          isUnmounted: false,\n          isDeactivated: false,\n          bc: null,\n          c: null,\n          bm: null,\n          m: null,\n          bu: null,\n          u: null,\n          um: null,\n          bum: null,\n          da: null,\n          a: null,\n          rtg: null,\n          rtc: null,\n          ec: null\n      };\n      {\n          instance.ctx = createRenderContext(instance);\n      }\n      instance.root = parent ? parent.root : instance;\n      instance.emit = emit.bind(null, instance);\n      {\n          devtoolsComponentAdded(instance);\n      }\n      return instance;\n  }\n  let currentInstance = null;\n  const getCurrentInstance = () => currentInstance || currentRenderingInstance;\n  const setCurrentInstance = (instance) => {\n      currentInstance = instance;\n  };\n  const isBuiltInTag = /*#__PURE__*/ makeMap(\'slot,component\');\n  function validateComponentName(name, config) {\n      const appIsNativeTag = config.isNativeTag || NO;\n      if (isBuiltInTag(name) || appIsNativeTag(name)) {\n          warn(\'Do not use built-in or reserved HTML elements as component id: \' + name);\n      }\n  }\n  let isInSSRComponentSetup = false;\n  function setupComponent(instance, isSSR = false) {\n      isInSSRComponentSetup = isSSR;\n      const { props, children, shapeFlag } = instance.vnode;\n      const isStateful = shapeFlag & 4 /* STATEFUL_COMPONENT */;\n      initProps(instance, props, isStateful, isSSR);\n      initSlots(instance, children);\n      const setupResult = isStateful\n          ? setupStatefulComponent(instance, isSSR)\n          : undefined;\n      isInSSRComponentSetup = false;\n      return setupResult;\n  }\n  function setupStatefulComponent(instance, isSSR) {\n      const Component = instance.type;\n      {\n          if (Component.name) {\n              validateComponentName(Component.name, instance.appContext.config);\n          }\n          if (Component.components) {\n              const names = Object.keys(Component.components);\n              for (let i = 0; i < names.length; i++) {\n                  validateComponentName(names[i], instance.appContext.config);\n              }\n          }\n          if (Component.directives) {\n              const names = Object.keys(Component.directives);\n              for (let i = 0; i < names.length; i++) {\n                  validateDirectiveName(names[i]);\n              }\n          }\n      }\n      // 0. create render proxy property access cache\n      instance.accessCache = Object.create(null);\n      // 1. create public instance / render proxy\n      // also mark it raw so it\'s never observed\n      instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);\n      {\n          exposePropsOnRenderContext(instance);\n      }\n      // 2. call setup()\n      const { setup } = Component;\n      if (setup) {\n          const setupContext = (instance.setupContext =\n              setup.length > 1 ? createSetupContext(instance) : null);\n          currentInstance = instance;\n          pauseTracking();\n          const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [ shallowReadonly(instance.props) , setupContext]);\n          resetTracking();\n          currentInstance = null;\n          if (isPromise(setupResult)) {\n              if (isSSR) {\n                  // return the promise so server-renderer can wait on it\n                  return setupResult.then((resolvedResult) => {\n                      handleSetupResult(instance, resolvedResult);\n                  });\n              }\n              else {\n                  // async setup returned Promise.\n                  // bail here and wait for re-entry.\n                  instance.asyncDep = setupResult;\n              }\n          }\n          else {\n              handleSetupResult(instance, setupResult);\n          }\n      }\n      else {\n          finishComponentSetup(instance);\n      }\n  }\n  function handleSetupResult(instance, setupResult, isSSR) {\n      if (isFunction(setupResult)) {\n          // setup returned an inline render function\n          instance.render = setupResult;\n      }\n      else if (isObject(setupResult)) {\n          if ( isVNode(setupResult)) {\n              warn(`setup() should not return VNodes directly - ` +\n                  `return a render function instead.`);\n          }\n          // setup returned bindings.\n          // assuming a render function compiled from template is present.\n          {\n              instance.devtoolsRawSetupState = setupResult;\n          }\n          instance.setupState = proxyRefs(setupResult);\n          {\n              exposeSetupStateOnRenderContext(instance);\n          }\n      }\n      else if ( setupResult !== undefined) {\n          warn(`setup() should return an object. Received: ${setupResult === null ? \'null\' : typeof setupResult}`);\n      }\n      finishComponentSetup(instance);\n  }\n  let compile;\n  /**\n   * For runtime-dom to register the compiler.\n   * Note the exported method uses any to avoid d.ts relying on the compiler types.\n   */\n  function registerRuntimeCompiler(_compile) {\n      compile = _compile;\n  }\n  function finishComponentSetup(instance, isSSR) {\n      const Component = instance.type;\n      // template / render function normalization\n      if (!instance.render) {\n          // could be set from setup()\n          if (compile && Component.template && !Component.render) {\n              {\n                  startMeasure(instance, `compile`);\n              }\n              Component.render = compile(Component.template, {\n                  isCustomElement: instance.appContext.config.isCustomElement,\n                  delimiters: Component.delimiters\n              });\n              {\n                  endMeasure(instance, `compile`);\n              }\n          }\n          instance.render = (Component.render || NOOP);\n          // for runtime-compiled render functions using `with` blocks, the render\n          // proxy used needs a different `has` handler which is more performant and\n          // also only allows a whitelist of globals to fallthrough.\n          if (instance.render._rc) {\n              instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\n          }\n      }\n      // support for 2.x options\n      {\n          currentInstance = instance;\n          applyOptions(instance, Component);\n          currentInstance = null;\n      }\n      // warn missing template/render\n      if ( !Component.render && instance.render === NOOP) {\n          /* istanbul ignore if */\n          if (!compile && Component.template) {\n              warn(`Component provided template option but ` +\n                  `runtime compilation is not supported in this build of Vue.` +\n                  (   ` Use "vue.global.js" instead.`\n                              ) /* should not happen */);\n          }\n          else {\n              warn(`Component is missing template or render function.`);\n          }\n      }\n  }\n  const attrHandlers = {\n      get: (target, key) => {\n          {\n              markAttrsAccessed();\n          }\n          return target[key];\n      },\n      set: () => {\n          warn(`setupContext.attrs is readonly.`);\n          return false;\n      },\n      deleteProperty: () => {\n          warn(`setupContext.attrs is readonly.`);\n          return false;\n      }\n  };\n  function createSetupContext(instance) {\n      {\n          // We use getters in dev in case libs like test-utils overwrite instance\n          // properties (overwrites should not be done in prod)\n          return Object.freeze({\n              get attrs() {\n                  return new Proxy(instance.attrs, attrHandlers);\n              },\n              get slots() {\n                  return shallowReadonly(instance.slots);\n              },\n              get emit() {\n                  return (event, ...args) => instance.emit(event, ...args);\n              }\n          });\n      }\n  }\n  // record effects created during a component\'s setup() so that they can be\n  // stopped when the component unmounts\n  function recordInstanceBoundEffect(effect) {\n      if (currentInstance) {\n          (currentInstance.effects || (currentInstance.effects = [])).push(effect);\n      }\n  }\n  const classifyRE = /(?:^|[-_])(\\w)/g;\n  const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, \'\');\n  /* istanbul ignore next */\n  function formatComponentName(instance, Component, isRoot = false) {\n      let name = isFunction(Component)\n          ? Component.displayName || Component.name\n          : Component.name;\n      if (!name && Component.__file) {\n          const match = Component.__file.match(/([^/\\\\]+)\\.vue$/);\n          if (match) {\n              name = match[1];\n          }\n      }\n      if (!name && instance && instance.parent) {\n          // try to infer the name based on reverse resolution\n          const inferFromRegistry = (registry) => {\n              for (const key in registry) {\n                  if (registry[key] === Component) {\n                      return key;\n                  }\n              }\n          };\n          name =\n              inferFromRegistry(instance.components ||\n                  instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\n      }\n      return name ? classify(name) : isRoot ? `App` : `Anonymous`;\n  }\n  function isClassComponent(value) {\n      return isFunction(value) && \'__vccOpts\' in value;\n  }\n\n  function computed$1(getterOrOptions) {\n      const c = computed(getterOrOptions);\n      recordInstanceBoundEffect(c.effect);\n      return c;\n  }\n\n  // implementation, close to no-op\n  function defineComponent(options) {\n      return isFunction(options) ? { setup: options, name: options.name } : options;\n  }\n\n  function defineAsyncComponent(source) {\n      if (isFunction(source)) {\n          source = { loader: source };\n      }\n      const { loader, loadingComponent: loadingComponent, errorComponent: errorComponent, delay = 200, timeout, // undefined = never times out\n      suspensible = true, onError: userOnError } = source;\n      let pendingRequest = null;\n      let resolvedComp;\n      let retries = 0;\n      const retry = () => {\n          retries++;\n          pendingRequest = null;\n          return load();\n      };\n      const load = () => {\n          let thisRequest;\n          return (pendingRequest ||\n              (thisRequest = pendingRequest = loader()\n                  .catch(err => {\n                  err = err instanceof Error ? err : new Error(String(err));\n                  if (userOnError) {\n                      return new Promise((resolve, reject) => {\n                          const userRetry = () => resolve(retry());\n                          const userFail = () => reject(err);\n                          userOnError(err, userRetry, userFail, retries + 1);\n                      });\n                  }\n                  else {\n                      throw err;\n                  }\n              })\n                  .then((comp) => {\n                  if (thisRequest !== pendingRequest && pendingRequest) {\n                      return pendingRequest;\n                  }\n                  if ( !comp) {\n                      warn(`Async component loader resolved to undefined. ` +\n                          `If you are using retry(), make sure to return its return value.`);\n                  }\n                  // interop module default\n                  if (comp &&\n                      (comp.__esModule || comp[Symbol.toStringTag] === \'Module\')) {\n                      comp = comp.default;\n                  }\n                  if ( comp && !isObject(comp) && !isFunction(comp)) {\n                      throw new Error(`Invalid async component load result: ${comp}`);\n                  }\n                  resolvedComp = comp;\n                  return comp;\n              })));\n      };\n      return defineComponent({\n          __asyncLoader: load,\n          name: \'AsyncComponentWrapper\',\n          setup() {\n              const instance = currentInstance;\n              // already resolved\n              if (resolvedComp) {\n                  return () => createInnerComp(resolvedComp, instance);\n              }\n              const onError = (err) => {\n                  pendingRequest = null;\n                  handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);\n              };\n              // suspense-controlled or SSR.\n              if (( suspensible && instance.suspense) ||\n                  (false )) {\n                  return load()\n                      .then(comp => {\n                      return () => createInnerComp(comp, instance);\n                  })\n                      .catch(err => {\n                      onError(err);\n                      return () => errorComponent\n                          ? createVNode(errorComponent, {\n                              error: err\n                          })\n                          : null;\n                  });\n              }\n              const loaded = ref(false);\n              const error = ref();\n              const delayed = ref(!!delay);\n              if (delay) {\n                  setTimeout(() => {\n                      delayed.value = false;\n                  }, delay);\n              }\n              if (timeout != null) {\n                  setTimeout(() => {\n                      if (!loaded.value && !error.value) {\n                          const err = new Error(`Async component timed out after ${timeout}ms.`);\n                          onError(err);\n                          error.value = err;\n                      }\n                  }, timeout);\n              }\n              load()\n                  .then(() => {\n                  loaded.value = true;\n              })\n                  .catch(err => {\n                  onError(err);\n                  error.value = err;\n              });\n              return () => {\n                  if (loaded.value && resolvedComp) {\n                      return createInnerComp(resolvedComp, instance);\n                  }\n                  else if (error.value && errorComponent) {\n                      return createVNode(errorComponent, {\n                          error: error.value\n                      });\n                  }\n                  else if (loadingComponent && !delayed.value) {\n                      return createVNode(loadingComponent);\n                  }\n              };\n          }\n      });\n  }\n  function createInnerComp(comp, { vnode: { props, children } }) {\n      return createVNode(comp, props, children);\n  }\n\n  // Actual implementation\n  function h(type, propsOrChildren, children) {\n      const l = arguments.length;\n      if (l === 2) {\n          if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {\n              // single vnode without props\n              if (isVNode(propsOrChildren)) {\n                  return createVNode(type, null, [propsOrChildren]);\n              }\n              // props without children\n              return createVNode(type, propsOrChildren);\n          }\n          else {\n              // omit props\n              return createVNode(type, null, propsOrChildren);\n          }\n      }\n      else {\n          if (l > 3) {\n              children = Array.prototype.slice.call(arguments, 2);\n          }\n          else if (l === 3 && isVNode(children)) {\n              children = [children];\n          }\n          return createVNode(type, propsOrChildren, children);\n      }\n  }\n\n  const ssrContextKey = Symbol( `ssrContext` );\n  const useSSRContext = () => {\n      {\n          warn(`useSsrContext() is not supported in the global build.`);\n      }\n  };\n\n  function initCustomFormatter() {\n      const vueStyle = { style: \'color:#3ba776\' };\n      const numberStyle = { style: \'color:#0b1bc9\' };\n      const stringStyle = { style: \'color:#b62e24\' };\n      const keywordStyle = { style: \'color:#9d288c\' };\n      // custom formatter for Chrome\n      // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\n      const formatter = {\n          header(obj) {\n              // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\n              if (!isObject(obj)) {\n                  return null;\n              }\n              if (obj.__isVue) {\n                  return [\'div\', vueStyle, `VueInstance`];\n              }\n              else if (isRef(obj)) {\n                  return [\n                      \'div\',\n                      {},\n                      [\'span\', vueStyle, genRefFlag(obj)],\n                      \'<\',\n                      formatValue(obj.value),\n                      `>`\n                  ];\n              }\n              else if (isReactive(obj)) {\n                  return [\n                      \'div\',\n                      {},\n                      [\'span\', vueStyle, \'Reactive\'],\n                      \'<\',\n                      formatValue(obj),\n                      `>${isReadonly(obj) ? ` (readonly)` : ``}`\n                  ];\n              }\n              else if (isReadonly(obj)) {\n                  return [\n                      \'div\',\n                      {},\n                      [\'span\', vueStyle, \'Readonly\'],\n                      \'<\',\n                      formatValue(obj),\n                      \'>\'\n                  ];\n              }\n              return null;\n          },\n          hasBody(obj) {\n              return obj && obj.__isVue;\n          },\n          body(obj) {\n              if (obj && obj.__isVue) {\n                  return [\n                      \'div\',\n                      {},\n                      ...formatInstance(obj.$)\n                  ];\n              }\n          }\n      };\n      function formatInstance(instance) {\n          const blocks = [];\n          if (instance.type.props && instance.props) {\n              blocks.push(createInstanceBlock(\'props\', toRaw(instance.props)));\n          }\n          if (instance.setupState !== EMPTY_OBJ) {\n              blocks.push(createInstanceBlock(\'setup\', instance.setupState));\n          }\n          if (instance.data !== EMPTY_OBJ) {\n              blocks.push(createInstanceBlock(\'data\', toRaw(instance.data)));\n          }\n          const computed = extractKeys(instance, \'computed\');\n          if (computed) {\n              blocks.push(createInstanceBlock(\'computed\', computed));\n          }\n          const injected = extractKeys(instance, \'inject\');\n          if (injected) {\n              blocks.push(createInstanceBlock(\'injected\', injected));\n          }\n          blocks.push([\n              \'div\',\n              {},\n              [\n                  \'span\',\n                  {\n                      style: keywordStyle.style + \';opacity:0.66\'\n                  },\n                  \'$ (internal): \'\n              ],\n              [\'object\', { object: instance }]\n          ]);\n          return blocks;\n      }\n      function createInstanceBlock(type, target) {\n          target = extend({}, target);\n          if (!Object.keys(target).length) {\n              return [\'span\', {}];\n          }\n          return [\n              \'div\',\n              { style: \'line-height:1.25em;margin-bottom:0.6em\' },\n              [\n                  \'div\',\n                  {\n                      style: \'color:#476582\'\n                  },\n                  type\n              ],\n              [\n                  \'div\',\n                  {\n                      style: \'padding-left:1.25em\'\n                  },\n                  ...Object.keys(target).map(key => {\n                      return [\n                          \'div\',\n                          {},\n                          [\'span\', keywordStyle, key + \': \'],\n                          formatValue(target[key], false)\n                      ];\n                  })\n              ]\n          ];\n      }\n      function formatValue(v, asRaw = true) {\n          if (typeof v === \'number\') {\n              return [\'span\', numberStyle, v];\n          }\n          else if (typeof v === \'string\') {\n              return [\'span\', stringStyle, JSON.stringify(v)];\n          }\n          else if (typeof v === \'boolean\') {\n              return [\'span\', keywordStyle, v];\n          }\n          else if (isObject(v)) {\n              return [\'object\', { object: asRaw ? toRaw(v) : v }];\n          }\n          else {\n              return [\'span\', stringStyle, String(v)];\n          }\n      }\n      function extractKeys(instance, type) {\n          const Comp = instance.type;\n          if (isFunction(Comp)) {\n              return;\n          }\n          const extracted = {};\n          for (const key in instance.ctx) {\n              if (isKeyOfType(Comp, key, type)) {\n                  extracted[key] = instance.ctx[key];\n              }\n          }\n          return extracted;\n      }\n      function isKeyOfType(Comp, key, type) {\n          const opts = Comp[type];\n          if ((isArray(opts) && opts.includes(key)) ||\n              (isObject(opts) && key in opts)) {\n              return true;\n          }\n          if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\n              return true;\n          }\n          if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\n              return true;\n          }\n      }\n      function genRefFlag(v) {\n          if (v._shallow) {\n              return `ShallowRef`;\n          }\n          if (v.effect) {\n              return `ComputedRef`;\n          }\n          return `Ref`;\n      }\n      /* eslint-disable no-restricted-globals */\n      if (window.devtoolsFormatters) {\n          window.devtoolsFormatters.push(formatter);\n      }\n      else {\n          window.devtoolsFormatters = [formatter];\n      }\n  }\n\n  /**\n   * Actual implementation\n   */\n  function renderList(source, renderItem) {\n      let ret;\n      if (isArray(source) || isString(source)) {\n          ret = new Array(source.length);\n          for (let i = 0, l = source.length; i < l; i++) {\n              ret[i] = renderItem(source[i], i);\n          }\n      }\n      else if (typeof source === \'number\') {\n          if ( !Number.isInteger(source)) {\n              warn(`The v-for range expect an integer value but got ${source}.`);\n              return [];\n          }\n          ret = new Array(source);\n          for (let i = 0; i < source; i++) {\n              ret[i] = renderItem(i + 1, i);\n          }\n      }\n      else if (isObject(source)) {\n          if (source[Symbol.iterator]) {\n              ret = Array.from(source, renderItem);\n          }\n          else {\n              const keys = Object.keys(source);\n              ret = new Array(keys.length);\n              for (let i = 0, l = keys.length; i < l; i++) {\n                  const key = keys[i];\n                  ret[i] = renderItem(source[key], key, i);\n              }\n          }\n      }\n      else {\n          ret = [];\n      }\n      return ret;\n  }\n\n  /**\n   * For prefixing keys in v-on="obj" with "on"\n   * @private\n   */\n  function toHandlers(obj) {\n      const ret = {};\n      if ( !isObject(obj)) {\n          warn(`v-on with no argument expects an object value.`);\n          return ret;\n      }\n      for (const key in obj) {\n          ret[toHandlerKey(key)] = obj[key];\n      }\n      return ret;\n  }\n\n  /**\n   * Compiler runtime helper for creating dynamic slots object\n   * @private\n   */\n  function createSlots(slots, dynamicSlots) {\n      for (let i = 0; i < dynamicSlots.length; i++) {\n          const slot = dynamicSlots[i];\n          // array of dynamic slot generated by <template v-for="..." #[...]>\n          if (isArray(slot)) {\n              for (let j = 0; j < slot.length; j++) {\n                  slots[slot[j].name] = slot[j].fn;\n              }\n          }\n          else if (slot) {\n              // conditional single slot generated by <template v-if="..." #foo>\n              slots[slot.name] = slot.fn;\n          }\n      }\n      return slots;\n  }\n\n  // Core API ------------------------------------------------------------------\n  const version = "3.0.2";\n  /**\n   * SSR utils for \\@vue/server-renderer. Only exposed in cjs builds.\n   * @internal\n   */\n  const ssrUtils = ( null);\n\n  const svgNS = \'http://www.w3.org/2000/svg\';\n  const doc = (typeof document !== \'undefined\' ? document : null);\n  let tempContainer;\n  let tempSVGContainer;\n  const nodeOps = {\n      insert: (child, parent, anchor) => {\n          parent.insertBefore(child, anchor || null);\n      },\n      remove: child => {\n          const parent = child.parentNode;\n          if (parent) {\n              parent.removeChild(child);\n          }\n      },\n      createElement: (tag, isSVG, is) => isSVG\n          ? doc.createElementNS(svgNS, tag)\n          : doc.createElement(tag, is ? { is } : undefined),\n      createText: text => doc.createTextNode(text),\n      createComment: text => doc.createComment(text),\n      setText: (node, text) => {\n          node.nodeValue = text;\n      },\n      setElementText: (el, text) => {\n          el.textContent = text;\n      },\n      parentNode: node => node.parentNode,\n      nextSibling: node => node.nextSibling,\n      querySelector: selector => doc.querySelector(selector),\n      setScopeId(el, id) {\n          el.setAttribute(id, \'\');\n      },\n      cloneNode(el) {\n          return el.cloneNode(true);\n      },\n      // __UNSAFE__\n      // Reason: innerHTML.\n      // Static content here can only come from compiled templates.\n      // As long as the user only uses trusted templates, this is safe.\n      insertStaticContent(content, parent, anchor, isSVG) {\n          const temp = isSVG\n              ? tempSVGContainer ||\n                  (tempSVGContainer = doc.createElementNS(svgNS, \'svg\'))\n              : tempContainer || (tempContainer = doc.createElement(\'div\'));\n          temp.innerHTML = content;\n          const first = temp.firstChild;\n          let node = first;\n          let last = node;\n          while (node) {\n              last = node;\n              nodeOps.insert(node, parent, anchor);\n              node = temp.firstChild;\n          }\n          return [first, last];\n      }\n  };\n\n  // compiler should normalize class + :class bindings on the same element\n  // into a single binding [\'staticClass\', dynamic]\n  function patchClass(el, value, isSVG) {\n      if (value == null) {\n          value = \'\';\n      }\n      if (isSVG) {\n          el.setAttribute(\'class\', value);\n      }\n      else {\n          // directly setting className should be faster than setAttribute in theory\n          // if this is an element during a transition, take the temporary transition\n          // classes into account.\n          const transitionClasses = el._vtc;\n          if (transitionClasses) {\n              value = (value\n                  ? [value, ...transitionClasses]\n                  : [...transitionClasses]).join(\' \');\n          }\n          el.className = value;\n      }\n  }\n\n  function patchStyle(el, prev, next) {\n      const style = el.style;\n      if (!next) {\n          el.removeAttribute(\'style\');\n      }\n      else if (isString(next)) {\n          if (prev !== next) {\n              style.cssText = next;\n          }\n      }\n      else {\n          for (const key in next) {\n              setStyle(style, key, next[key]);\n          }\n          if (prev && !isString(prev)) {\n              for (const key in prev) {\n                  if (next[key] == null) {\n                      setStyle(style, key, \'\');\n                  }\n              }\n          }\n      }\n  }\n  const importantRE = /\\s*!important$/;\n  function setStyle(style, name, val) {\n      if (isArray(val)) {\n          val.forEach(v => setStyle(style, name, v));\n      }\n      else {\n          if (name.startsWith(\'--\')) {\n              // custom property definition\n              style.setProperty(name, val);\n          }\n          else {\n              const prefixed = autoPrefix(style, name);\n              if (importantRE.test(val)) {\n                  // !important\n                  style.setProperty(hyphenate(prefixed), val.replace(importantRE, \'\'), \'important\');\n              }\n              else {\n                  style[prefixed] = val;\n              }\n          }\n      }\n  }\n  const prefixes = [\'Webkit\', \'Moz\', \'ms\'];\n  const prefixCache = {};\n  function autoPrefix(style, rawName) {\n      const cached = prefixCache[rawName];\n      if (cached) {\n          return cached;\n      }\n      let name = camelize(rawName);\n      if (name !== \'filter\' && name in style) {\n          return (prefixCache[rawName] = name);\n      }\n      name = capitalize(name);\n      for (let i = 0; i < prefixes.length; i++) {\n          const prefixed = prefixes[i] + name;\n          if (prefixed in style) {\n              return (prefixCache[rawName] = prefixed);\n          }\n      }\n      return rawName;\n  }\n\n  const xlinkNS = \'http://www.w3.org/1999/xlink\';\n  function patchAttr(el, key, value, isSVG) {\n      if (isSVG && key.startsWith(\'xlink:\')) {\n          if (value == null) {\n              el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\n          }\n          else {\n              el.setAttributeNS(xlinkNS, key, value);\n          }\n      }\n      else {\n          // note we are only checking boolean attributes that don\'t have a\n          // corresponding dom prop of the same name here.\n          const isBoolean = isSpecialBooleanAttr(key);\n          if (value == null || (isBoolean && value === false)) {\n              el.removeAttribute(key);\n          }\n          else {\n              el.setAttribute(key, isBoolean ? \'\' : value);\n          }\n      }\n  }\n\n  // __UNSAFE__\n  // functions. The user is responsible for using them with only trusted content.\n  function patchDOMProp(el, key, value, \n  // the following args are passed only due to potential innerHTML/textContent\n  // overriding existing VNodes, in which case the old tree must be properly\n  // unmounted.\n  prevChildren, parentComponent, parentSuspense, unmountChildren) {\n      if (key === \'innerHTML\' || key === \'textContent\') {\n          if (prevChildren) {\n              unmountChildren(prevChildren, parentComponent, parentSuspense);\n          }\n          el[key] = value == null ? \'\' : value;\n          return;\n      }\n      if (key === \'value\' && el.tagName !== \'PROGRESS\') {\n          // store value as _value as well since\n          // non-string values will be stringified.\n          el._value = value;\n          const newValue = value == null ? \'\' : value;\n          if (el.value !== newValue) {\n              el.value = newValue;\n          }\n          return;\n      }\n      if (value === \'\' && typeof el[key] === \'boolean\') {\n          // e.g. <select multiple> compiles to { multiple: \'\' }\n          el[key] = true;\n      }\n      else if (value == null && typeof el[key] === \'string\') {\n          // e.g. <div :id="null">\n          el[key] = \'\';\n          el.removeAttribute(key);\n      }\n      else {\n          // some properties perform value validation and throw\n          try {\n              el[key] = value;\n          }\n          catch (e) {\n              {\n                  warn(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: ` +\n                      `value ${value} is invalid.`, e);\n              }\n          }\n      }\n  }\n\n  // Async edge case fix requires storing an event listener\'s attach timestamp.\n  let _getNow = Date.now;\n  // Determine what event timestamp the browser is using. Annoyingly, the\n  // timestamp can either be hi-res (relative to page load) or low-res\n  // (relative to UNIX epoch), so in order to compare time we have to use the\n  // same timestamp type when saving the flush timestamp.\n  if (typeof document !== \'undefined\' &&\n      _getNow() > document.createEvent(\'Event\').timeStamp) {\n      // if the low-res timestamp which is bigger than the event timestamp\n      // (which is evaluated AFTER) it means the event is using a hi-res timestamp,\n      // and we need to use the hi-res version for event listeners as well.\n      _getNow = () => performance.now();\n  }\n  // To avoid the overhead of repeatedly calling performance.now(), we cache\n  // and use the same timestamp for all event listeners attached in the same tick.\n  let cachedNow = 0;\n  const p = Promise.resolve();\n  const reset = () => {\n      cachedNow = 0;\n  };\n  const getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));\n  function addEventListener(el, event, handler, options) {\n      el.addEventListener(event, handler, options);\n  }\n  function removeEventListener(el, event, handler, options) {\n      el.removeEventListener(event, handler, options);\n  }\n  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {\n      // vei = vue event invokers\n      const invokers = el._vei || (el._vei = {});\n      const existingInvoker = invokers[rawName];\n      if (nextValue && existingInvoker) {\n          // patch\n          existingInvoker.value = nextValue;\n      }\n      else {\n          const [name, options] = parseName(rawName);\n          if (nextValue) {\n              // add\n              const invoker = (invokers[rawName] = createInvoker(nextValue, instance));\n              addEventListener(el, name, invoker, options);\n          }\n          else if (existingInvoker) {\n              // remove\n              removeEventListener(el, name, existingInvoker, options);\n              invokers[rawName] = undefined;\n          }\n      }\n  }\n  const optionsModifierRE = /(?:Once|Passive|Capture)$/;\n  function parseName(name) {\n      let options;\n      if (optionsModifierRE.test(name)) {\n          options = {};\n          let m;\n          while ((m = name.match(optionsModifierRE))) {\n              name = name.slice(0, name.length - m[0].length);\n              options[m[0].toLowerCase()] = true;\n          }\n      }\n      return [name.slice(2).toLowerCase(), options];\n  }\n  function createInvoker(initialValue, instance) {\n      const invoker = (e) => {\n          // async edge case #6566: inner click event triggers patch, event handler\n          // attached to outer element during patch, and triggered again. This\n          // happens because browsers fire microtask ticks between event propagation.\n          // the solution is simple: we save the timestamp when a handler is attached,\n          // and the handler would only fire if the event passed to it was fired\n          // AFTER it was attached.\n          const timeStamp = e.timeStamp || _getNow();\n          if (timeStamp >= invoker.attached - 1) {\n              callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);\n          }\n      };\n      invoker.value = initialValue;\n      invoker.attached = getNow();\n      return invoker;\n  }\n  function patchStopImmediatePropagation(e, value) {\n      if (isArray(value)) {\n          const originalStop = e.stopImmediatePropagation;\n          e.stopImmediatePropagation = () => {\n              originalStop.call(e);\n              e._stopped = true;\n          };\n          return value.map(fn => (e) => !e._stopped && fn(e));\n      }\n      else {\n          return value;\n      }\n  }\n\n  const nativeOnRE = /^on[a-z]/;\n  const forcePatchProp = (_, key) => key === \'value\';\n  const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\n      switch (key) {\n          // special\n          case \'class\':\n              patchClass(el, nextValue, isSVG);\n              break;\n          case \'style\':\n              patchStyle(el, prevValue, nextValue);\n              break;\n          default:\n              if (isOn(key)) {\n                  // ignore v-model listeners\n                  if (!isModelListener(key)) {\n                      patchEvent(el, key, prevValue, nextValue, parentComponent);\n                  }\n              }\n              else if (shouldSetAsProp(el, key, nextValue, isSVG)) {\n                  patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\n              }\n              else {\n                  // special case for <input v-model type="checkbox"> with\n                  // :true-value & :false-value\n                  // store value as dom properties since non-string values will be\n                  // stringified.\n                  if (key === \'true-value\') {\n                      el._trueValue = nextValue;\n                  }\n                  else if (key === \'false-value\') {\n                      el._falseValue = nextValue;\n                  }\n                  patchAttr(el, key, nextValue, isSVG);\n              }\n              break;\n      }\n  };\n  function shouldSetAsProp(el, key, value, isSVG) {\n      if (isSVG) {\n          // most keys must be set as attribute on svg elements to work\n          // ...except innerHTML\n          if (key === \'innerHTML\') {\n              return true;\n          }\n          // or native onclick with function values\n          if (key in el && nativeOnRE.test(key) && isFunction(value)) {\n              return true;\n          }\n          return false;\n      }\n      // spellcheck and draggable are numerated attrs, however their\n      // corresponding DOM properties are actually booleans - this leads to\n      // setting it with a string "false" value leading it to be coerced to\n      // `true`, so we need to always treat them as attributes.\n      // Note that `contentEditable` doesn\'t have this problem: its DOM\n      // property is also enumerated string values.\n      if (key === \'spellcheck\' || key === \'draggable\') {\n          return false;\n      }\n      // #1787 form as an attribute must be a string, while it accepts an Element as\n      // a prop\n      if (key === \'form\' && typeof value === \'string\') {\n          return false;\n      }\n      // #1526 <input list> must be set as attribute\n      if (key === \'list\' && el.tagName === \'INPUT\') {\n          return false;\n      }\n      // native onclick with string value, must be set as attribute\n      if (nativeOnRE.test(key) && isString(value)) {\n          return false;\n      }\n      return key in el;\n  }\n\n  function useCssModule(name = \'$style\') {\n      /* istanbul ignore else */\n      {\n          {\n              warn(`useCssModule() is not supported in the global build.`);\n          }\n          return EMPTY_OBJ;\n      }\n  }\n\n  function useCssVars(getter, scoped = false) {\n      const instance = getCurrentInstance();\n      /* istanbul ignore next */\n      if (!instance) {\n          \n              warn(`useCssVars is called without current active component instance.`);\n          return;\n      }\n      const prefix = scoped && instance.type.__scopeId\n          ? `${instance.type.__scopeId.replace(/^data-v-/, \'\')}-`\n          : ``;\n      const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy), prefix);\n      onMounted(() => watchEffect(setVars));\n      onUpdated(setVars);\n  }\n  function setVarsOnVNode(vnode, vars, prefix) {\n      if ( vnode.shapeFlag & 128 /* SUSPENSE */) {\n          const suspense = vnode.suspense;\n          vnode = suspense.activeBranch;\n          if (suspense.pendingBranch && !suspense.isHydrating) {\n              suspense.effects.push(() => {\n                  setVarsOnVNode(suspense.activeBranch, vars, prefix);\n              });\n          }\n      }\n      // drill down HOCs until it\'s a non-component vnode\n      while (vnode.component) {\n          vnode = vnode.component.subTree;\n      }\n      if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {\n          const style = vnode.el.style;\n          for (const key in vars) {\n              style.setProperty(`--${prefix}${key}`, unref(vars[key]));\n          }\n      }\n      else if (vnode.type === Fragment) {\n          vnode.children.forEach(c => setVarsOnVNode(c, vars, prefix));\n      }\n  }\n\n  const TRANSITION = \'transition\';\n  const ANIMATION = \'animation\';\n  // DOM Transition is a higher-order-component based on the platform-agnostic\n  // base Transition component, with DOM-specific logic.\n  const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);\n  Transition.displayName = \'Transition\';\n  const DOMTransitionPropsValidators = {\n      name: String,\n      type: String,\n      css: {\n          type: Boolean,\n          default: true\n      },\n      duration: [String, Number, Object],\n      enterFromClass: String,\n      enterActiveClass: String,\n      enterToClass: String,\n      appearFromClass: String,\n      appearActiveClass: String,\n      appearToClass: String,\n      leaveFromClass: String,\n      leaveActiveClass: String,\n      leaveToClass: String\n  };\n  const TransitionPropsValidators = (Transition.props = /*#__PURE__*/ extend({}, BaseTransition.props, DOMTransitionPropsValidators));\n  function resolveTransitionProps(rawProps) {\n      let { name = \'v\', type, css = true, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;\n      const baseProps = {};\n      for (const key in rawProps) {\n          if (!(key in DOMTransitionPropsValidators)) {\n              baseProps[key] = rawProps[key];\n          }\n      }\n      if (!css) {\n          return baseProps;\n      }\n      const durations = normalizeDuration(duration);\n      const enterDuration = durations && durations[0];\n      const leaveDuration = durations && durations[1];\n      const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;\n      const finishEnter = (el, isAppear, done) => {\n          removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\n          removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\n          done && done();\n      };\n      const finishLeave = (el, done) => {\n          removeTransitionClass(el, leaveToClass);\n          removeTransitionClass(el, leaveActiveClass);\n          done && done();\n      };\n      const makeEnterHook = (isAppear) => {\n          return (el, done) => {\n              const hook = isAppear ? onAppear : onEnter;\n              const resolve = () => finishEnter(el, isAppear, done);\n              hook && hook(el, resolve);\n              nextFrame(() => {\n                  removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\n                  addTransitionClass(el, isAppear ? appearToClass : enterToClass);\n                  if (!(hook && hook.length > 1)) {\n                      if (enterDuration) {\n                          setTimeout(resolve, enterDuration);\n                      }\n                      else {\n                          whenTransitionEnds(el, type, resolve);\n                      }\n                  }\n              });\n          };\n      };\n      return extend(baseProps, {\n          onBeforeEnter(el) {\n              onBeforeEnter && onBeforeEnter(el);\n              addTransitionClass(el, enterActiveClass);\n              addTransitionClass(el, enterFromClass);\n          },\n          onBeforeAppear(el) {\n              onBeforeAppear && onBeforeAppear(el);\n              addTransitionClass(el, appearActiveClass);\n              addTransitionClass(el, appearFromClass);\n          },\n          onEnter: makeEnterHook(false),\n          onAppear: makeEnterHook(true),\n          onLeave(el, done) {\n              const resolve = () => finishLeave(el, done);\n              addTransitionClass(el, leaveActiveClass);\n              addTransitionClass(el, leaveFromClass);\n              nextFrame(() => {\n                  removeTransitionClass(el, leaveFromClass);\n                  addTransitionClass(el, leaveToClass);\n                  if (!(onLeave && onLeave.length > 1)) {\n                      if (leaveDuration) {\n                          setTimeout(resolve, leaveDuration);\n                      }\n                      else {\n                          whenTransitionEnds(el, type, resolve);\n                      }\n                  }\n              });\n              onLeave && onLeave(el, resolve);\n          },\n          onEnterCancelled(el) {\n              finishEnter(el, false);\n              onEnterCancelled && onEnterCancelled(el);\n          },\n          onAppearCancelled(el) {\n              finishEnter(el, true);\n              onAppearCancelled && onAppearCancelled(el);\n          },\n          onLeaveCancelled(el) {\n              finishLeave(el);\n              onLeaveCancelled && onLeaveCancelled(el);\n          }\n      });\n  }\n  function normalizeDuration(duration) {\n      if (duration == null) {\n          return null;\n      }\n      else if (isObject(duration)) {\n          return [NumberOf(duration.enter), NumberOf(duration.leave)];\n      }\n      else {\n          const n = NumberOf(duration);\n          return [n, n];\n      }\n  }\n  function NumberOf(val) {\n      const res = toNumber(val);\n      validateDuration(res);\n      return res;\n  }\n  function validateDuration(val) {\n      if (typeof val !== \'number\') {\n          warn(`<transition> explicit duration is not a valid number - ` +\n              `got ${JSON.stringify(val)}.`);\n      }\n      else if (isNaN(val)) {\n          warn(`<transition> explicit duration is NaN - ` +\n              \'the duration expression might be incorrect.\');\n      }\n  }\n  function addTransitionClass(el, cls) {\n      cls.split(/\\s+/).forEach(c => c && el.classList.add(c));\n      (el._vtc ||\n          (el._vtc = new Set())).add(cls);\n  }\n  function removeTransitionClass(el, cls) {\n      cls.split(/\\s+/).forEach(c => c && el.classList.remove(c));\n      const { _vtc } = el;\n      if (_vtc) {\n          _vtc.delete(cls);\n          if (!_vtc.size) {\n              el._vtc = undefined;\n          }\n      }\n  }\n  function nextFrame(cb) {\n      requestAnimationFrame(() => {\n          requestAnimationFrame(cb);\n      });\n  }\n  function whenTransitionEnds(el, expectedType, cb) {\n      const { type, timeout, propCount } = getTransitionInfo(el, expectedType);\n      if (!type) {\n          return cb();\n      }\n      const endEvent = type + \'end\';\n      let ended = 0;\n      const end = () => {\n          el.removeEventListener(endEvent, onEnd);\n          cb();\n      };\n      const onEnd = (e) => {\n          if (e.target === el) {\n              if (++ended >= propCount) {\n                  end();\n              }\n          }\n      };\n      setTimeout(() => {\n          if (ended < propCount) {\n              end();\n          }\n      }, timeout + 1);\n      el.addEventListener(endEvent, onEnd);\n  }\n  function getTransitionInfo(el, expectedType) {\n      const styles = window.getComputedStyle(el);\n      // JSDOM may return undefined for transition properties\n      const getStyleProperties = (key) => (styles[key] || \'\').split(\', \');\n      const transitionDelays = getStyleProperties(TRANSITION + \'Delay\');\n      const transitionDurations = getStyleProperties(TRANSITION + \'Duration\');\n      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n      const animationDelays = getStyleProperties(ANIMATION + \'Delay\');\n      const animationDurations = getStyleProperties(ANIMATION + \'Duration\');\n      const animationTimeout = getTimeout(animationDelays, animationDurations);\n      let type = null;\n      let timeout = 0;\n      let propCount = 0;\n      /* istanbul ignore if */\n      if (expectedType === TRANSITION) {\n          if (transitionTimeout > 0) {\n              type = TRANSITION;\n              timeout = transitionTimeout;\n              propCount = transitionDurations.length;\n          }\n      }\n      else if (expectedType === ANIMATION) {\n          if (animationTimeout > 0) {\n              type = ANIMATION;\n              timeout = animationTimeout;\n              propCount = animationDurations.length;\n          }\n      }\n      else {\n          timeout = Math.max(transitionTimeout, animationTimeout);\n          type =\n              timeout > 0\n                  ? transitionTimeout > animationTimeout\n                      ? TRANSITION\n                      : ANIMATION\n                  : null;\n          propCount = type\n              ? type === TRANSITION\n                  ? transitionDurations.length\n                  : animationDurations.length\n              : 0;\n      }\n      const hasTransform = type === TRANSITION &&\n          /\\b(transform|all)(,|$)/.test(styles[TRANSITION + \'Property\']);\n      return {\n          type,\n          timeout,\n          propCount,\n          hasTransform\n      };\n  }\n  function getTimeout(delays, durations) {\n      while (delays.length < durations.length) {\n          delays = delays.concat(delays);\n      }\n      return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\n  }\n  // Old versions of Chromium (below 61.0.3163.100) formats floating pointer\n  // numbers in a locale-dependent way, using a comma instead of a dot.\n  // If comma is not replaced with a dot, the input will be rounded down\n  // (i.e. acting as a floor function) causing unexpected behaviors\n  function toMs(s) {\n      return Number(s.slice(0, -1).replace(\',\', \'.\')) * 1000;\n  }\n\n  const positionMap = new WeakMap();\n  const newPositionMap = new WeakMap();\n  const TransitionGroupImpl = {\n      name: \'TransitionGroup\',\n      props: /*#__PURE__*/ extend({}, TransitionPropsValidators, {\n          tag: String,\n          moveClass: String\n      }),\n      setup(props, { slots }) {\n          const instance = getCurrentInstance();\n          const state = useTransitionState();\n          let prevChildren;\n          let children;\n          onUpdated(() => {\n              // children is guaranteed to exist after initial render\n              if (!prevChildren.length) {\n                  return;\n              }\n              const moveClass = props.moveClass || `${props.name || \'v\'}-move`;\n              if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {\n                  return;\n              }\n              // we divide the work into three loops to avoid mixing DOM reads and writes\n              // in each iteration - which helps prevent layout thrashing.\n              prevChildren.forEach(callPendingCbs);\n              prevChildren.forEach(recordPosition);\n              const movedChildren = prevChildren.filter(applyTranslation);\n              // force reflow to put everything in position\n              forceReflow();\n              movedChildren.forEach(c => {\n                  const el = c.el;\n                  const style = el.style;\n                  addTransitionClass(el, moveClass);\n                  style.transform = style.webkitTransform = style.transitionDuration = \'\';\n                  const cb = (el._moveCb = (e) => {\n                      if (e && e.target !== el) {\n                          return;\n                      }\n                      if (!e || /transform$/.test(e.propertyName)) {\n                          el.removeEventListener(\'transitionend\', cb);\n                          el._moveCb = null;\n                          removeTransitionClass(el, moveClass);\n                      }\n                  });\n                  el.addEventListener(\'transitionend\', cb);\n              });\n          });\n          return () => {\n              const rawProps = toRaw(props);\n              const cssTransitionProps = resolveTransitionProps(rawProps);\n              const tag = rawProps.tag || Fragment;\n              prevChildren = children;\n              children = slots.default ? getTransitionRawChildren(slots.default()) : [];\n              for (let i = 0; i < children.length; i++) {\n                  const child = children[i];\n                  if (child.key != null) {\n                      setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));\n                  }\n                  else {\n                      warn(`<TransitionGroup> children must be keyed.`);\n                  }\n              }\n              if (prevChildren) {\n                  for (let i = 0; i < prevChildren.length; i++) {\n                      const child = prevChildren[i];\n                      setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));\n                      positionMap.set(child, child.el.getBoundingClientRect());\n                  }\n              }\n              return createVNode(tag, null, children);\n          };\n      }\n  };\n  const TransitionGroup = TransitionGroupImpl;\n  function callPendingCbs(c) {\n      const el = c.el;\n      if (el._moveCb) {\n          el._moveCb();\n      }\n      if (el._enterCb) {\n          el._enterCb();\n      }\n  }\n  function recordPosition(c) {\n      newPositionMap.set(c, c.el.getBoundingClientRect());\n  }\n  function applyTranslation(c) {\n      const oldPos = positionMap.get(c);\n      const newPos = newPositionMap.get(c);\n      const dx = oldPos.left - newPos.left;\n      const dy = oldPos.top - newPos.top;\n      if (dx || dy) {\n          const s = c.el.style;\n          s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\n          s.transitionDuration = \'0s\';\n          return c;\n      }\n  }\n  // this is put in a dedicated function to avoid the line from being treeshaken\n  function forceReflow() {\n      return document.body.offsetHeight;\n  }\n  function hasCSSTransform(el, root, moveClass) {\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      const clone = el.cloneNode();\n      if (el._vtc) {\n          el._vtc.forEach(cls => {\n              cls.split(/\\s+/).forEach(c => c && clone.classList.remove(c));\n          });\n      }\n      moveClass.split(/\\s+/).forEach(c => c && clone.classList.add(c));\n      clone.style.display = \'none\';\n      const container = (root.nodeType === 1\n          ? root\n          : root.parentNode);\n      container.appendChild(clone);\n      const { hasTransform } = getTransitionInfo(clone);\n      container.removeChild(clone);\n      return hasTransform;\n  }\n\n  const getModelAssigner = (vnode) => {\n      const fn = vnode.props[\'onUpdate:modelValue\'];\n      return isArray(fn) ? value => invokeArrayFns(fn, value) : fn;\n  };\n  function onCompositionStart(e) {\n      e.target.composing = true;\n  }\n  function onCompositionEnd(e) {\n      const target = e.target;\n      if (target.composing) {\n          target.composing = false;\n          trigger$1(target, \'input\');\n      }\n  }\n  function trigger$1(el, type) {\n      const e = document.createEvent(\'HTMLEvents\');\n      e.initEvent(type, true, true);\n      el.dispatchEvent(e);\n  }\n  // We are exporting the v-model runtime directly as vnode hooks so that it can\n  // be tree-shaken in case v-model is never used.\n  const vModelText = {\n      created(el, { modifiers: { lazy, trim, number } }, vnode) {\n          el._assign = getModelAssigner(vnode);\n          const castToNumber = number || el.type === \'number\';\n          addEventListener(el, lazy ? \'change\' : \'input\', e => {\n              if (e.target.composing)\n                  return;\n              let domValue = el.value;\n              if (trim) {\n                  domValue = domValue.trim();\n              }\n              else if (castToNumber) {\n                  domValue = toNumber(domValue);\n              }\n              el._assign(domValue);\n          });\n          if (trim) {\n              addEventListener(el, \'change\', () => {\n                  el.value = el.value.trim();\n              });\n          }\n          if (!lazy) {\n              addEventListener(el, \'compositionstart\', onCompositionStart);\n              addEventListener(el, \'compositionend\', onCompositionEnd);\n              // Safari < 10.2 & UIWebView doesn\'t fire compositionend when\n              // switching focus before confirming composition choice\n              // this also fixes the issue where some browsers e.g. iOS Chrome\n              // fires "change" instead of "input" on autocomplete.\n              addEventListener(el, \'change\', onCompositionEnd);\n          }\n      },\n      // set value on mounted so it\'s after min/max for type="range"\n      mounted(el, { value }) {\n          el.value = value == null ? \'\' : value;\n      },\n      beforeUpdate(el, { value, modifiers: { trim, number } }, vnode) {\n          el._assign = getModelAssigner(vnode);\n          // avoid clearing unresolved text. #2302\n          if (el.composing)\n              return;\n          if (document.activeElement === el) {\n              if (trim && el.value.trim() === value) {\n                  return;\n              }\n              if ((number || el.type === \'number\') && toNumber(el.value) === value) {\n                  return;\n              }\n          }\n          const newValue = value == null ? \'\' : value;\n          if (el.value !== newValue) {\n              el.value = newValue;\n          }\n      }\n  };\n  const vModelCheckbox = {\n      created(el, binding, vnode) {\n          setChecked(el, binding, vnode);\n          el._assign = getModelAssigner(vnode);\n          addEventListener(el, \'change\', () => {\n              const modelValue = el._modelValue;\n              const elementValue = getValue(el);\n              const checked = el.checked;\n              const assign = el._assign;\n              if (isArray(modelValue)) {\n                  const index = looseIndexOf(modelValue, elementValue);\n                  const found = index !== -1;\n                  if (checked && !found) {\n                      assign(modelValue.concat(elementValue));\n                  }\n                  else if (!checked && found) {\n                      const filtered = [...modelValue];\n                      filtered.splice(index, 1);\n                      assign(filtered);\n                  }\n              }\n              else if (isSet(modelValue)) {\n                  if (checked) {\n                      modelValue.add(elementValue);\n                  }\n                  else {\n                      modelValue.delete(elementValue);\n                  }\n              }\n              else {\n                  assign(getCheckboxValue(el, checked));\n              }\n          });\n      },\n      beforeUpdate(el, binding, vnode) {\n          el._assign = getModelAssigner(vnode);\n          setChecked(el, binding, vnode);\n      }\n  };\n  function setChecked(el, { value, oldValue }, vnode) {\n      el._modelValue = value;\n      if (isArray(value)) {\n          el.checked = looseIndexOf(value, vnode.props.value) > -1;\n      }\n      else if (isSet(value)) {\n          el.checked = value.has(vnode.props.value);\n      }\n      else if (value !== oldValue) {\n          el.checked = looseEqual(value, getCheckboxValue(el, true));\n      }\n  }\n  const vModelRadio = {\n      created(el, { value }, vnode) {\n          el.checked = looseEqual(value, vnode.props.value);\n          el._assign = getModelAssigner(vnode);\n          addEventListener(el, \'change\', () => {\n              el._assign(getValue(el));\n          });\n      },\n      beforeUpdate(el, { value, oldValue }, vnode) {\n          el._assign = getModelAssigner(vnode);\n          if (value !== oldValue) {\n              el.checked = looseEqual(value, vnode.props.value);\n          }\n      }\n  };\n  const vModelSelect = {\n      created(el, { modifiers: { number } }, vnode) {\n          addEventListener(el, \'change\', () => {\n              const selectedVal = Array.prototype.filter\n                  .call(el.options, (o) => o.selected)\n                  .map((o) => number ? toNumber(getValue(o)) : getValue(o));\n              el._assign(el.multiple ? selectedVal : selectedVal[0]);\n          });\n          el._assign = getModelAssigner(vnode);\n      },\n      // set value in mounted & updated because <select> relies on its children\n      // <option>s.\n      mounted(el, { value }) {\n          setSelected(el, value);\n      },\n      beforeUpdate(el, _binding, vnode) {\n          el._assign = getModelAssigner(vnode);\n      },\n      updated(el, { value }) {\n          setSelected(el, value);\n      }\n  };\n  function setSelected(el, value) {\n      const isMultiple = el.multiple;\n      if (isMultiple && !isArray(value) && !isSet(value)) {\n          \n              warn(`<select multiple v-model> expects an Array or Set value for its binding, ` +\n                  `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);\n          return;\n      }\n      for (let i = 0, l = el.options.length; i < l; i++) {\n          const option = el.options[i];\n          const optionValue = getValue(option);\n          if (isMultiple) {\n              if (isArray(value)) {\n                  option.selected = looseIndexOf(value, optionValue) > -1;\n              }\n              else {\n                  option.selected = value.has(optionValue);\n              }\n          }\n          else {\n              if (looseEqual(getValue(option), value)) {\n                  el.selectedIndex = i;\n                  return;\n              }\n          }\n      }\n      if (!isMultiple) {\n          el.selectedIndex = -1;\n      }\n  }\n  // retrieve raw value set via :value bindings\n  function getValue(el) {\n      return \'_value\' in el ? el._value : el.value;\n  }\n  // retrieve raw value for true-value and false-value set via :true-value or :false-value bindings\n  function getCheckboxValue(el, checked) {\n      const key = checked ? \'_trueValue\' : \'_falseValue\';\n      return key in el ? el[key] : checked;\n  }\n  const vModelDynamic = {\n      created(el, binding, vnode) {\n          callModelHook(el, binding, vnode, null, \'created\');\n      },\n      mounted(el, binding, vnode) {\n          callModelHook(el, binding, vnode, null, \'mounted\');\n      },\n      beforeUpdate(el, binding, vnode, prevVNode) {\n          callModelHook(el, binding, vnode, prevVNode, \'beforeUpdate\');\n      },\n      updated(el, binding, vnode, prevVNode) {\n          callModelHook(el, binding, vnode, prevVNode, \'updated\');\n      }\n  };\n  function callModelHook(el, binding, vnode, prevVNode, hook) {\n      let modelToUse;\n      switch (el.tagName) {\n          case \'SELECT\':\n              modelToUse = vModelSelect;\n              break;\n          case \'TEXTAREA\':\n              modelToUse = vModelText;\n              break;\n          default:\n              switch (vnode.props && vnode.props.type) {\n                  case \'checkbox\':\n                      modelToUse = vModelCheckbox;\n                      break;\n                  case \'radio\':\n                      modelToUse = vModelRadio;\n                      break;\n                  default:\n                      modelToUse = vModelText;\n              }\n      }\n      const fn = modelToUse[hook];\n      fn && fn(el, binding, vnode, prevVNode);\n  }\n\n  const systemModifiers = [\'ctrl\', \'shift\', \'alt\', \'meta\'];\n  const modifierGuards = {\n      stop: e => e.stopPropagation(),\n      prevent: e => e.preventDefault(),\n      self: e => e.target !== e.currentTarget,\n      ctrl: e => !e.ctrlKey,\n      shift: e => !e.shiftKey,\n      alt: e => !e.altKey,\n      meta: e => !e.metaKey,\n      left: e => \'button\' in e && e.button !== 0,\n      middle: e => \'button\' in e && e.button !== 1,\n      right: e => \'button\' in e && e.button !== 2,\n      exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))\n  };\n  /**\n   * @private\n   */\n  const withModifiers = (fn, modifiers) => {\n      return (event, ...args) => {\n          for (let i = 0; i < modifiers.length; i++) {\n              const guard = modifierGuards[modifiers[i]];\n              if (guard && guard(event, modifiers))\n                  return;\n          }\n          return fn(event, ...args);\n      };\n  };\n  // Kept for 2.x compat.\n  // Note: IE11 compat for `spacebar` and `del` is removed for now.\n  const keyNames = {\n      esc: \'escape\',\n      space: \' \',\n      up: \'arrow-up\',\n      left: \'arrow-left\',\n      right: \'arrow-right\',\n      down: \'arrow-down\',\n      delete: \'backspace\'\n  };\n  /**\n   * @private\n   */\n  const withKeys = (fn, modifiers) => {\n      return (event) => {\n          if (!(\'key\' in event))\n              return;\n          const eventKey = hyphenate(event.key);\n          if (\n          // None of the provided key modifiers match the current event key\n          !modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {\n              return;\n          }\n          return fn(event);\n      };\n  };\n\n  const vShow = {\n      beforeMount(el, { value }, { transition }) {\n          el._vod = el.style.display === \'none\' ? \'\' : el.style.display;\n          if (transition && value) {\n              transition.beforeEnter(el);\n          }\n          else {\n              setDisplay(el, value);\n          }\n      },\n      mounted(el, { value }, { transition }) {\n          if (transition && value) {\n              transition.enter(el);\n          }\n      },\n      updated(el, { value, oldValue }, { transition }) {\n          if (!value === !oldValue)\n              return;\n          if (transition) {\n              if (value) {\n                  transition.beforeEnter(el);\n                  setDisplay(el, true);\n                  transition.enter(el);\n              }\n              else {\n                  transition.leave(el, () => {\n                      setDisplay(el, false);\n                  });\n              }\n          }\n          else {\n              setDisplay(el, value);\n          }\n      },\n      beforeUnmount(el, { value }) {\n          setDisplay(el, value);\n      }\n  };\n  function setDisplay(el, value) {\n      el.style.display = value ? el._vod : \'none\';\n  }\n\n  const rendererOptions = extend({ patchProp, forcePatchProp }, nodeOps);\n  // lazy create the renderer - this makes core renderer logic tree-shakable\n  // in case the user only imports reactivity utilities from Vue.\n  let renderer;\n  let enabledHydration = false;\n  function ensureRenderer() {\n      return renderer || (renderer = createRenderer(rendererOptions));\n  }\n  function ensureHydrationRenderer() {\n      renderer = enabledHydration\n          ? renderer\n          : createHydrationRenderer(rendererOptions);\n      enabledHydration = true;\n      return renderer;\n  }\n  // use explicit type casts here to avoid import() calls in rolled-up d.ts\n  const render = ((...args) => {\n      ensureRenderer().render(...args);\n  });\n  const hydrate = ((...args) => {\n      ensureHydrationRenderer().hydrate(...args);\n  });\n  const createApp = ((...args) => {\n      const app = ensureRenderer().createApp(...args);\n      {\n          injectNativeTagCheck(app);\n      }\n      const { mount } = app;\n      app.mount = (containerOrSelector) => {\n          const container = normalizeContainer(containerOrSelector);\n          if (!container)\n              return;\n          const component = app._component;\n          if (!isFunction(component) && !component.render && !component.template) {\n              component.template = container.innerHTML;\n          }\n          // clear content before mounting\n          container.innerHTML = \'\';\n          const proxy = mount(container);\n          container.removeAttribute(\'v-cloak\');\n          container.setAttribute(\'data-v-app\', \'\');\n          return proxy;\n      };\n      return app;\n  });\n  const createSSRApp = ((...args) => {\n      const app = ensureHydrationRenderer().createApp(...args);\n      {\n          injectNativeTagCheck(app);\n      }\n      const { mount } = app;\n      app.mount = (containerOrSelector) => {\n          const container = normalizeContainer(containerOrSelector);\n          if (container) {\n              return mount(container, true);\n          }\n      };\n      return app;\n  });\n  function injectNativeTagCheck(app) {\n      // Inject `isNativeTag`\n      // this is used for component name validation (dev only)\n      Object.defineProperty(app.config, \'isNativeTag\', {\n          value: (tag) => isHTMLTag(tag) || isSVGTag(tag),\n          writable: false\n      });\n  }\n  function normalizeContainer(container) {\n      if (isString(container)) {\n          const res = document.querySelector(container);\n          if ( !res) {\n              warn(`Failed to mount app: mount target selector returned null.`);\n          }\n          return res;\n      }\n      return container;\n  }\n\n  function initDev() {\n      const target = getGlobalThis();\n      target.__VUE__ = true;\n      setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__);\n      {\n          console.info(`You are running a development build of Vue.\\n` +\n              `Make sure to use the production build (*.prod.js) when deploying for production.`);\n          initCustomFormatter();\n      }\n  }\n\n  function defaultOnError(error) {\n      throw error;\n  }\n  function createCompilerError(code, loc, messages, additionalMessage) {\n      const msg =  (messages || errorMessages)[code] + (additionalMessage || ``)\n          ;\n      const error = new SyntaxError(String(msg));\n      error.code = code;\n      error.loc = loc;\n      return error;\n  }\n  const errorMessages = {\n      // parse errors\n      [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: \'Illegal comment.\',\n      [1 /* CDATA_IN_HTML_CONTENT */]: \'CDATA section is allowed only in XML context.\',\n      [2 /* DUPLICATE_ATTRIBUTE */]: \'Duplicate attribute.\',\n      [3 /* END_TAG_WITH_ATTRIBUTES */]: \'End tag cannot have attributes.\',\n      [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal \'/\' in tags.",\n      [5 /* EOF_BEFORE_TAG_NAME */]: \'Unexpected EOF in tag.\',\n      [6 /* EOF_IN_CDATA */]: \'Unexpected EOF in CDATA section.\',\n      [7 /* EOF_IN_COMMENT */]: \'Unexpected EOF in comment.\',\n      [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: \'Unexpected EOF in script.\',\n      [9 /* EOF_IN_TAG */]: \'Unexpected EOF in tag.\',\n      [10 /* INCORRECTLY_CLOSED_COMMENT */]: \'Incorrectly closed comment.\',\n      [11 /* INCORRECTLY_OPENED_COMMENT */]: \'Incorrectly opened comment.\',\n      [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use \'&lt;\' to print \'<\'.",\n      [13 /* MISSING_ATTRIBUTE_VALUE */]: \'Attribute value was expected.\',\n      [14 /* MISSING_END_TAG_NAME */]: \'End tag name was expected.\',\n      [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: \'Whitespace was expected.\',\n      [16 /* NESTED_COMMENT */]: "Unexpected \'<\!--\' in comment.",\n      [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: \'Attribute name cannot contain U+0022 ("), U+0027 (\\\'), and U+003C (<).\',\n      [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: \'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\\\'), U+003C (<), U+003D (=), and U+0060 (`).\',\n      [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with \'=\'.",\n      [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "\'<?\' is allowed only in XML context.",\n      [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal \'/\' in tags.",\n      // Vue-specific parse errors\n      [23 /* X_INVALID_END_TAG */]: \'Invalid end tag.\',\n      [24 /* X_MISSING_END_TAG */]: \'Element is missing end tag.\',\n      [25 /* X_MISSING_INTERPOLATION_END */]: \'Interpolation end sign was not found.\',\n      [26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: \'End bracket for dynamic directive argument was not found. \' +\n          \'Note that dynamic directive argument cannot contain spaces.\',\n      // transform errors\n      [27 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,\n      [28 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,\n      [29 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if.`,\n      [30 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,\n      [31 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,\n      [32 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,\n      [33 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,\n      [34 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,\n      [35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,\n      [36 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +\n          `When there are multiple named slots, all slots should use <template> ` +\n          `syntax to avoid scope ambiguity.`,\n      [37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,\n      [38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +\n          `default slot. These children will be ignored.`,\n      [39 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,\n      [40 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,\n      [41 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,\n      [42 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\n      [43 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,\n      [44 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,\n      // generic errors\n      [45 /* X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,\n      [46 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,\n      [47 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,\n      [48 /* X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`\n  };\n\n  const FRAGMENT = Symbol( `Fragment` );\n  const TELEPORT = Symbol( `Teleport` );\n  const SUSPENSE = Symbol( `Suspense` );\n  const KEEP_ALIVE = Symbol( `KeepAlive` );\n  const BASE_TRANSITION = Symbol( `BaseTransition` );\n  const OPEN_BLOCK = Symbol( `openBlock` );\n  const CREATE_BLOCK = Symbol( `createBlock` );\n  const CREATE_VNODE = Symbol( `createVNode` );\n  const CREATE_COMMENT = Symbol( `createCommentVNode` );\n  const CREATE_TEXT = Symbol( `createTextVNode` );\n  const CREATE_STATIC = Symbol( `createStaticVNode` );\n  const RESOLVE_COMPONENT = Symbol( `resolveComponent` );\n  const RESOLVE_DYNAMIC_COMPONENT = Symbol( `resolveDynamicComponent` );\n  const RESOLVE_DIRECTIVE = Symbol( `resolveDirective` );\n  const WITH_DIRECTIVES = Symbol( `withDirectives` );\n  const RENDER_LIST = Symbol( `renderList` );\n  const RENDER_SLOT = Symbol( `renderSlot` );\n  const CREATE_SLOTS = Symbol( `createSlots` );\n  const TO_DISPLAY_STRING = Symbol( `toDisplayString` );\n  const MERGE_PROPS = Symbol( `mergeProps` );\n  const TO_HANDLERS = Symbol( `toHandlers` );\n  const CAMELIZE = Symbol( `camelize` );\n  const CAPITALIZE = Symbol( `capitalize` );\n  const TO_HANDLER_KEY = Symbol( `toHandlerKey` );\n  const SET_BLOCK_TRACKING = Symbol( `setBlockTracking` );\n  const PUSH_SCOPE_ID = Symbol( `pushScopeId` );\n  const POP_SCOPE_ID = Symbol( `popScopeId` );\n  const WITH_SCOPE_ID = Symbol( `withScopeId` );\n  const WITH_CTX = Symbol( `withCtx` );\n  // Name mapping for runtime helpers that need to be imported from \'vue\' in\n  // generated code. Make sure these are correctly exported in the runtime!\n  // Using `any` here because TS doesn\'t allow symbols as index type.\n  const helperNameMap = {\n      [FRAGMENT]: `Fragment`,\n      [TELEPORT]: `Teleport`,\n      [SUSPENSE]: `Suspense`,\n      [KEEP_ALIVE]: `KeepAlive`,\n      [BASE_TRANSITION]: `BaseTransition`,\n      [OPEN_BLOCK]: `openBlock`,\n      [CREATE_BLOCK]: `createBlock`,\n      [CREATE_VNODE]: `createVNode`,\n      [CREATE_COMMENT]: `createCommentVNode`,\n      [CREATE_TEXT]: `createTextVNode`,\n      [CREATE_STATIC]: `createStaticVNode`,\n      [RESOLVE_COMPONENT]: `resolveComponent`,\n      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\n      [RESOLVE_DIRECTIVE]: `resolveDirective`,\n      [WITH_DIRECTIVES]: `withDirectives`,\n      [RENDER_LIST]: `renderList`,\n      [RENDER_SLOT]: `renderSlot`,\n      [CREATE_SLOTS]: `createSlots`,\n      [TO_DISPLAY_STRING]: `toDisplayString`,\n      [MERGE_PROPS]: `mergeProps`,\n      [TO_HANDLERS]: `toHandlers`,\n      [CAMELIZE]: `camelize`,\n      [CAPITALIZE]: `capitalize`,\n      [TO_HANDLER_KEY]: `toHandlerKey`,\n      [SET_BLOCK_TRACKING]: `setBlockTracking`,\n      [PUSH_SCOPE_ID]: `pushScopeId`,\n      [POP_SCOPE_ID]: `popScopeId`,\n      [WITH_SCOPE_ID]: `withScopeId`,\n      [WITH_CTX]: `withCtx`\n  };\n  function registerRuntimeHelpers(helpers) {\n      Object.getOwnPropertySymbols(helpers).forEach(s => {\n          helperNameMap[s] = helpers[s];\n      });\n  }\n\n  // AST Utilities ---------------------------------------------------------------\n  // Some expressions, e.g. sequence and conditional expressions, are never\n  // associated with template nodes, so their source locations are just a stub.\n  // Container types like CompoundExpression also don\'t need a real location.\n  const locStub = {\n      source: \'\',\n      start: { line: 1, column: 1, offset: 0 },\n      end: { line: 1, column: 1, offset: 0 }\n  };\n  function createRoot(children, loc = locStub) {\n      return {\n          type: 0 /* ROOT */,\n          children,\n          helpers: [],\n          components: [],\n          directives: [],\n          hoists: [],\n          imports: [],\n          cached: 0,\n          temps: 0,\n          codegenNode: undefined,\n          loc\n      };\n  }\n  function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, loc = locStub) {\n      if (context) {\n          if (isBlock) {\n              context.helper(OPEN_BLOCK);\n              context.helper(CREATE_BLOCK);\n          }\n          else {\n              context.helper(CREATE_VNODE);\n          }\n          if (directives) {\n              context.helper(WITH_DIRECTIVES);\n          }\n      }\n      return {\n          type: 13 /* VNODE_CALL */,\n          tag,\n          props,\n          children,\n          patchFlag,\n          dynamicProps,\n          directives,\n          isBlock,\n          disableTracking,\n          loc\n      };\n  }\n  function createArrayExpression(elements, loc = locStub) {\n      return {\n          type: 17 /* JS_ARRAY_EXPRESSION */,\n          loc,\n          elements\n      };\n  }\n  function createObjectExpression(properties, loc = locStub) {\n      return {\n          type: 15 /* JS_OBJECT_EXPRESSION */,\n          loc,\n          properties\n      };\n  }\n  function createObjectProperty(key, value) {\n      return {\n          type: 16 /* JS_PROPERTY */,\n          loc: locStub,\n          key: isString(key) ? createSimpleExpression(key, true) : key,\n          value\n      };\n  }\n  function createSimpleExpression(content, isStatic, loc = locStub, isConstant = false) {\n      return {\n          type: 4 /* SIMPLE_EXPRESSION */,\n          loc,\n          isConstant,\n          content,\n          isStatic\n      };\n  }\n  function createCompoundExpression(children, loc = locStub) {\n      return {\n          type: 8 /* COMPOUND_EXPRESSION */,\n          loc,\n          children\n      };\n  }\n  function createCallExpression(callee, args = [], loc = locStub) {\n      return {\n          type: 14 /* JS_CALL_EXPRESSION */,\n          loc,\n          callee,\n          arguments: args\n      };\n  }\n  function createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {\n      return {\n          type: 18 /* JS_FUNCTION_EXPRESSION */,\n          params,\n          returns,\n          newline,\n          isSlot,\n          loc\n      };\n  }\n  function createConditionalExpression(test, consequent, alternate, newline = true) {\n      return {\n          type: 19 /* JS_CONDITIONAL_EXPRESSION */,\n          test,\n          consequent,\n          alternate,\n          newline,\n          loc: locStub\n      };\n  }\n  function createCacheExpression(index, value, isVNode = false) {\n      return {\n          type: 20 /* JS_CACHE_EXPRESSION */,\n          index,\n          value,\n          isVNode,\n          loc: locStub\n      };\n  }\n\n  const isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;\n  const isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);\n  function isCoreComponent(tag) {\n      if (isBuiltInType(tag, \'Teleport\')) {\n          return TELEPORT;\n      }\n      else if (isBuiltInType(tag, \'Suspense\')) {\n          return SUSPENSE;\n      }\n      else if (isBuiltInType(tag, \'KeepAlive\')) {\n          return KEEP_ALIVE;\n      }\n      else if (isBuiltInType(tag, \'BaseTransition\')) {\n          return BASE_TRANSITION;\n      }\n  }\n  const nonIdentifierRE = /^\\d|[^\\$\\w]/;\n  const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);\n  const memberExpRE = /^[A-Za-z_$][\\w$]*(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*|\\[[^\\]]+\\])*$/;\n  const isMemberExpression = (path) => {\n      if (!path)\n          return false;\n      return memberExpRE.test(path.trim());\n  };\n  function getInnerRange(loc, offset, length) {\n      const source = loc.source.substr(offset, length);\n      const newLoc = {\n          source,\n          start: advancePositionWithClone(loc.start, loc.source, offset),\n          end: loc.end\n      };\n      if (length != null) {\n          newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);\n      }\n      return newLoc;\n  }\n  function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {\n      return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);\n  }\n  // advance by mutation without cloning (for performance reasons), since this\n  // gets called a lot in the parser\n  function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {\n      let linesCount = 0;\n      let lastNewLinePos = -1;\n      for (let i = 0; i < numberOfCharacters; i++) {\n          if (source.charCodeAt(i) === 10 /* newline char code */) {\n              linesCount++;\n              lastNewLinePos = i;\n          }\n      }\n      pos.offset += numberOfCharacters;\n      pos.line += linesCount;\n      pos.column =\n          lastNewLinePos === -1\n              ? pos.column + numberOfCharacters\n              : numberOfCharacters - lastNewLinePos;\n      return pos;\n  }\n  function assert(condition, msg) {\n      /* istanbul ignore if */\n      if (!condition) {\n          throw new Error(msg || `unexpected compiler condition`);\n      }\n  }\n  function findDir(node, name, allowEmpty = false) {\n      for (let i = 0; i < node.props.length; i++) {\n          const p = node.props[i];\n          if (p.type === 7 /* DIRECTIVE */ &&\n              (allowEmpty || p.exp) &&\n              (isString(name) ? p.name === name : name.test(p.name))) {\n              return p;\n          }\n      }\n  }\n  function findProp(node, name, dynamicOnly = false, allowEmpty = false) {\n      for (let i = 0; i < node.props.length; i++) {\n          const p = node.props[i];\n          if (p.type === 6 /* ATTRIBUTE */) {\n              if (dynamicOnly)\n                  continue;\n              if (p.name === name && (p.value || allowEmpty)) {\n                  return p;\n              }\n          }\n          else if (p.name === \'bind\' &&\n              (p.exp || allowEmpty) &&\n              isBindKey(p.arg, name)) {\n              return p;\n          }\n      }\n  }\n  function isBindKey(arg, name) {\n      return !!(arg && isStaticExp(arg) && arg.content === name);\n  }\n  function hasDynamicKeyVBind(node) {\n      return node.props.some(p => p.type === 7 /* DIRECTIVE */ &&\n          p.name === \'bind\' &&\n          (!p.arg || // v-bind="obj"\n              p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]\n              !p.arg.isStatic) // v-bind:[foo]\n      );\n  }\n  function isText(node) {\n      return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;\n  }\n  function isVSlot(p) {\n      return p.type === 7 /* DIRECTIVE */ && p.name === \'slot\';\n  }\n  function isTemplateNode(node) {\n      return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);\n  }\n  function isSlotOutlet(node) {\n      return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;\n  }\n  function injectProp(node, prop, context) {\n      let propsWithInjection;\n      const props = node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];\n      if (props == null || isString(props)) {\n          propsWithInjection = createObjectExpression([prop]);\n      }\n      else if (props.type === 14 /* JS_CALL_EXPRESSION */) {\n          // merged props... add ours\n          // only inject key to object literal if it\'s the first argument so that\n          // if doesn\'t override user provided keys\n          const first = props.arguments[0];\n          if (!isString(first) && first.type === 15 /* JS_OBJECT_EXPRESSION */) {\n              first.properties.unshift(prop);\n          }\n          else {\n              if (props.callee === TO_HANDLERS) {\n                  // #2366\n                  propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\n                      createObjectExpression([prop]),\n                      props\n                  ]);\n              }\n              else {\n                  props.arguments.unshift(createObjectExpression([prop]));\n              }\n          }\n          !propsWithInjection && (propsWithInjection = props);\n      }\n      else if (props.type === 15 /* JS_OBJECT_EXPRESSION */) {\n          let alreadyExists = false;\n          // check existing key to avoid overriding user provided keys\n          if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {\n              const propKeyName = prop.key.content;\n              alreadyExists = props.properties.some(p => p.key.type === 4 /* SIMPLE_EXPRESSION */ &&\n                  p.key.content === propKeyName);\n          }\n          if (!alreadyExists) {\n              props.properties.unshift(prop);\n          }\n          propsWithInjection = props;\n      }\n      else {\n          // single v-bind with expression, return a merged replacement\n          propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\n              createObjectExpression([prop]),\n              props\n          ]);\n      }\n      if (node.type === 13 /* VNODE_CALL */) {\n          node.props = propsWithInjection;\n      }\n      else {\n          node.arguments[2] = propsWithInjection;\n      }\n  }\n  function toValidAssetId(name, type) {\n      return `_${type}_${name.replace(/[^\\w]/g, \'_\')}`;\n  }\n\n  // The default decoder only provides escapes for characters reserved as part of\n  // the template syntax, and is only used if the custom renderer did not provide\n  // a platform-specific decoder.\n  const decodeRE = /&(gt|lt|amp|apos|quot);/g;\n  const decodeMap = {\n      gt: \'>\',\n      lt: \'<\',\n      amp: \'&\',\n      apos: "\'",\n      quot: \'"\'\n  };\n  const defaultParserOptions = {\n      delimiters: [`{{`, `}}`],\n      getNamespace: () => 0 /* HTML */,\n      getTextMode: () => 0 /* DATA */,\n      isVoidTag: NO,\n      isPreTag: NO,\n      isCustomElement: NO,\n      decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),\n      onError: defaultOnError,\n      comments: false\n  };\n  function baseParse(content, options = {}) {\n      const context = createParserContext(content, options);\n      const start = getCursor(context);\n      return createRoot(parseChildren(context, 0 /* DATA */, []), getSelection(context, start));\n  }\n  function createParserContext(content, rawOptions) {\n      const options = extend({}, defaultParserOptions);\n      for (const key in rawOptions) {\n          // @ts-ignore\n          options[key] = rawOptions[key] || defaultParserOptions[key];\n      }\n      return {\n          options,\n          column: 1,\n          line: 1,\n          offset: 0,\n          originalSource: content,\n          source: content,\n          inPre: false,\n          inVPre: false\n      };\n  }\n  function parseChildren(context, mode, ancestors) {\n      const parent = last(ancestors);\n      const ns = parent ? parent.ns : 0 /* HTML */;\n      const nodes = [];\n      while (!isEnd(context, mode, ancestors)) {\n          const s = context.source;\n          let node = undefined;\n          if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {\n              if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {\n                  // \'{{\'\n                  node = parseInterpolation(context, mode);\n              }\n              else if (mode === 0 /* DATA */ && s[0] === \'<\') {\n                  // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\n                  if (s.length === 1) {\n                      emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);\n                  }\n                  else if (s[1] === \'!\') {\n                      // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\n                      if (startsWith(s, \'<\!--\')) {\n                          node = parseComment(context);\n                      }\n                      else if (startsWith(s, \'<!DOCTYPE\')) {\n                          // Ignore DOCTYPE by a limitation.\n                          node = parseBogusComment(context);\n                      }\n                      else if (startsWith(s, \'<![CDATA[\')) {\n                          if (ns !== 0 /* HTML */) {\n                              node = parseCDATA(context, ancestors);\n                          }\n                          else {\n                              emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);\n                              node = parseBogusComment(context);\n                          }\n                      }\n                      else {\n                          emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);\n                          node = parseBogusComment(context);\n                      }\n                  }\n                  else if (s[1] === \'/\') {\n                      // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\n                      if (s.length === 2) {\n                          emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);\n                      }\n                      else if (s[2] === \'>\') {\n                          emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);\n                          advanceBy(context, 3);\n                          continue;\n                      }\n                      else if (/[a-z]/i.test(s[2])) {\n                          emitError(context, 23 /* X_INVALID_END_TAG */);\n                          parseTag(context, 1 /* End */, parent);\n                          continue;\n                      }\n                      else {\n                          emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);\n                          node = parseBogusComment(context);\n                      }\n                  }\n                  else if (/[a-z]/i.test(s[1])) {\n                      node = parseElement(context, ancestors);\n                  }\n                  else if (s[1] === \'?\') {\n                      emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);\n                      node = parseBogusComment(context);\n                  }\n                  else {\n                      emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);\n                  }\n              }\n          }\n          if (!node) {\n              node = parseText(context, mode);\n          }\n          if (isArray(node)) {\n              for (let i = 0; i < node.length; i++) {\n                  pushNode(nodes, node[i]);\n              }\n          }\n          else {\n              pushNode(nodes, node);\n          }\n      }\n      // Whitespace management for more efficient output\n      // (same as v2 whitespace: \'condense\')\n      let removedWhitespace = false;\n      if (mode !== 2 /* RAWTEXT */) {\n          for (let i = 0; i < nodes.length; i++) {\n              const node = nodes[i];\n              if (!context.inPre && node.type === 2 /* TEXT */) {\n                  if (!/[^\\t\\r\\n\\f ]/.test(node.content)) {\n                      const prev = nodes[i - 1];\n                      const next = nodes[i + 1];\n                      // If:\n                      // - the whitespace is the first or last node, or:\n                      // - the whitespace is adjacent to a comment, or:\n                      // - the whitespace is between two elements AND contains newline\n                      // Then the whitespace is ignored.\n                      if (!prev ||\n                          !next ||\n                          prev.type === 3 /* COMMENT */ ||\n                          next.type === 3 /* COMMENT */ ||\n                          (prev.type === 1 /* ELEMENT */ &&\n                              next.type === 1 /* ELEMENT */ &&\n                              /[\\r\\n]/.test(node.content))) {\n                          removedWhitespace = true;\n                          nodes[i] = null;\n                      }\n                      else {\n                          // Otherwise, condensed consecutive whitespace inside the text\n                          // down to a single space\n                          node.content = \' \';\n                      }\n                  }\n                  else {\n                      node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, \' \');\n                  }\n              }\n          }\n          if (context.inPre && parent && context.options.isPreTag(parent.tag)) {\n              // remove leading newline per html spec\n              // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element\n              const first = nodes[0];\n              if (first && first.type === 2 /* TEXT */) {\n                  first.content = first.content.replace(/^\\r?\\n/, \'\');\n              }\n          }\n      }\n      return removedWhitespace ? nodes.filter(Boolean) : nodes;\n  }\n  function pushNode(nodes, node) {\n      if (node.type === 2 /* TEXT */) {\n          const prev = last(nodes);\n          // Merge if both this and the previous node are text and those are\n          // consecutive. This happens for cases like "a < b".\n          if (prev &&\n              prev.type === 2 /* TEXT */ &&\n              prev.loc.end.offset === node.loc.start.offset) {\n              prev.content += node.content;\n              prev.loc.end = node.loc.end;\n              prev.loc.source += node.loc.source;\n              return;\n          }\n      }\n      nodes.push(node);\n  }\n  function parseCDATA(context, ancestors) {\n      advanceBy(context, 9);\n      const nodes = parseChildren(context, 3 /* CDATA */, ancestors);\n      if (context.source.length === 0) {\n          emitError(context, 6 /* EOF_IN_CDATA */);\n      }\n      else {\n          advanceBy(context, 3);\n      }\n      return nodes;\n  }\n  function parseComment(context) {\n      const start = getCursor(context);\n      let content;\n      // Regular comment.\n      const match = /--(\\!)?>/.exec(context.source);\n      if (!match) {\n          content = context.source.slice(4);\n          advanceBy(context, context.source.length);\n          emitError(context, 7 /* EOF_IN_COMMENT */);\n      }\n      else {\n          if (match.index <= 3) {\n              emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);\n          }\n          if (match[1]) {\n              emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);\n          }\n          content = context.source.slice(4, match.index);\n          // Advancing with reporting nested comments.\n          const s = context.source.slice(0, match.index);\n          let prevIndex = 1, nestedIndex = 0;\n          while ((nestedIndex = s.indexOf(\'<\!--\', prevIndex)) !== -1) {\n              advanceBy(context, nestedIndex - prevIndex + 1);\n              if (nestedIndex + 4 < s.length) {\n                  emitError(context, 16 /* NESTED_COMMENT */);\n              }\n              prevIndex = nestedIndex + 1;\n          }\n          advanceBy(context, match.index + match[0].length - prevIndex + 1);\n      }\n      return {\n          type: 3 /* COMMENT */,\n          content,\n          loc: getSelection(context, start)\n      };\n  }\n  function parseBogusComment(context) {\n      const start = getCursor(context);\n      const contentStart = context.source[1] === \'?\' ? 1 : 2;\n      let content;\n      const closeIndex = context.source.indexOf(\'>\');\n      if (closeIndex === -1) {\n          content = context.source.slice(contentStart);\n          advanceBy(context, context.source.length);\n      }\n      else {\n          content = context.source.slice(contentStart, closeIndex);\n          advanceBy(context, closeIndex + 1);\n      }\n      return {\n          type: 3 /* COMMENT */,\n          content,\n          loc: getSelection(context, start)\n      };\n  }\n  function parseElement(context, ancestors) {\n      // Start tag.\n      const wasInPre = context.inPre;\n      const wasInVPre = context.inVPre;\n      const parent = last(ancestors);\n      const element = parseTag(context, 0 /* Start */, parent);\n      const isPreBoundary = context.inPre && !wasInPre;\n      const isVPreBoundary = context.inVPre && !wasInVPre;\n      if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\n          return element;\n      }\n      // Children.\n      ancestors.push(element);\n      const mode = context.options.getTextMode(element, parent);\n      const children = parseChildren(context, mode, ancestors);\n      ancestors.pop();\n      element.children = children;\n      // End tag.\n      if (startsWithEndTagOpen(context.source, element.tag)) {\n          parseTag(context, 1 /* End */, parent);\n      }\n      else {\n          emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);\n          if (context.source.length === 0 && element.tag.toLowerCase() === \'script\') {\n              const first = children[0];\n              if (first && startsWith(first.loc.source, \'<\!--\')) {\n                  emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);\n              }\n          }\n      }\n      element.loc = getSelection(context, element.loc.start);\n      if (isPreBoundary) {\n          context.inPre = false;\n      }\n      if (isVPreBoundary) {\n          context.inVPre = false;\n      }\n      return element;\n  }\n  const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(`if,else,else-if,for,slot`);\n  /**\n   * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).\n   */\n  function parseTag(context, type, parent) {\n      // Tag open.\n      const start = getCursor(context);\n      const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source);\n      const tag = match[1];\n      const ns = context.options.getNamespace(tag, parent);\n      advanceBy(context, match[0].length);\n      advanceSpaces(context);\n      // save current state in case we need to re-parse attributes with v-pre\n      const cursor = getCursor(context);\n      const currentSource = context.source;\n      // Attributes.\n      let props = parseAttributes(context, type);\n      // check <pre> tag\n      if (context.options.isPreTag(tag)) {\n          context.inPre = true;\n      }\n      // check v-pre\n      if (!context.inVPre &&\n          props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === \'pre\')) {\n          context.inVPre = true;\n          // reset context\n          extend(context, cursor);\n          context.source = currentSource;\n          // re-parse attrs and filter out v-pre itself\n          props = parseAttributes(context, type).filter(p => p.name !== \'v-pre\');\n      }\n      // Tag close.\n      let isSelfClosing = false;\n      if (context.source.length === 0) {\n          emitError(context, 9 /* EOF_IN_TAG */);\n      }\n      else {\n          isSelfClosing = startsWith(context.source, \'/>\');\n          if (type === 1 /* End */ && isSelfClosing) {\n              emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);\n          }\n          advanceBy(context, isSelfClosing ? 2 : 1);\n      }\n      let tagType = 0 /* ELEMENT */;\n      const options = context.options;\n      if (!context.inVPre && !options.isCustomElement(tag)) {\n          const hasVIs = props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === \'is\');\n          if (options.isNativeTag && !hasVIs) {\n              if (!options.isNativeTag(tag))\n                  tagType = 1 /* COMPONENT */;\n          }\n          else if (hasVIs ||\n              isCoreComponent(tag) ||\n              (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||\n              /^[A-Z]/.test(tag) ||\n              tag === \'component\') {\n              tagType = 1 /* COMPONENT */;\n          }\n          if (tag === \'slot\') {\n              tagType = 2 /* SLOT */;\n          }\n          else if (tag === \'template\' &&\n              props.some(p => {\n                  return (p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name));\n              })) {\n              tagType = 3 /* TEMPLATE */;\n          }\n      }\n      return {\n          type: 1 /* ELEMENT */,\n          ns,\n          tag,\n          tagType,\n          props,\n          isSelfClosing,\n          children: [],\n          loc: getSelection(context, start),\n          codegenNode: undefined // to be created during transform phase\n      };\n  }\n  function parseAttributes(context, type) {\n      const props = [];\n      const attributeNames = new Set();\n      while (context.source.length > 0 &&\n          !startsWith(context.source, \'>\') &&\n          !startsWith(context.source, \'/>\')) {\n          if (startsWith(context.source, \'/\')) {\n              emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);\n              advanceBy(context, 1);\n              advanceSpaces(context);\n              continue;\n          }\n          if (type === 1 /* End */) {\n              emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);\n          }\n          const attr = parseAttribute(context, attributeNames);\n          if (type === 0 /* Start */) {\n              props.push(attr);\n          }\n          if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\n              emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);\n          }\n          advanceSpaces(context);\n      }\n      return props;\n  }\n  function parseAttribute(context, nameSet) {\n      // Name.\n      const start = getCursor(context);\n      const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source);\n      const name = match[0];\n      if (nameSet.has(name)) {\n          emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);\n      }\n      nameSet.add(name);\n      if (name[0] === \'=\') {\n          emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);\n      }\n      {\n          const pattern = /["\'<]/g;\n          let m;\n          while ((m = pattern.exec(name))) {\n              emitError(context, 17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);\n          }\n      }\n      advanceBy(context, name.length);\n      // Value\n      let value = undefined;\n      if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\n          advanceSpaces(context);\n          advanceBy(context, 1);\n          advanceSpaces(context);\n          value = parseAttributeValue(context);\n          if (!value) {\n              emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);\n          }\n      }\n      const loc = getSelection(context, start);\n      if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {\n          const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)(\\[[^\\]]+\\]|[^\\.]+))?(.+)?$/i.exec(name);\n          const dirName = match[1] ||\n              (startsWith(name, \':\') ? \'bind\' : startsWith(name, \'@\') ? \'on\' : \'slot\');\n          let arg;\n          if (match[2]) {\n              const isSlot = dirName === \'slot\';\n              const startOffset = name.indexOf(match[2]);\n              const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || \'\').length));\n              let content = match[2];\n              let isStatic = true;\n              if (content.startsWith(\'[\')) {\n                  isStatic = false;\n                  if (!content.endsWith(\']\')) {\n                      emitError(context, 26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);\n                  }\n                  content = content.substr(1, content.length - 2);\n              }\n              else if (isSlot) {\n                  // #1241 special case for v-slot: vuetify relies extensively on slot\n                  // names containing dots. v-slot doesn\'t have any modifiers and Vue 2.x\n                  // supports such usage so we are keeping it consistent with 2.x.\n                  content += match[3] || \'\';\n              }\n              arg = {\n                  type: 4 /* SIMPLE_EXPRESSION */,\n                  content,\n                  isStatic,\n                  isConstant: isStatic,\n                  loc\n              };\n          }\n          if (value && value.isQuoted) {\n              const valueLoc = value.loc;\n              valueLoc.start.offset++;\n              valueLoc.start.column++;\n              valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);\n              valueLoc.source = valueLoc.source.slice(1, -1);\n          }\n          return {\n              type: 7 /* DIRECTIVE */,\n              name: dirName,\n              exp: value && {\n                  type: 4 /* SIMPLE_EXPRESSION */,\n                  content: value.content,\n                  isStatic: false,\n                  // Treat as non-constant by default. This can be potentially set to\n                  // true by `transformExpression` to make it eligible for hoisting.\n                  isConstant: false,\n                  loc: value.loc\n              },\n              arg,\n              modifiers: match[3] ? match[3].substr(1).split(\'.\') : [],\n              loc\n          };\n      }\n      return {\n          type: 6 /* ATTRIBUTE */,\n          name,\n          value: value && {\n              type: 2 /* TEXT */,\n              content: value.content,\n              loc: value.loc\n          },\n          loc\n      };\n  }\n  function parseAttributeValue(context) {\n      const start = getCursor(context);\n      let content;\n      const quote = context.source[0];\n      const isQuoted = quote === `"` || quote === `\'`;\n      if (isQuoted) {\n          // Quoted value.\n          advanceBy(context, 1);\n          const endIndex = context.source.indexOf(quote);\n          if (endIndex === -1) {\n              content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);\n          }\n          else {\n              content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);\n              advanceBy(context, 1);\n          }\n      }\n      else {\n          // Unquoted\n          const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source);\n          if (!match) {\n              return undefined;\n          }\n          const unexpectedChars = /["\'<=`]/g;\n          let m;\n          while ((m = unexpectedChars.exec(match[0]))) {\n              emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);\n          }\n          content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);\n      }\n      return { content, isQuoted, loc: getSelection(context, start) };\n  }\n  function parseInterpolation(context, mode) {\n      const [open, close] = context.options.delimiters;\n      const closeIndex = context.source.indexOf(close, open.length);\n      if (closeIndex === -1) {\n          emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);\n          return undefined;\n      }\n      const start = getCursor(context);\n      advanceBy(context, open.length);\n      const innerStart = getCursor(context);\n      const innerEnd = getCursor(context);\n      const rawContentLength = closeIndex - open.length;\n      const rawContent = context.source.slice(0, rawContentLength);\n      const preTrimContent = parseTextData(context, rawContentLength, mode);\n      const content = preTrimContent.trim();\n      const startOffset = preTrimContent.indexOf(content);\n      if (startOffset > 0) {\n          advancePositionWithMutation(innerStart, rawContent, startOffset);\n      }\n      const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);\n      advancePositionWithMutation(innerEnd, rawContent, endOffset);\n      advanceBy(context, close.length);\n      return {\n          type: 5 /* INTERPOLATION */,\n          content: {\n              type: 4 /* SIMPLE_EXPRESSION */,\n              isStatic: false,\n              // Set `isConstant` to false by default and will decide in transformExpression\n              isConstant: false,\n              content,\n              loc: getSelection(context, innerStart, innerEnd)\n          },\n          loc: getSelection(context, start)\n      };\n  }\n  function parseText(context, mode) {\n      const endTokens = [\'<\', context.options.delimiters[0]];\n      if (mode === 3 /* CDATA */) {\n          endTokens.push(\']]>\');\n      }\n      let endIndex = context.source.length;\n      for (let i = 0; i < endTokens.length; i++) {\n          const index = context.source.indexOf(endTokens[i], 1);\n          if (index !== -1 && endIndex > index) {\n              endIndex = index;\n          }\n      }\n      const start = getCursor(context);\n      const content = parseTextData(context, endIndex, mode);\n      return {\n          type: 2 /* TEXT */,\n          content,\n          loc: getSelection(context, start)\n      };\n  }\n  /**\n   * Get text data with a given length from the current location.\n   * This translates HTML entities in the text data.\n   */\n  function parseTextData(context, length, mode) {\n      const rawText = context.source.slice(0, length);\n      advanceBy(context, length);\n      if (mode === 2 /* RAWTEXT */ ||\n          mode === 3 /* CDATA */ ||\n          rawText.indexOf(\'&\') === -1) {\n          return rawText;\n      }\n      else {\n          // DATA or RCDATA containing "&"". Entity decoding required.\n          return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);\n      }\n  }\n  function getCursor(context) {\n      const { column, line, offset } = context;\n      return { column, line, offset };\n  }\n  function getSelection(context, start, end) {\n      end = end || getCursor(context);\n      return {\n          start,\n          end,\n          source: context.originalSource.slice(start.offset, end.offset)\n      };\n  }\n  function last(xs) {\n      return xs[xs.length - 1];\n  }\n  function startsWith(source, searchString) {\n      return source.startsWith(searchString);\n  }\n  function advanceBy(context, numberOfCharacters) {\n      const { source } = context;\n      advancePositionWithMutation(context, source, numberOfCharacters);\n      context.source = source.slice(numberOfCharacters);\n  }\n  function advanceSpaces(context) {\n      const match = /^[\\t\\r\\n\\f ]+/.exec(context.source);\n      if (match) {\n          advanceBy(context, match[0].length);\n      }\n  }\n  function getNewPosition(context, start, numberOfCharacters) {\n      return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);\n  }\n  function emitError(context, code, offset, loc = getCursor(context)) {\n      if (offset) {\n          loc.offset += offset;\n          loc.column += offset;\n      }\n      context.options.onError(createCompilerError(code, {\n          start: loc,\n          end: loc,\n          source: \'\'\n      }));\n  }\n  function isEnd(context, mode, ancestors) {\n      const s = context.source;\n      switch (mode) {\n          case 0 /* DATA */:\n              if (startsWith(s, \'</\')) {\n                  //TODO: probably bad performance\n                  for (let i = ancestors.length - 1; i >= 0; --i) {\n                      if (startsWithEndTagOpen(s, ancestors[i].tag)) {\n                          return true;\n                      }\n                  }\n              }\n              break;\n          case 1 /* RCDATA */:\n          case 2 /* RAWTEXT */: {\n              const parent = last(ancestors);\n              if (parent && startsWithEndTagOpen(s, parent.tag)) {\n                  return true;\n              }\n              break;\n          }\n          case 3 /* CDATA */:\n              if (startsWith(s, \']]>\')) {\n                  return true;\n              }\n              break;\n      }\n      return !s;\n  }\n  function startsWithEndTagOpen(source, tag) {\n      return (startsWith(source, \'</\') &&\n          source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&\n          /[\\t\\r\\n\\f />]/.test(source[2 + tag.length] || \'>\'));\n  }\n\n  function hoistStatic(root, context) {\n      walk(root, context, new Map(), \n      // Root node is unfortunately non-hoistable due to potential parent\n      // fallthrough attributes.\n      isSingleElementRoot(root, root.children[0]));\n  }\n  function isSingleElementRoot(root, child) {\n      const { children } = root;\n      return (children.length === 1 &&\n          child.type === 1 /* ELEMENT */ &&\n          !isSlotOutlet(child));\n  }\n  function walk(node, context, resultCache, doNotHoistNode = false) {\n      let hasHoistedNode = false;\n      // Some transforms, e.g. transformAssetUrls from @vue/compiler-sfc, replaces\n      // static bindings with expressions. These expressions are guaranteed to be\n      // constant so they are still eligible for hoisting, but they are only\n      // available at runtime and therefore cannot be evaluated ahead of time.\n      // This is only a concern for pre-stringification (via transformHoist by\n      // @vue/compiler-dom), but doing it here allows us to perform only one full\n      // walk of the AST and allow `stringifyStatic` to stop walking as soon as its\n      // stringficiation threshold is met.\n      let hasRuntimeConstant = false;\n      const { children } = node;\n      for (let i = 0; i < children.length; i++) {\n          const child = children[i];\n          // only plain elements & text calls are eligible for hoisting.\n          if (child.type === 1 /* ELEMENT */ &&\n              child.tagType === 0 /* ELEMENT */) {\n              let staticType;\n              if (!doNotHoistNode &&\n                  (staticType = getStaticType(child, resultCache)) > 0) {\n                  if (staticType === 2 /* HAS_RUNTIME_CONSTANT */) {\n                      hasRuntimeConstant = true;\n                  }\n                  child.codegenNode.patchFlag =\n                      -1 /* HOISTED */ + ( ` /* HOISTED */` );\n                  child.codegenNode = context.hoist(child.codegenNode);\n                  hasHoistedNode = true;\n                  continue;\n              }\n              else {\n                  // node may contain dynamic children, but its props may be eligible for\n                  // hoisting.\n                  const codegenNode = child.codegenNode;\n                  if (codegenNode.type === 13 /* VNODE_CALL */) {\n                      const flag = getPatchFlag(codegenNode);\n                      if ((!flag ||\n                          flag === 512 /* NEED_PATCH */ ||\n                          flag === 1 /* TEXT */) &&\n                          !hasNonHoistableProps(child)) {\n                          const props = getNodeProps(child);\n                          if (props) {\n                              codegenNode.props = context.hoist(props);\n                          }\n                      }\n                  }\n              }\n          }\n          else if (child.type === 12 /* TEXT_CALL */) {\n              const staticType = getStaticType(child.content, resultCache);\n              if (staticType > 0) {\n                  if (staticType === 2 /* HAS_RUNTIME_CONSTANT */) {\n                      hasRuntimeConstant = true;\n                  }\n                  child.codegenNode = context.hoist(child.codegenNode);\n                  hasHoistedNode = true;\n              }\n          }\n          // walk further\n          if (child.type === 1 /* ELEMENT */) {\n              walk(child, context, resultCache);\n          }\n          else if (child.type === 11 /* FOR */) {\n              // Do not hoist v-for single child because it has to be a block\n              walk(child, context, resultCache, child.children.length === 1);\n          }\n          else if (child.type === 9 /* IF */) {\n              for (let i = 0; i < child.branches.length; i++) {\n                  // Do not hoist v-if single child because it has to be a block\n                  walk(child.branches[i], context, resultCache, child.branches[i].children.length === 1);\n              }\n          }\n      }\n      if (!hasRuntimeConstant && hasHoistedNode && context.transformHoist) {\n          context.transformHoist(children, context, node);\n      }\n  }\n  function getStaticType(node, resultCache = new Map()) {\n      switch (node.type) {\n          case 1 /* ELEMENT */:\n              if (node.tagType !== 0 /* ELEMENT */) {\n                  return 0 /* NOT_STATIC */;\n              }\n              const cached = resultCache.get(node);\n              if (cached !== undefined) {\n                  return cached;\n              }\n              const codegenNode = node.codegenNode;\n              if (codegenNode.type !== 13 /* VNODE_CALL */) {\n                  return 0 /* NOT_STATIC */;\n              }\n              const flag = getPatchFlag(codegenNode);\n              if (!flag && !hasNonHoistableProps(node)) {\n                  // element self is static. check its children.\n                  let returnType = 1 /* FULL_STATIC */;\n                  for (let i = 0; i < node.children.length; i++) {\n                      const childType = getStaticType(node.children[i], resultCache);\n                      if (childType === 0 /* NOT_STATIC */) {\n                          resultCache.set(node, 0 /* NOT_STATIC */);\n                          return 0 /* NOT_STATIC */;\n                      }\n                      else if (childType === 2 /* HAS_RUNTIME_CONSTANT */) {\n                          returnType = 2 /* HAS_RUNTIME_CONSTANT */;\n                      }\n                  }\n                  // check if any of the props contain runtime constants\n                  if (returnType !== 2 /* HAS_RUNTIME_CONSTANT */) {\n                      for (let i = 0; i < node.props.length; i++) {\n                          const p = node.props[i];\n                          if (p.type === 7 /* DIRECTIVE */ &&\n                              p.name === \'bind\' &&\n                              p.exp &&\n                              (p.exp.type === 8 /* COMPOUND_EXPRESSION */ ||\n                                  p.exp.isRuntimeConstant)) {\n                              returnType = 2 /* HAS_RUNTIME_CONSTANT */;\n                          }\n                      }\n                  }\n                  // only svg/foreignObject could be block here, however if they are\n                  // stati then they don\'t need to be blocks since there will be no\n                  // nested updates.\n                  if (codegenNode.isBlock) {\n                      codegenNode.isBlock = false;\n                  }\n                  resultCache.set(node, returnType);\n                  return returnType;\n              }\n              else {\n                  resultCache.set(node, 0 /* NOT_STATIC */);\n                  return 0 /* NOT_STATIC */;\n              }\n          case 2 /* TEXT */:\n          case 3 /* COMMENT */:\n              return 1 /* FULL_STATIC */;\n          case 9 /* IF */:\n          case 11 /* FOR */:\n          case 10 /* IF_BRANCH */:\n              return 0 /* NOT_STATIC */;\n          case 5 /* INTERPOLATION */:\n          case 12 /* TEXT_CALL */:\n              return getStaticType(node.content, resultCache);\n          case 4 /* SIMPLE_EXPRESSION */:\n              return node.isConstant\n                  ? node.isRuntimeConstant\n                      ? 2 /* HAS_RUNTIME_CONSTANT */\n                      : 1 /* FULL_STATIC */\n                  : 0 /* NOT_STATIC */;\n          case 8 /* COMPOUND_EXPRESSION */:\n              let returnType = 1 /* FULL_STATIC */;\n              for (let i = 0; i < node.children.length; i++) {\n                  const child = node.children[i];\n                  if (isString(child) || isSymbol(child)) {\n                      continue;\n                  }\n                  const childType = getStaticType(child, resultCache);\n                  if (childType === 0 /* NOT_STATIC */) {\n                      return 0 /* NOT_STATIC */;\n                  }\n                  else if (childType === 2 /* HAS_RUNTIME_CONSTANT */) {\n                      returnType = 2 /* HAS_RUNTIME_CONSTANT */;\n                  }\n              }\n              return returnType;\n          default:\n              return 0 /* NOT_STATIC */;\n      }\n  }\n  /**\n   * Even for a node with no patch flag, it is possible for it to contain\n   * non-hoistable expressions that refers to scope variables, e.g. compiler\n   * injected keys or cached event handlers. Therefore we need to always check the\n   * codegenNode\'s props to be sure.\n   */\n  function hasNonHoistableProps(node) {\n      const props = getNodeProps(node);\n      if (props && props.type === 15 /* JS_OBJECT_EXPRESSION */) {\n          const { properties } = props;\n          for (let i = 0; i < properties.length; i++) {\n              const { key, value } = properties[i];\n              if (key.type !== 4 /* SIMPLE_EXPRESSION */ ||\n                  !key.isStatic ||\n                  (value.type !== 4 /* SIMPLE_EXPRESSION */ ||\n                      (!value.isStatic && !value.isConstant))) {\n                  return true;\n              }\n          }\n      }\n      return false;\n  }\n  function getNodeProps(node) {\n      const codegenNode = node.codegenNode;\n      if (codegenNode.type === 13 /* VNODE_CALL */) {\n          return codegenNode.props;\n      }\n  }\n  function getPatchFlag(node) {\n      const flag = node.patchFlag;\n      return flag ? parseInt(flag, 10) : undefined;\n  }\n\n  function createTransformContext(root, { prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, ssr = false, ssrCssVars = ``, bindingMetadata = {}, onError = defaultOnError }) {\n      const context = {\n          // options\n          prefixIdentifiers,\n          hoistStatic,\n          cacheHandlers,\n          nodeTransforms,\n          directiveTransforms,\n          transformHoist,\n          isBuiltInComponent,\n          isCustomElement,\n          expressionPlugins,\n          scopeId,\n          ssr,\n          ssrCssVars,\n          bindingMetadata,\n          onError,\n          // state\n          root,\n          helpers: new Set(),\n          components: new Set(),\n          directives: new Set(),\n          hoists: [],\n          imports: new Set(),\n          temps: 0,\n          cached: 0,\n          identifiers: Object.create(null),\n          scopes: {\n              vFor: 0,\n              vSlot: 0,\n              vPre: 0,\n              vOnce: 0\n          },\n          parent: null,\n          currentNode: root,\n          childIndex: 0,\n          // methods\n          helper(name) {\n              context.helpers.add(name);\n              return name;\n          },\n          helperString(name) {\n              return `_${helperNameMap[context.helper(name)]}`;\n          },\n          replaceNode(node) {\n              /* istanbul ignore if */\n              {\n                  if (!context.currentNode) {\n                      throw new Error(`Node being replaced is already removed.`);\n                  }\n                  if (!context.parent) {\n                      throw new Error(`Cannot replace root node.`);\n                  }\n              }\n              context.parent.children[context.childIndex] = context.currentNode = node;\n          },\n          removeNode(node) {\n              if ( !context.parent) {\n                  throw new Error(`Cannot remove root node.`);\n              }\n              const list = context.parent.children;\n              const removalIndex = node\n                  ? list.indexOf(node)\n                  : context.currentNode\n                      ? context.childIndex\n                      : -1;\n              /* istanbul ignore if */\n              if ( removalIndex < 0) {\n                  throw new Error(`node being removed is not a child of current parent`);\n              }\n              if (!node || node === context.currentNode) {\n                  // current node removed\n                  context.currentNode = null;\n                  context.onNodeRemoved();\n              }\n              else {\n                  // sibling node removed\n                  if (context.childIndex > removalIndex) {\n                      context.childIndex--;\n                      context.onNodeRemoved();\n                  }\n              }\n              context.parent.children.splice(removalIndex, 1);\n          },\n          onNodeRemoved: () => { },\n          addIdentifiers(exp) {\n          },\n          removeIdentifiers(exp) {\n          },\n          hoist(exp) {\n              context.hoists.push(exp);\n              const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, true);\n              identifier.hoisted = exp;\n              return identifier;\n          },\n          cache(exp, isVNode = false) {\n              return createCacheExpression(++context.cached, exp, isVNode);\n          }\n      };\n      return context;\n  }\n  function transform(root, options) {\n      const context = createTransformContext(root, options);\n      traverseNode(root, context);\n      if (options.hoistStatic) {\n          hoistStatic(root, context);\n      }\n      if (!options.ssr) {\n          createRootCodegen(root, context);\n      }\n      // finalize meta information\n      root.helpers = [...context.helpers];\n      root.components = [...context.components];\n      root.directives = [...context.directives];\n      root.imports = [...context.imports];\n      root.hoists = context.hoists;\n      root.temps = context.temps;\n      root.cached = context.cached;\n  }\n  function createRootCodegen(root, context) {\n      const { helper } = context;\n      const { children } = root;\n      if (children.length === 1) {\n          const child = children[0];\n          // if the single child is an element, turn it into a block.\n          if (isSingleElementRoot(root, child) && child.codegenNode) {\n              // single element root is never hoisted so codegenNode will never be\n              // SimpleExpressionNode\n              const codegenNode = child.codegenNode;\n              if (codegenNode.type === 13 /* VNODE_CALL */) {\n                  codegenNode.isBlock = true;\n                  helper(OPEN_BLOCK);\n                  helper(CREATE_BLOCK);\n              }\n              root.codegenNode = codegenNode;\n          }\n          else {\n              // - single <slot/>, IfNode, ForNode: already blocks.\n              // - single text node: always patched.\n              // root codegen falls through via genNode()\n              root.codegenNode = child;\n          }\n      }\n      else if (children.length > 1) {\n          // root has multiple nodes - return a fragment block.\n          root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, `${64 /* STABLE_FRAGMENT */} /* ${PatchFlagNames[64 /* STABLE_FRAGMENT */]} */`, undefined, undefined, true);\n      }\n      else ;\n  }\n  function traverseChildren(parent, context) {\n      let i = 0;\n      const nodeRemoved = () => {\n          i--;\n      };\n      for (; i < parent.children.length; i++) {\n          const child = parent.children[i];\n          if (isString(child))\n              continue;\n          context.parent = parent;\n          context.childIndex = i;\n          context.onNodeRemoved = nodeRemoved;\n          traverseNode(child, context);\n      }\n  }\n  function traverseNode(node, context) {\n      context.currentNode = node;\n      // apply transform plugins\n      const { nodeTransforms } = context;\n      const exitFns = [];\n      for (let i = 0; i < nodeTransforms.length; i++) {\n          const onExit = nodeTransforms[i](node, context);\n          if (onExit) {\n              if (isArray(onExit)) {\n                  exitFns.push(...onExit);\n              }\n              else {\n                  exitFns.push(onExit);\n              }\n          }\n          if (!context.currentNode) {\n              // node was removed\n              return;\n          }\n          else {\n              // node may have been replaced\n              node = context.currentNode;\n          }\n      }\n      switch (node.type) {\n          case 3 /* COMMENT */:\n              if (!context.ssr) {\n                  // inject import for the Comment symbol, which is needed for creating\n                  // comment nodes with `createVNode`\n                  context.helper(CREATE_COMMENT);\n              }\n              break;\n          case 5 /* INTERPOLATION */:\n              // no need to traverse, but we need to inject toString helper\n              if (!context.ssr) {\n                  context.helper(TO_DISPLAY_STRING);\n              }\n              break;\n          // for container types, further traverse downwards\n          case 9 /* IF */:\n              for (let i = 0; i < node.branches.length; i++) {\n                  traverseNode(node.branches[i], context);\n              }\n              break;\n          case 10 /* IF_BRANCH */:\n          case 11 /* FOR */:\n          case 1 /* ELEMENT */:\n          case 0 /* ROOT */:\n              traverseChildren(node, context);\n              break;\n      }\n      // exit transforms\n      context.currentNode = node;\n      let i = exitFns.length;\n      while (i--) {\n          exitFns[i]();\n      }\n  }\n  function createStructuralDirectiveTransform(name, fn) {\n      const matches = isString(name)\n          ? (n) => n === name\n          : (n) => name.test(n);\n      return (node, context) => {\n          if (node.type === 1 /* ELEMENT */) {\n              const { props } = node;\n              // structural directive transforms are not concerned with slots\n              // as they are handled separately in vSlot.ts\n              if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {\n                  return;\n              }\n              const exitFns = [];\n              for (let i = 0; i < props.length; i++) {\n                  const prop = props[i];\n                  if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {\n                      // structural directives are removed to avoid infinite recursion\n                      // also we remove them *before* applying so that it can further\n                      // traverse itself in case it moves the node around\n                      props.splice(i, 1);\n                      i--;\n                      const onExit = fn(node, prop, context);\n                      if (onExit)\n                          exitFns.push(onExit);\n                  }\n              }\n              return exitFns;\n          }\n      };\n  }\n\n  const PURE_ANNOTATION = `/*#__PURE__*/`;\n  function createCodegenContext(ast, { mode = \'function\', prefixIdentifiers = mode === \'module\', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssr = false }) {\n      const context = {\n          mode,\n          prefixIdentifiers,\n          sourceMap,\n          filename,\n          scopeId,\n          optimizeImports,\n          runtimeGlobalName,\n          runtimeModuleName,\n          ssr,\n          source: ast.loc.source,\n          code: ``,\n          column: 1,\n          line: 1,\n          offset: 0,\n          indentLevel: 0,\n          pure: false,\n          map: undefined,\n          helper(key) {\n              return `_${helperNameMap[key]}`;\n          },\n          push(code, node) {\n              context.code += code;\n          },\n          indent() {\n              newline(++context.indentLevel);\n          },\n          deindent(withoutNewLine = false) {\n              if (withoutNewLine) {\n                  --context.indentLevel;\n              }\n              else {\n                  newline(--context.indentLevel);\n              }\n          },\n          newline() {\n              newline(context.indentLevel);\n          }\n      };\n      function newline(n) {\n          context.push(\'\\n\' + `  `.repeat(n));\n      }\n      return context;\n  }\n  function generate(ast, options = {}) {\n      const context = createCodegenContext(ast, options);\n      if (options.onContextCreated)\n          options.onContextCreated(context);\n      const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;\n      const hasHelpers = ast.helpers.length > 0;\n      const useWithBlock = !prefixIdentifiers && mode !== \'module\';\n      // preambles\n      {\n          genFunctionPreamble(ast, context);\n      }\n      // binding optimizations\n      const optimizeSources = options.bindingMetadata\n          ? `, $props, $setup, $data, $options`\n          : ``;\n      // enter render function\n      if (!ssr) {\n          push(`function render(_ctx, _cache${optimizeSources}) {`);\n      }\n      else {\n          push(`function ssrRender(_ctx, _push, _parent, _attrs${optimizeSources}) {`);\n      }\n      indent();\n      if (useWithBlock) {\n          push(`with (_ctx) {`);\n          indent();\n          // function mode const declarations should be inside with block\n          // also they should be renamed to avoid collision with user properties\n          if (hasHelpers) {\n              push(`const { ${ast.helpers\n                .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)\n                .join(\', \')} } = _Vue`);\n              push(`\\n`);\n              newline();\n          }\n      }\n      // generate asset resolution statements\n      if (ast.components.length) {\n          genAssets(ast.components, \'component\', context);\n          if (ast.directives.length || ast.temps > 0) {\n              newline();\n          }\n      }\n      if (ast.directives.length) {\n          genAssets(ast.directives, \'directive\', context);\n          if (ast.temps > 0) {\n              newline();\n          }\n      }\n      if (ast.temps > 0) {\n          push(`let `);\n          for (let i = 0; i < ast.temps; i++) {\n              push(`${i > 0 ? `, ` : ``}_temp${i}`);\n          }\n      }\n      if (ast.components.length || ast.directives.length || ast.temps) {\n          push(`\\n`);\n          newline();\n      }\n      // generate the VNode tree expression\n      if (!ssr) {\n          push(`return `);\n      }\n      if (ast.codegenNode) {\n          genNode(ast.codegenNode, context);\n      }\n      else {\n          push(`null`);\n      }\n      if (useWithBlock) {\n          deindent();\n          push(`}`);\n      }\n      deindent();\n      push(`}`);\n      return {\n          ast,\n          code: context.code,\n          // SourceMapGenerator does have toJSON() method but it\'s not in the types\n          map: context.map ? context.map.toJSON() : undefined\n      };\n  }\n  function genFunctionPreamble(ast, context) {\n      const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName } = context;\n      const VueBinding =  runtimeGlobalName;\n      const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;\n      // Generate const declaration for helpers\n      // In prefix mode, we place the const declaration at top so it\'s done\n      // only once; But if we not prefixing, we place the declaration inside the\n      // with block so it doesn\'t incur the `in` check cost for every helper access.\n      if (ast.helpers.length > 0) {\n          {\n              // "with" mode.\n              // save Vue in a separate variable to avoid collision\n              push(`const _Vue = ${VueBinding}\\n`);\n              // in "with" mode, helpers are declared inside the with block to avoid\n              // has check cost, but hoists are lifted out of the function - we need\n              // to provide the helper here.\n              if (ast.hoists.length) {\n                  const staticHelpers = [\n                      CREATE_VNODE,\n                      CREATE_COMMENT,\n                      CREATE_TEXT,\n                      CREATE_STATIC\n                  ]\n                      .filter(helper => ast.helpers.includes(helper))\n                      .map(aliasHelper)\n                      .join(\', \');\n                  push(`const { ${staticHelpers} } = _Vue\\n`);\n              }\n          }\n      }\n      genHoists(ast.hoists, context);\n      newline();\n      push(`return `);\n  }\n  function genAssets(assets, type, { helper, push, newline }) {\n      const resolver = helper(type === \'component\' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);\n      for (let i = 0; i < assets.length; i++) {\n          const id = assets[i];\n          push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)})`);\n          if (i < assets.length - 1) {\n              newline();\n          }\n      }\n  }\n  function genHoists(hoists, context) {\n      if (!hoists.length) {\n          return;\n      }\n      context.pure = true;\n      const { push, newline, helper, scopeId, mode } = context;\n      newline();\n      hoists.forEach((exp, i) => {\n          if (exp) {\n              push(`const _hoisted_${i + 1} = `);\n              genNode(exp, context);\n              newline();\n          }\n      });\n      context.pure = false;\n  }\n  function isText$1(n) {\n      return (isString(n) ||\n          n.type === 4 /* SIMPLE_EXPRESSION */ ||\n          n.type === 2 /* TEXT */ ||\n          n.type === 5 /* INTERPOLATION */ ||\n          n.type === 8 /* COMPOUND_EXPRESSION */);\n  }\n  function genNodeListAsArray(nodes, context) {\n      const multilines = nodes.length > 3 ||\n          ( nodes.some(n => isArray(n) || !isText$1(n)));\n      context.push(`[`);\n      multilines && context.indent();\n      genNodeList(nodes, context, multilines);\n      multilines && context.deindent();\n      context.push(`]`);\n  }\n  function genNodeList(nodes, context, multilines = false, comma = true) {\n      const { push, newline } = context;\n      for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if (isString(node)) {\n              push(node);\n          }\n          else if (isArray(node)) {\n              genNodeListAsArray(node, context);\n          }\n          else {\n              genNode(node, context);\n          }\n          if (i < nodes.length - 1) {\n              if (multilines) {\n                  comma && push(\',\');\n                  newline();\n              }\n              else {\n                  comma && push(\', \');\n              }\n          }\n      }\n  }\n  function genNode(node, context) {\n      if (isString(node)) {\n          context.push(node);\n          return;\n      }\n      if (isSymbol(node)) {\n          context.push(context.helper(node));\n          return;\n      }\n      switch (node.type) {\n          case 1 /* ELEMENT */:\n          case 9 /* IF */:\n          case 11 /* FOR */:\n              \n                  assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +\n                      `Apply appropriate transforms first.`);\n              genNode(node.codegenNode, context);\n              break;\n          case 2 /* TEXT */:\n              genText(node, context);\n              break;\n          case 4 /* SIMPLE_EXPRESSION */:\n              genExpression(node, context);\n              break;\n          case 5 /* INTERPOLATION */:\n              genInterpolation(node, context);\n              break;\n          case 12 /* TEXT_CALL */:\n              genNode(node.codegenNode, context);\n              break;\n          case 8 /* COMPOUND_EXPRESSION */:\n              genCompoundExpression(node, context);\n              break;\n          case 3 /* COMMENT */:\n              genComment(node, context);\n              break;\n          case 13 /* VNODE_CALL */:\n              genVNodeCall(node, context);\n              break;\n          case 14 /* JS_CALL_EXPRESSION */:\n              genCallExpression(node, context);\n              break;\n          case 15 /* JS_OBJECT_EXPRESSION */:\n              genObjectExpression(node, context);\n              break;\n          case 17 /* JS_ARRAY_EXPRESSION */:\n              genArrayExpression(node, context);\n              break;\n          case 18 /* JS_FUNCTION_EXPRESSION */:\n              genFunctionExpression(node, context);\n              break;\n          case 19 /* JS_CONDITIONAL_EXPRESSION */:\n              genConditionalExpression(node, context);\n              break;\n          case 20 /* JS_CACHE_EXPRESSION */:\n              genCacheExpression(node, context);\n              break;\n          // SSR only types\n          case 21 /* JS_BLOCK_STATEMENT */:\n              break;\n          case 22 /* JS_TEMPLATE_LITERAL */:\n              break;\n          case 23 /* JS_IF_STATEMENT */:\n              break;\n          case 24 /* JS_ASSIGNMENT_EXPRESSION */:\n              break;\n          case 25 /* JS_SEQUENCE_EXPRESSION */:\n              break;\n          case 26 /* JS_RETURN_STATEMENT */:\n              break;\n          /* istanbul ignore next */\n          case 10 /* IF_BRANCH */:\n              // noop\n              break;\n          default:\n              {\n                  assert(false, `unhandled codegen node type: ${node.type}`);\n                  // make sure we exhaust all possible types\n                  const exhaustiveCheck = node;\n                  return exhaustiveCheck;\n              }\n      }\n  }\n  function genText(node, context) {\n      context.push(JSON.stringify(node.content), node);\n  }\n  function genExpression(node, context) {\n      const { content, isStatic } = node;\n      context.push(isStatic ? JSON.stringify(content) : content, node);\n  }\n  function genInterpolation(node, context) {\n      const { push, helper, pure } = context;\n      if (pure)\n          push(PURE_ANNOTATION);\n      push(`${helper(TO_DISPLAY_STRING)}(`);\n      genNode(node.content, context);\n      push(`)`);\n  }\n  function genCompoundExpression(node, context) {\n      for (let i = 0; i < node.children.length; i++) {\n          const child = node.children[i];\n          if (isString(child)) {\n              context.push(child);\n          }\n          else {\n              genNode(child, context);\n          }\n      }\n  }\n  function genExpressionAsPropertyKey(node, context) {\n      const { push } = context;\n      if (node.type === 8 /* COMPOUND_EXPRESSION */) {\n          push(`[`);\n          genCompoundExpression(node, context);\n          push(`]`);\n      }\n      else if (node.isStatic) {\n          // only quote keys if necessary\n          const text = isSimpleIdentifier(node.content)\n              ? node.content\n              : JSON.stringify(node.content);\n          push(text, node);\n      }\n      else {\n          push(`[${node.content}]`, node);\n      }\n  }\n  function genComment(node, context) {\n      {\n          const { push, helper, pure } = context;\n          if (pure) {\n              push(PURE_ANNOTATION);\n          }\n          push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);\n      }\n  }\n  function genVNodeCall(node, context) {\n      const { push, helper, pure } = context;\n      const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking } = node;\n      if (directives) {\n          push(helper(WITH_DIRECTIVES) + `(`);\n      }\n      if (isBlock) {\n          push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);\n      }\n      if (pure) {\n          push(PURE_ANNOTATION);\n      }\n      push(helper(isBlock ? CREATE_BLOCK : CREATE_VNODE) + `(`, node);\n      genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);\n      push(`)`);\n      if (isBlock) {\n          push(`)`);\n      }\n      if (directives) {\n          push(`, `);\n          genNode(directives, context);\n          push(`)`);\n      }\n  }\n  function genNullableArgs(args) {\n      let i = args.length;\n      while (i--) {\n          if (args[i] != null)\n              break;\n      }\n      return args.slice(0, i + 1).map(arg => arg || `null`);\n  }\n  // JavaScript\n  function genCallExpression(node, context) {\n      const { push, helper, pure } = context;\n      const callee = isString(node.callee) ? node.callee : helper(node.callee);\n      if (pure) {\n          push(PURE_ANNOTATION);\n      }\n      push(callee + `(`, node);\n      genNodeList(node.arguments, context);\n      push(`)`);\n  }\n  function genObjectExpression(node, context) {\n      const { push, indent, deindent, newline } = context;\n      const { properties } = node;\n      if (!properties.length) {\n          push(`{}`, node);\n          return;\n      }\n      const multilines = properties.length > 1 ||\n          (\n              properties.some(p => p.value.type !== 4 /* SIMPLE_EXPRESSION */));\n      push(multilines ? `{` : `{ `);\n      multilines && indent();\n      for (let i = 0; i < properties.length; i++) {\n          const { key, value } = properties[i];\n          // key\n          genExpressionAsPropertyKey(key, context);\n          push(`: `);\n          // value\n          genNode(value, context);\n          if (i < properties.length - 1) {\n              // will only reach this if it\'s multilines\n              push(`,`);\n              newline();\n          }\n      }\n      multilines && deindent();\n      push(multilines ? `}` : ` }`);\n  }\n  function genArrayExpression(node, context) {\n      genNodeListAsArray(node.elements, context);\n  }\n  function genFunctionExpression(node, context) {\n      const { push, indent, deindent, scopeId, mode } = context;\n      const { params, returns, body, newline, isSlot } = node;\n      if (isSlot) {\n          push(`_${helperNameMap[WITH_CTX]}(`);\n      }\n      push(`(`, node);\n      if (isArray(params)) {\n          genNodeList(params, context);\n      }\n      else if (params) {\n          genNode(params, context);\n      }\n      push(`) => `);\n      if (newline || body) {\n          push(`{`);\n          indent();\n      }\n      if (returns) {\n          if (newline) {\n              push(`return `);\n          }\n          if (isArray(returns)) {\n              genNodeListAsArray(returns, context);\n          }\n          else {\n              genNode(returns, context);\n          }\n      }\n      else if (body) {\n          genNode(body, context);\n      }\n      if (newline || body) {\n          deindent();\n          push(`}`);\n      }\n      if ( isSlot) {\n          push(`)`);\n      }\n  }\n  function genConditionalExpression(node, context) {\n      const { test, consequent, alternate, newline: needNewline } = node;\n      const { push, indent, deindent, newline } = context;\n      if (test.type === 4 /* SIMPLE_EXPRESSION */) {\n          const needsParens = !isSimpleIdentifier(test.content);\n          needsParens && push(`(`);\n          genExpression(test, context);\n          needsParens && push(`)`);\n      }\n      else {\n          push(`(`);\n          genNode(test, context);\n          push(`)`);\n      }\n      needNewline && indent();\n      context.indentLevel++;\n      needNewline || push(` `);\n      push(`? `);\n      genNode(consequent, context);\n      context.indentLevel--;\n      needNewline && newline();\n      needNewline || push(` `);\n      push(`: `);\n      const isNested = alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */;\n      if (!isNested) {\n          context.indentLevel++;\n      }\n      genNode(alternate, context);\n      if (!isNested) {\n          context.indentLevel--;\n      }\n      needNewline && deindent(true /* without newline */);\n  }\n  function genCacheExpression(node, context) {\n      const { push, helper, indent, deindent, newline } = context;\n      push(`_cache[${node.index}] || (`);\n      if (node.isVNode) {\n          indent();\n          push(`${helper(SET_BLOCK_TRACKING)}(-1),`);\n          newline();\n      }\n      push(`_cache[${node.index}] = `);\n      genNode(node.value, context);\n      if (node.isVNode) {\n          push(`,`);\n          newline();\n          push(`${helper(SET_BLOCK_TRACKING)}(1),`);\n          newline();\n          push(`_cache[${node.index}]`);\n          deindent();\n      }\n      push(`)`);\n  }\n\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n  const prohibitedKeywordRE = new RegExp(\'\\\\b\' +\n      (\'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,\' +\n          \'super,throw,while,yield,delete,export,import,return,switch,default,\' +\n          \'extends,finally,continue,debugger,function,arguments,typeof,void\')\n          .split(\',\')\n          .join(\'\\\\b|\\\\b\') +\n      \'\\\\b\');\n  // strip strings in expressions\n  const stripStringRE = /\'(?:[^\'\\\\]|\\\\.)*\'|"(?:[^"\\\\]|\\\\.)*"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n  /**\n   * Validate a non-prefixed expression.\n   * This is only called when using the in-browser runtime compiler since it\n   * doesn\'t prefix expressions.\n   */\n  function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {\n      const exp = node.content;\n      // empty expressions are validated per-directive since some directives\n      // do allow empty expressions.\n      if (!exp.trim()) {\n          return;\n      }\n      try {\n          new Function(asRawStatements\n              ? ` ${exp} `\n              : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);\n      }\n      catch (e) {\n          let message = e.message;\n          const keywordMatch = exp\n              .replace(stripStringRE, \'\')\n              .match(prohibitedKeywordRE);\n          if (keywordMatch) {\n              message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;\n          }\n          context.onError(createCompilerError(43 /* X_INVALID_EXPRESSION */, node.loc, undefined, message));\n      }\n  }\n\n  const transformExpression = (node, context) => {\n      if (node.type === 5 /* INTERPOLATION */) {\n          node.content = processExpression(node.content, context);\n      }\n      else if (node.type === 1 /* ELEMENT */) {\n          // handle directives on element\n          for (let i = 0; i < node.props.length; i++) {\n              const dir = node.props[i];\n              // do not process for v-on & v-for since they are special handled\n              if (dir.type === 7 /* DIRECTIVE */ && dir.name !== \'for\') {\n                  const exp = dir.exp;\n                  const arg = dir.arg;\n                  // do not process exp if this is v-on:arg - we need special handling\n                  // for wrapping inline statements.\n                  if (exp &&\n                      exp.type === 4 /* SIMPLE_EXPRESSION */ &&\n                      !(dir.name === \'on\' && arg)) {\n                      dir.exp = processExpression(exp, context, \n                      // slot args must be processed as function params\n                      dir.name === \'slot\');\n                  }\n                  if (arg && arg.type === 4 /* SIMPLE_EXPRESSION */ && !arg.isStatic) {\n                      dir.arg = processExpression(arg, context);\n                  }\n              }\n          }\n      }\n  };\n  // Important: since this function uses Node.js only dependencies, it should\n  // always be used with a leading !true check so that it can be\n  // tree-shaken from the browser build.\n  function processExpression(node, context, \n  // some expressions like v-slot props & v-for aliases should be parsed as\n  // function params\n  asParams = false, \n  // v-on handler values may contain multiple statements\n  asRawStatements = false) {\n      {\n          // simple in-browser validation (same logic in 2.x)\n          validateBrowserExpression(node, context, asParams, asRawStatements);\n          return node;\n      }\n  }\n\n  const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {\n      return processIf(node, dir, context, (ifNode, branch, isRoot) => {\n          // #1587: We need to dynamically increment the key based on the current\n          // node\'s sibling nodes, since chained v-if/else branches are\n          // rendered at the same depth\n          const siblings = context.parent.children;\n          let i = siblings.indexOf(ifNode);\n          let key = 0;\n          while (i-- >= 0) {\n              const sibling = siblings[i];\n              if (sibling && sibling.type === 9 /* IF */) {\n                  key += sibling.branches.length;\n              }\n          }\n          // Exit callback. Complete the codegenNode when all children have been\n          // transformed.\n          return () => {\n              if (isRoot) {\n                  ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);\n              }\n              else {\n                  // attach this branch\'s codegen node to the v-if root.\n                  const parentCondition = getParentCondition(ifNode.codegenNode);\n                  parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);\n              }\n          };\n      });\n  });\n  // target-agnostic transform used for both Client and SSR\n  function processIf(node, dir, context, processCodegen) {\n      if (dir.name !== \'else\' &&\n          (!dir.exp || !dir.exp.content.trim())) {\n          const loc = dir.exp ? dir.exp.loc : node.loc;\n          context.onError(createCompilerError(27 /* X_V_IF_NO_EXPRESSION */, dir.loc));\n          dir.exp = createSimpleExpression(`true`, false, loc);\n      }\n      if ( dir.exp) {\n          validateBrowserExpression(dir.exp, context);\n      }\n      if (dir.name === \'if\') {\n          const branch = createIfBranch(node, dir);\n          const ifNode = {\n              type: 9 /* IF */,\n              loc: node.loc,\n              branches: [branch]\n          };\n          context.replaceNode(ifNode);\n          if (processCodegen) {\n              return processCodegen(ifNode, branch, true);\n          }\n      }\n      else {\n          // locate the adjacent v-if\n          const siblings = context.parent.children;\n          const comments = [];\n          let i = siblings.indexOf(node);\n          while (i-- >= -1) {\n              const sibling = siblings[i];\n              if ( sibling && sibling.type === 3 /* COMMENT */) {\n                  context.removeNode(sibling);\n                  comments.unshift(sibling);\n                  continue;\n              }\n              if (sibling &&\n                  sibling.type === 2 /* TEXT */ &&\n                  !sibling.content.trim().length) {\n                  context.removeNode(sibling);\n                  continue;\n              }\n              if (sibling && sibling.type === 9 /* IF */) {\n                  // move the node to the if node\'s branches\n                  context.removeNode();\n                  const branch = createIfBranch(node, dir);\n                  if ( comments.length) {\n                      branch.children = [...comments, ...branch.children];\n                  }\n                  // check if user is forcing same key on different branches\n                  {\n                      const key = branch.userKey;\n                      if (key) {\n                          sibling.branches.forEach(({ userKey }) => {\n                              if (isSameKey(userKey, key)) {\n                                  context.onError(createCompilerError(28 /* X_V_IF_SAME_KEY */, branch.userKey.loc));\n                              }\n                          });\n                      }\n                  }\n                  sibling.branches.push(branch);\n                  const onExit = processCodegen && processCodegen(sibling, branch, false);\n                  // since the branch was removed, it will not be traversed.\n                  // make sure to traverse here.\n                  traverseNode(branch, context);\n                  // call on exit\n                  if (onExit)\n                      onExit();\n                  // make sure to reset currentNode after traversal to indicate this\n                  // node has been removed.\n                  context.currentNode = null;\n              }\n              else {\n                  context.onError(createCompilerError(29 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));\n              }\n              break;\n          }\n      }\n  }\n  function createIfBranch(node, dir) {\n      return {\n          type: 10 /* IF_BRANCH */,\n          loc: node.loc,\n          condition: dir.name === \'else\' ? undefined : dir.exp,\n          children: node.tagType === 3 /* TEMPLATE */ && !findDir(node, \'for\')\n              ? node.children\n              : [node],\n          userKey: findProp(node, `key`)\n      };\n  }\n  function createCodegenNodeForBranch(branch, keyIndex, context) {\n      if (branch.condition) {\n          return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), \n          // make sure to pass in asBlock: true so that the comment node call\n          // closes the current block.\n          createCallExpression(context.helper(CREATE_COMMENT), [\n               \'"v-if"\' ,\n              \'true\'\n          ]));\n      }\n      else {\n          return createChildrenCodegenNode(branch, keyIndex, context);\n      }\n  }\n  function createChildrenCodegenNode(branch, keyIndex, context) {\n      const { helper } = context;\n      const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, true));\n      const { children } = branch;\n      const firstChild = children[0];\n      const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* ELEMENT */;\n      if (needFragmentWrapper) {\n          if (children.length === 1 && firstChild.type === 11 /* FOR */) {\n              // optimize away nested fragments when child is a ForNode\n              const vnodeCall = firstChild.codegenNode;\n              injectProp(vnodeCall, keyProperty, context);\n              return vnodeCall;\n          }\n          else {\n              return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, `${64 /* STABLE_FRAGMENT */} /* ${PatchFlagNames[64 /* STABLE_FRAGMENT */]} */`, undefined, undefined, true, false, branch.loc);\n          }\n      }\n      else {\n          const vnodeCall = firstChild\n              .codegenNode;\n          // Change createVNode to createBlock.\n          if (vnodeCall.type === 13 /* VNODE_CALL */) {\n              vnodeCall.isBlock = true;\n              helper(OPEN_BLOCK);\n              helper(CREATE_BLOCK);\n          }\n          // inject branch key\n          injectProp(vnodeCall, keyProperty, context);\n          return vnodeCall;\n      }\n  }\n  function isSameKey(a, b) {\n      if (!a || a.type !== b.type) {\n          return false;\n      }\n      if (a.type === 6 /* ATTRIBUTE */) {\n          if (a.value.content !== b.value.content) {\n              return false;\n          }\n      }\n      else {\n          // directive\n          const exp = a.exp;\n          const branchExp = b.exp;\n          if (exp.type !== branchExp.type) {\n              return false;\n          }\n          if (exp.type !== 4 /* SIMPLE_EXPRESSION */ ||\n              (exp.isStatic !== branchExp.isStatic ||\n                  exp.content !== branchExp.content)) {\n              return false;\n          }\n      }\n      return true;\n  }\n  function getParentCondition(node) {\n      while (true) {\n          if (node.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\n              if (node.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\n                  node = node.alternate;\n              }\n              else {\n                  return node;\n              }\n          }\n          else if (node.type === 20 /* JS_CACHE_EXPRESSION */) {\n              node = node.value;\n          }\n      }\n  }\n\n  const transformFor = createStructuralDirectiveTransform(\'for\', (node, dir, context) => {\n      const { helper } = context;\n      return processFor(node, dir, context, forNode => {\n          // create the loop render function expression now, and add the\n          // iterator on exit after all children have been traversed\n          const renderExp = createCallExpression(helper(RENDER_LIST), [\n              forNode.source\n          ]);\n          const keyProp = findProp(node, `key`);\n          const keyProperty = keyProp\n              ? createObjectProperty(`key`, keyProp.type === 6 /* ATTRIBUTE */\n                  ? createSimpleExpression(keyProp.value.content, true)\n                  : keyProp.exp)\n              : null;\n          const isStableFragment = forNode.source.type === 4 /* SIMPLE_EXPRESSION */ &&\n              forNode.source.isConstant;\n          const fragmentFlag = isStableFragment\n              ? 64 /* STABLE_FRAGMENT */\n              : keyProp\n                  ? 128 /* KEYED_FRAGMENT */\n                  : 256 /* UNKEYED_FRAGMENT */;\n          forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, `${fragmentFlag} /* ${PatchFlagNames[fragmentFlag]} */`, undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, node.loc);\n          return () => {\n              // finish the codegen now that all children have been traversed\n              let childBlock;\n              const isTemplate = isTemplateNode(node);\n              const { children } = forNode;\n              // check <template v-for> key placement\n              if ( isTemplate) {\n                  node.children.some(c => {\n                      if (c.type === 1 /* ELEMENT */) {\n                          const key = findProp(c, \'key\');\n                          if (key) {\n                              context.onError(createCompilerError(32 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));\n                              return true;\n                          }\n                      }\n                  });\n              }\n              const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* ELEMENT */;\n              const slotOutlet = isSlotOutlet(node)\n                  ? node\n                  : isTemplate &&\n                      node.children.length === 1 &&\n                      isSlotOutlet(node.children[0])\n                      ? node.children[0] // api-extractor somehow fails to infer this\n                      : null;\n              if (slotOutlet) {\n                  // <slot v-for="..."> or <template v-for="..."><slot/></template>\n                  childBlock = slotOutlet.codegenNode;\n                  if (isTemplate && keyProperty) {\n                      // <template v-for="..." :key="..."><slot/></template>\n                      // we need to inject the key to the renderSlot() call.\n                      // the props for renderSlot is passed as the 3rd argument.\n                      injectProp(childBlock, keyProperty, context);\n                  }\n              }\n              else if (needFragmentWrapper) {\n                  // <template v-for="..."> with text or multi-elements\n                  // should generate a fragment block for each loop\n                  childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, `${64 /* STABLE_FRAGMENT */} /* ${PatchFlagNames[64 /* STABLE_FRAGMENT */]} */`, undefined, undefined, true);\n              }\n              else {\n                  // Normal element v-for. Directly use the child\'s codegenNode\n                  // but mark it as a block.\n                  childBlock = children[0]\n                      .codegenNode;\n                  if (isTemplate && keyProperty) {\n                      injectProp(childBlock, keyProperty, context);\n                  }\n                  childBlock.isBlock = !isStableFragment;\n                  if (childBlock.isBlock) {\n                      helper(OPEN_BLOCK);\n                      helper(CREATE_BLOCK);\n                  }\n              }\n              renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));\n          };\n      });\n  });\n  // target-agnostic transform used for both Client and SSR\n  function processFor(node, dir, context, processCodegen) {\n      if (!dir.exp) {\n          context.onError(createCompilerError(30 /* X_V_FOR_NO_EXPRESSION */, dir.loc));\n          return;\n      }\n      const parseResult = parseForExpression(\n      // can only be simple expression because vFor transform is applied\n      // before expression transform.\n      dir.exp, context);\n      if (!parseResult) {\n          context.onError(createCompilerError(31 /* X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));\n          return;\n      }\n      const { addIdentifiers, removeIdentifiers, scopes } = context;\n      const { source, value, key, index } = parseResult;\n      const forNode = {\n          type: 11 /* FOR */,\n          loc: dir.loc,\n          source,\n          valueAlias: value,\n          keyAlias: key,\n          objectIndexAlias: index,\n          parseResult,\n          children: isTemplateNode(node) ? node.children : [node]\n      };\n      context.replaceNode(forNode);\n      // bookkeeping\n      scopes.vFor++;\n      const onExit = processCodegen && processCodegen(forNode);\n      return () => {\n          scopes.vFor--;\n          if (onExit)\n              onExit();\n      };\n  }\n  const forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  // This regex doesn\'t cover the case if key or index aliases have destructuring,\n  // but those do not make sense in the first place, so this works in practice.\n  const forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  const stripParensRE = /^\\(|\\)$/g;\n  function parseForExpression(input, context) {\n      const loc = input.loc;\n      const exp = input.content;\n      const inMatch = exp.match(forAliasRE);\n      if (!inMatch)\n          return;\n      const [, LHS, RHS] = inMatch;\n      const result = {\n          source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),\n          value: undefined,\n          key: undefined,\n          index: undefined\n      };\n      {\n          validateBrowserExpression(result.source, context);\n      }\n      let valueContent = LHS.trim()\n          .replace(stripParensRE, \'\')\n          .trim();\n      const trimmedOffset = LHS.indexOf(valueContent);\n      const iteratorMatch = valueContent.match(forIteratorRE);\n      if (iteratorMatch) {\n          valueContent = valueContent.replace(forIteratorRE, \'\').trim();\n          const keyContent = iteratorMatch[1].trim();\n          let keyOffset;\n          if (keyContent) {\n              keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);\n              result.key = createAliasExpression(loc, keyContent, keyOffset);\n              {\n                  validateBrowserExpression(result.key, context, true);\n              }\n          }\n          if (iteratorMatch[2]) {\n              const indexContent = iteratorMatch[2].trim();\n              if (indexContent) {\n                  result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key\n                      ? keyOffset + keyContent.length\n                      : trimmedOffset + valueContent.length));\n                  {\n                      validateBrowserExpression(result.index, context, true);\n                  }\n              }\n          }\n      }\n      if (valueContent) {\n          result.value = createAliasExpression(loc, valueContent, trimmedOffset);\n          {\n              validateBrowserExpression(result.value, context, true);\n          }\n      }\n      return result;\n  }\n  function createAliasExpression(range, content, offset) {\n      return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));\n  }\n  function createForLoopParams({ value, key, index }) {\n      const params = [];\n      if (value) {\n          params.push(value);\n      }\n      if (key) {\n          if (!value) {\n              params.push(createSimpleExpression(`_`, false));\n          }\n          params.push(key);\n      }\n      if (index) {\n          if (!key) {\n              if (!value) {\n                  params.push(createSimpleExpression(`_`, false));\n              }\n              params.push(createSimpleExpression(`__`, false));\n          }\n          params.push(index);\n      }\n      return params;\n  }\n\n  const defaultFallback = createSimpleExpression(`undefined`, false);\n  // A NodeTransform that:\n  // 1. Tracks scope identifiers for scoped slots so that they don\'t get prefixed\n  //    by transformExpression. This is only applied in non-browser builds with\n  //    { prefixIdentifiers: true }.\n  // 2. Track v-slot depths so that we know a slot is inside another slot.\n  //    Note the exit callback is executed before buildSlots() on the same node,\n  //    so only nested slots see positive numbers.\n  const trackSlotScopes = (node, context) => {\n      if (node.type === 1 /* ELEMENT */ &&\n          (node.tagType === 1 /* COMPONENT */ ||\n              node.tagType === 3 /* TEMPLATE */)) {\n          // We are only checking non-empty v-slot here\n          // since we only care about slots that introduce scope variables.\n          const vSlot = findDir(node, \'slot\');\n          if (vSlot) {\n              const slotProps = vSlot.exp;\n              context.scopes.vSlot++;\n              return () => {\n                  context.scopes.vSlot--;\n              };\n          }\n      }\n  };\n  const buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);\n  // Instead of being a DirectiveTransform, v-slot processing is called during\n  // transformElement to build the slots object for a component.\n  function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {\n      context.helper(WITH_CTX);\n      const { children, loc } = node;\n      const slotsProperties = [];\n      const dynamicSlots = [];\n      const buildDefaultSlotProperty = (props, children) => createObjectProperty(`default`, buildSlotFn(props, children, loc));\n      // If the slot is inside a v-for or another v-slot, force it to be dynamic\n      // since it likely uses a scope variable.\n      let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;\n      // 1. Check for slot with slotProps on component itself.\n      //    <Comp v-slot="{ prop }"/>\n      const onComponentSlot = findDir(node, \'slot\', true);\n      if (onComponentSlot) {\n          const { arg, exp } = onComponentSlot;\n          if (arg && !isStaticExp(arg)) {\n              hasDynamicSlots = true;\n          }\n          slotsProperties.push(createObjectProperty(arg || createSimpleExpression(\'default\', true), buildSlotFn(exp, children, loc)));\n      }\n      // 2. Iterate through children and check for template slots\n      //    <template v-slot:foo="{ prop }">\n      let hasTemplateSlots = false;\n      let hasNamedDefaultSlot = false;\n      const implicitDefaultChildren = [];\n      const seenSlotNames = new Set();\n      for (let i = 0; i < children.length; i++) {\n          const slotElement = children[i];\n          let slotDir;\n          if (!isTemplateNode(slotElement) ||\n              !(slotDir = findDir(slotElement, \'slot\', true))) {\n              // not a <template v-slot>, skip.\n              if (slotElement.type !== 3 /* COMMENT */) {\n                  implicitDefaultChildren.push(slotElement);\n              }\n              continue;\n          }\n          if (onComponentSlot) {\n              // already has on-component slot - this is incorrect usage.\n              context.onError(createCompilerError(36 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));\n              break;\n          }\n          hasTemplateSlots = true;\n          const { children: slotChildren, loc: slotLoc } = slotElement;\n          const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;\n          // check if name is dynamic.\n          let staticSlotName;\n          if (isStaticExp(slotName)) {\n              staticSlotName = slotName ? slotName.content : `default`;\n          }\n          else {\n              hasDynamicSlots = true;\n          }\n          const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);\n          // check if this slot is conditional (v-if/v-for)\n          let vIf;\n          let vElse;\n          let vFor;\n          if ((vIf = findDir(slotElement, \'if\'))) {\n              hasDynamicSlots = true;\n              dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));\n          }\n          else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {\n              // find adjacent v-if\n              let j = i;\n              let prev;\n              while (j--) {\n                  prev = children[j];\n                  if (prev.type !== 3 /* COMMENT */) {\n                      break;\n                  }\n              }\n              if (prev && isTemplateNode(prev) && findDir(prev, \'if\')) {\n                  // remove node\n                  children.splice(i, 1);\n                  i--;\n                  // attach this slot to previous conditional\n                  let conditional = dynamicSlots[dynamicSlots.length - 1];\n                  while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\n                      conditional = conditional.alternate;\n                  }\n                  conditional.alternate = vElse.exp\n                      ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)\n                      : buildDynamicSlot(slotName, slotFunction);\n              }\n              else {\n                  context.onError(createCompilerError(29 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));\n              }\n          }\n          else if ((vFor = findDir(slotElement, \'for\'))) {\n              hasDynamicSlots = true;\n              const parseResult = vFor.parseResult ||\n                  parseForExpression(vFor.exp, context);\n              if (parseResult) {\n                  // Render the dynamic slots as an array and add it to the createSlot()\n                  // args. The runtime knows how to handle it appropriately.\n                  dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [\n                      parseResult.source,\n                      createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)\n                  ]));\n              }\n              else {\n                  context.onError(createCompilerError(31 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));\n              }\n          }\n          else {\n              // check duplicate static names\n              if (staticSlotName) {\n                  if (seenSlotNames.has(staticSlotName)) {\n                      context.onError(createCompilerError(37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));\n                      continue;\n                  }\n                  seenSlotNames.add(staticSlotName);\n                  if (staticSlotName === \'default\') {\n                      hasNamedDefaultSlot = true;\n                  }\n              }\n              slotsProperties.push(createObjectProperty(slotName, slotFunction));\n          }\n      }\n      if (!onComponentSlot) {\n          if (!hasTemplateSlots) {\n              // implicit default slot (on component)\n              slotsProperties.push(buildDefaultSlotProperty(undefined, children));\n          }\n          else if (implicitDefaultChildren.length) {\n              // implicit default slot (mixed with named slots)\n              if (hasNamedDefaultSlot) {\n                  context.onError(createCompilerError(38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));\n              }\n              else {\n                  slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));\n              }\n          }\n      }\n      const slotFlag = hasDynamicSlots\n          ? 2 /* DYNAMIC */\n          : hasForwardedSlots(node.children)\n              ? 3 /* FORWARDED */\n              : 1 /* STABLE */;\n      let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, \n      // 2 = compiled but dynamic = can skip normalization, but must run diff\n      // 1 = compiled and static = can skip normalization AND diff as optimized\n      createSimpleExpression(\'\' + slotFlag, false))), loc);\n      if (dynamicSlots.length) {\n          slots = createCallExpression(context.helper(CREATE_SLOTS), [\n              slots,\n              createArrayExpression(dynamicSlots)\n          ]);\n      }\n      return {\n          slots,\n          hasDynamicSlots\n      };\n  }\n  function buildDynamicSlot(name, fn) {\n      return createObjectExpression([\n          createObjectProperty(`name`, name),\n          createObjectProperty(`fn`, fn)\n      ]);\n  }\n  function hasForwardedSlots(children) {\n      for (let i = 0; i < children.length; i++) {\n          const child = children[i];\n          if (child.type === 1 /* ELEMENT */) {\n              if (child.tagType === 2 /* SLOT */ ||\n                  (child.tagType === 0 /* ELEMENT */ &&\n                      hasForwardedSlots(child.children))) {\n                  return true;\n              }\n          }\n      }\n      return false;\n  }\n\n  // some directive transforms (e.g. v-model) may return a symbol for runtime\n  // import, which should be used instead of a resolveDirective call.\n  const directiveImportMap = new WeakMap();\n  // generate a JavaScript AST for this element\'s codegen\n  const transformElement = (node, context) => {\n      if (!(node.type === 1 /* ELEMENT */ &&\n          (node.tagType === 0 /* ELEMENT */ ||\n              node.tagType === 1 /* COMPONENT */))) {\n          return;\n      }\n      // perform the work on exit, after all child expressions have been\n      // processed and merged.\n      return function postTransformElement() {\n          const { tag, props } = node;\n          const isComponent = node.tagType === 1 /* COMPONENT */;\n          // The goal of the transform is to create a codegenNode implementing the\n          // VNodeCall interface.\n          const vnodeTag = isComponent\n              ? resolveComponentType(node, context)\n              : `"${tag}"`;\n          const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;\n          let vnodeProps;\n          let vnodeChildren;\n          let vnodePatchFlag;\n          let patchFlag = 0;\n          let vnodeDynamicProps;\n          let dynamicPropNames;\n          let vnodeDirectives;\n          let shouldUseBlock = \n          // dynamic component may resolve to plain elements\n          isDynamicComponent ||\n              vnodeTag === TELEPORT ||\n              vnodeTag === SUSPENSE ||\n              (!isComponent &&\n                  // <svg> and <foreignObject> must be forced into blocks so that block\n                  // updates inside get proper isSVG flag at runtime. (#639, #643)\n                  // This is technically web-specific, but splitting the logic out of core\n                  // leads to too much unnecessary complexity.\n                  (tag === \'svg\' ||\n                      tag === \'foreignObject\' ||\n                      // #938: elements with dynamic keys should be forced into blocks\n                      findProp(node, \'key\', true)));\n          // props\n          if (props.length > 0) {\n              const propsBuildResult = buildProps(node, context);\n              vnodeProps = propsBuildResult.props;\n              patchFlag = propsBuildResult.patchFlag;\n              dynamicPropNames = propsBuildResult.dynamicPropNames;\n              const directives = propsBuildResult.directives;\n              vnodeDirectives =\n                  directives && directives.length\n                      ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))\n                      : undefined;\n          }\n          // children\n          if (node.children.length > 0) {\n              if (vnodeTag === KEEP_ALIVE) {\n                  // Although a built-in component, we compile KeepAlive with raw children\n                  // instead of slot functions so that it can be used inside Transition\n                  // or other Transition-wrapping HOCs.\n                  // To ensure correct updates with block optimizations, we need to:\n                  // 1. Force keep-alive into a block. This avoids its children being\n                  //    collected by a parent block.\n                  shouldUseBlock = true;\n                  // 2. Force keep-alive to always be updated, since it uses raw children.\n                  patchFlag |= 1024 /* DYNAMIC_SLOTS */;\n                  if ( node.children.length > 1) {\n                      context.onError(createCompilerError(44 /* X_KEEP_ALIVE_INVALID_CHILDREN */, {\n                          start: node.children[0].loc.start,\n                          end: node.children[node.children.length - 1].loc.end,\n                          source: \'\'\n                      }));\n                  }\n              }\n              const shouldBuildAsSlots = isComponent &&\n                  // Teleport is not a real component and has dedicated runtime handling\n                  vnodeTag !== TELEPORT &&\n                  // explained above.\n                  vnodeTag !== KEEP_ALIVE;\n              if (shouldBuildAsSlots) {\n                  const { slots, hasDynamicSlots } = buildSlots(node, context);\n                  vnodeChildren = slots;\n                  if (hasDynamicSlots) {\n                      patchFlag |= 1024 /* DYNAMIC_SLOTS */;\n                  }\n              }\n              else if (node.children.length === 1 && vnodeTag !== TELEPORT) {\n                  const child = node.children[0];\n                  const type = child.type;\n                  // check for dynamic text children\n                  const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||\n                      type === 8 /* COMPOUND_EXPRESSION */;\n                  if (hasDynamicTextChild && !getStaticType(child)) {\n                      patchFlag |= 1 /* TEXT */;\n                  }\n                  // pass directly if the only child is a text node\n                  // (plain / interpolation / expression)\n                  if (hasDynamicTextChild || type === 2 /* TEXT */) {\n                      vnodeChildren = child;\n                  }\n                  else {\n                      vnodeChildren = node.children;\n                  }\n              }\n              else {\n                  vnodeChildren = node.children;\n              }\n          }\n          // patchFlag & dynamicPropNames\n          if (patchFlag !== 0) {\n              {\n                  if (patchFlag < 0) {\n                      // special flags (negative and mutually exclusive)\n                      vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;\n                  }\n                  else {\n                      // bitwise flags\n                      const flagNames = Object.keys(PatchFlagNames)\n                          .map(Number)\n                          .filter(n => n > 0 && patchFlag & n)\n                          .map(n => PatchFlagNames[n])\n                          .join(`, `);\n                      vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;\n                  }\n              }\n              if (dynamicPropNames && dynamicPropNames.length) {\n                  vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);\n              }\n          }\n          node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, node.loc);\n      };\n  };\n  function resolveComponentType(node, context, ssr = false) {\n      const { tag } = node;\n      // 1. dynamic component\n      const isProp = node.tag === \'component\' ? findProp(node, \'is\') : findDir(node, \'is\');\n      if (isProp) {\n          const exp = isProp.type === 6 /* ATTRIBUTE */\n              ? isProp.value && createSimpleExpression(isProp.value.content, true)\n              : isProp.exp;\n          if (exp) {\n              return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\n                  exp\n              ]);\n          }\n      }\n      // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)\n      const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);\n      if (builtIn) {\n          // built-ins are simply fallthroughs / have special handling during ssr\n          // no we don\'t need to import their runtime equivalents\n          if (!ssr)\n              context.helper(builtIn);\n          return builtIn;\n      }\n      // 3. user component (from setup bindings)\n      if (context.bindingMetadata[tag] === \'setup\') {\n          return `$setup[${JSON.stringify(tag)}]`;\n      }\n      // 4. user component (resolve)\n      context.helper(RESOLVE_COMPONENT);\n      context.components.add(tag);\n      return toValidAssetId(tag, `component`);\n  }\n  function buildProps(node, context, props = node.props, ssr = false) {\n      const { tag, loc: elementLoc } = node;\n      const isComponent = node.tagType === 1 /* COMPONENT */;\n      let properties = [];\n      const mergeArgs = [];\n      const runtimeDirectives = [];\n      // patchFlag analysis\n      let patchFlag = 0;\n      let hasRef = false;\n      let hasClassBinding = false;\n      let hasStyleBinding = false;\n      let hasHydrationEventBinding = false;\n      let hasDynamicKeys = false;\n      let hasVnodeHook = false;\n      const dynamicPropNames = [];\n      const analyzePatchFlag = ({ key, value }) => {\n          if (isStaticExp(key)) {\n              const name = key.content;\n              const isEventHandler = isOn(name);\n              if (!isComponent &&\n                  isEventHandler &&\n                  // omit the flag for click handlers because hydration gives click\n                  // dedicated fast path.\n                  name.toLowerCase() !== \'onclick\' &&\n                  // omit v-model handlers\n                  name !== \'onUpdate:modelValue\' &&\n                  // omit onVnodeXXX hooks\n                  !isReservedProp(name)) {\n                  hasHydrationEventBinding = true;\n              }\n              if (isEventHandler && isReservedProp(name)) {\n                  hasVnodeHook = true;\n              }\n              if (value.type === 20 /* JS_CACHE_EXPRESSION */ ||\n                  ((value.type === 4 /* SIMPLE_EXPRESSION */ ||\n                      value.type === 8 /* COMPOUND_EXPRESSION */) &&\n                      getStaticType(value) > 0)) {\n                  // skip if the prop is a cached handler or has constant value\n                  return;\n              }\n              if (name === \'ref\') {\n                  hasRef = true;\n              }\n              else if (name === \'class\' && !isComponent) {\n                  hasClassBinding = true;\n              }\n              else if (name === \'style\' && !isComponent) {\n                  hasStyleBinding = true;\n              }\n              else if (name !== \'key\' && !dynamicPropNames.includes(name)) {\n                  dynamicPropNames.push(name);\n              }\n          }\n          else {\n              hasDynamicKeys = true;\n          }\n      };\n      for (let i = 0; i < props.length; i++) {\n          // static attribute\n          const prop = props[i];\n          if (prop.type === 6 /* ATTRIBUTE */) {\n              const { loc, name, value } = prop;\n              if (name === \'ref\') {\n                  hasRef = true;\n              }\n              // skip :is on <component>\n              if (name === \'is\' && tag === \'component\') {\n                  continue;\n              }\n              properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : \'\', true, value ? value.loc : loc)));\n          }\n          else {\n              // directives\n              const { name, arg, exp, loc } = prop;\n              const isBind = name === \'bind\';\n              const isOn = name === \'on\';\n              // skip v-slot - it is handled by its dedicated transform.\n              if (name === \'slot\') {\n                  if (!isComponent) {\n                      context.onError(createCompilerError(39 /* X_V_SLOT_MISPLACED */, loc));\n                  }\n                  continue;\n              }\n              // skip v-once - it is handled by its dedicated transform.\n              if (name === \'once\') {\n                  continue;\n              }\n              // skip v-is and :is on <component>\n              if (name === \'is\' ||\n                  (isBind && tag === \'component\' && isBindKey(arg, \'is\'))) {\n                  continue;\n              }\n              // skip v-on in SSR compilation\n              if (isOn && ssr) {\n                  continue;\n              }\n              // special case for v-bind and v-on with no argument\n              if (!arg && (isBind || isOn)) {\n                  hasDynamicKeys = true;\n                  if (exp) {\n                      if (properties.length) {\n                          mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\n                          properties = [];\n                      }\n                      if (isBind) {\n                          mergeArgs.push(exp);\n                      }\n                      else {\n                          // v-on="obj" -> toHandlers(obj)\n                          mergeArgs.push({\n                              type: 14 /* JS_CALL_EXPRESSION */,\n                              loc,\n                              callee: context.helper(TO_HANDLERS),\n                              arguments: [exp]\n                          });\n                      }\n                  }\n                  else {\n                      context.onError(createCompilerError(isBind\n                          ? 33 /* X_V_BIND_NO_EXPRESSION */\n                          : 34 /* X_V_ON_NO_EXPRESSION */, loc));\n                  }\n                  continue;\n              }\n              const directiveTransform = context.directiveTransforms[name];\n              if (directiveTransform) {\n                  // has built-in directive transform.\n                  const { props, needRuntime } = directiveTransform(prop, node, context);\n                  !ssr && props.forEach(analyzePatchFlag);\n                  properties.push(...props);\n                  if (needRuntime) {\n                      runtimeDirectives.push(prop);\n                      if (isSymbol(needRuntime)) {\n                          directiveImportMap.set(prop, needRuntime);\n                      }\n                  }\n              }\n              else {\n                  // no built-in transform, this is a user custom directive.\n                  runtimeDirectives.push(prop);\n              }\n          }\n      }\n      let propsExpression = undefined;\n      // has v-bind="object" or v-on="object", wrap with mergeProps\n      if (mergeArgs.length) {\n          if (properties.length) {\n              mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\n          }\n          if (mergeArgs.length > 1) {\n              propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);\n          }\n          else {\n              // single v-bind with nothing else - no need for a mergeProps call\n              propsExpression = mergeArgs[0];\n          }\n      }\n      else if (properties.length) {\n          propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);\n      }\n      // patchFlag analysis\n      if (hasDynamicKeys) {\n          patchFlag |= 16 /* FULL_PROPS */;\n      }\n      else {\n          if (hasClassBinding) {\n              patchFlag |= 2 /* CLASS */;\n          }\n          if (hasStyleBinding) {\n              patchFlag |= 4 /* STYLE */;\n          }\n          if (dynamicPropNames.length) {\n              patchFlag |= 8 /* PROPS */;\n          }\n          if (hasHydrationEventBinding) {\n              patchFlag |= 32 /* HYDRATE_EVENTS */;\n          }\n      }\n      if ((patchFlag === 0 || patchFlag === 32 /* HYDRATE_EVENTS */) &&\n          (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {\n          patchFlag |= 512 /* NEED_PATCH */;\n      }\n      return {\n          props: propsExpression,\n          directives: runtimeDirectives,\n          patchFlag,\n          dynamicPropNames\n      };\n  }\n  // Dedupe props in an object literal.\n  // Literal duplicated attributes would have been warned during the parse phase,\n  // however, it\'s possible to encounter duplicated `onXXX` handlers with different\n  // modifiers. We also need to merge static and dynamic class / style attributes.\n  // - onXXX handlers / style: merge into array\n  // - class: merge into single expression with concatenation\n  function dedupeProperties(properties) {\n      const knownProps = new Map();\n      const deduped = [];\n      for (let i = 0; i < properties.length; i++) {\n          const prop = properties[i];\n          // dynamic keys are always allowed\n          if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {\n              deduped.push(prop);\n              continue;\n          }\n          const name = prop.key.content;\n          const existing = knownProps.get(name);\n          if (existing) {\n              if (name === \'style\' || name === \'class\' || name.startsWith(\'on\')) {\n                  mergeAsArray(existing, prop);\n              }\n              // unexpected duplicate, should have emitted error during parse\n          }\n          else {\n              knownProps.set(name, prop);\n              deduped.push(prop);\n          }\n      }\n      return deduped;\n  }\n  function mergeAsArray(existing, incoming) {\n      if (existing.value.type === 17 /* JS_ARRAY_EXPRESSION */) {\n          existing.value.elements.push(incoming.value);\n      }\n      else {\n          existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);\n      }\n  }\n  function buildDirectiveArgs(dir, context) {\n      const dirArgs = [];\n      const runtime = directiveImportMap.get(dir);\n      if (runtime) {\n          dirArgs.push(context.helperString(runtime));\n      }\n      else {\n          // inject statement for resolving directive\n          context.helper(RESOLVE_DIRECTIVE);\n          context.directives.add(dir.name);\n          dirArgs.push(toValidAssetId(dir.name, `directive`));\n      }\n      const { loc } = dir;\n      if (dir.exp)\n          dirArgs.push(dir.exp);\n      if (dir.arg) {\n          if (!dir.exp) {\n              dirArgs.push(`void 0`);\n          }\n          dirArgs.push(dir.arg);\n      }\n      if (Object.keys(dir.modifiers).length) {\n          if (!dir.arg) {\n              if (!dir.exp) {\n                  dirArgs.push(`void 0`);\n              }\n              dirArgs.push(`void 0`);\n          }\n          const trueExpression = createSimpleExpression(`true`, false, loc);\n          dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));\n      }\n      return createArrayExpression(dirArgs, dir.loc);\n  }\n  function stringifyDynamicPropNames(props) {\n      let propsNamesString = `[`;\n      for (let i = 0, l = props.length; i < l; i++) {\n          propsNamesString += JSON.stringify(props[i]);\n          if (i < l - 1)\n              propsNamesString += \', \';\n      }\n      return propsNamesString + `]`;\n  }\n\n  const transformSlotOutlet = (node, context) => {\n      if (isSlotOutlet(node)) {\n          const { children, loc } = node;\n          const { slotName, slotProps } = processSlotOutlet(node, context);\n          const slotArgs = [\n              context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,\n              slotName\n          ];\n          if (slotProps) {\n              slotArgs.push(slotProps);\n          }\n          if (children.length) {\n              if (!slotProps) {\n                  slotArgs.push(`{}`);\n              }\n              slotArgs.push(createFunctionExpression([], children, false, false, loc));\n          }\n          node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);\n      }\n  };\n  function processSlotOutlet(node, context) {\n      let slotName = `"default"`;\n      let slotProps = undefined;\n      // check for <slot name="xxx" OR :name="xxx" />\n      const name = findProp(node, \'name\');\n      if (name) {\n          if (name.type === 6 /* ATTRIBUTE */ && name.value) {\n              // static name\n              slotName = JSON.stringify(name.value.content);\n          }\n          else if (name.type === 7 /* DIRECTIVE */ && name.exp) {\n              // dynamic name\n              slotName = name.exp;\n          }\n      }\n      const propsWithoutName = name\n          ? node.props.filter(p => p !== name)\n          : node.props;\n      if (propsWithoutName.length > 0) {\n          const { props, directives } = buildProps(node, context, propsWithoutName);\n          slotProps = props;\n          if (directives.length) {\n              context.onError(createCompilerError(35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));\n          }\n      }\n      return {\n          slotName,\n          slotProps\n      };\n  }\n\n  const fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^\\s*function(?:\\s+[\\w$]+)?\\s*\\(/;\n  const transformOn = (dir, node, context, augmentor) => {\n      const { loc, modifiers, arg } = dir;\n      if (!dir.exp && !modifiers.length) {\n          context.onError(createCompilerError(34 /* X_V_ON_NO_EXPRESSION */, loc));\n      }\n      let eventName;\n      if (arg.type === 4 /* SIMPLE_EXPRESSION */) {\n          if (arg.isStatic) {\n              const rawName = arg.content;\n              // for all event listeners, auto convert it to camelCase. See issue #2249\n              eventName = createSimpleExpression(toHandlerKey(camelize(rawName)), true, arg.loc);\n          }\n          else {\n              // #2388\n              eventName = createCompoundExpression([\n                  `${context.helperString(TO_HANDLER_KEY)}(`,\n                  arg,\n                  `)`\n              ]);\n          }\n      }\n      else {\n          // already a compound expression.\n          eventName = arg;\n          eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);\n          eventName.children.push(`)`);\n      }\n      // handler processing\n      let exp = dir.exp;\n      if (exp && !exp.content.trim()) {\n          exp = undefined;\n      }\n      let isCacheable = context.cacheHandlers && !exp;\n      if (exp) {\n          const isMemberExp = isMemberExpression(exp.content);\n          const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));\n          const hasMultipleStatements = exp.content.includes(`;`);\n          {\n              validateBrowserExpression(exp, context, false, hasMultipleStatements);\n          }\n          if (isInlineStatement || (isCacheable && isMemberExp)) {\n              // wrap inline statement in a function expression\n              exp = createCompoundExpression([\n                  `${isInlineStatement ? `$event` : `(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,\n                  exp,\n                  hasMultipleStatements ? `}` : `)`\n              ]);\n          }\n      }\n      let ret = {\n          props: [\n              createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))\n          ]\n      };\n      // apply extended compiler augmentor\n      if (augmentor) {\n          ret = augmentor(ret);\n      }\n      if (isCacheable) {\n          // cache handlers so that it\'s always the same handler being passed down.\n          // this avoids unnecessary re-renders when users use inline handlers on\n          // components.\n          ret.props[0].value = context.cache(ret.props[0].value);\n      }\n      return ret;\n  };\n\n  // v-bind without arg is handled directly in ./transformElements.ts due to it affecting\n  // codegen for the entire props object. This transform here is only for v-bind\n  // *with* args.\n  const transformBind = (dir, node, context) => {\n      const { exp, modifiers, loc } = dir;\n      const arg = dir.arg;\n      if (arg.type !== 4 /* SIMPLE_EXPRESSION */) {\n          arg.children.unshift(`(`);\n          arg.children.push(`) || ""`);\n      }\n      else if (!arg.isStatic) {\n          arg.content = `${arg.content} || ""`;\n      }\n      // .prop is no longer necessary due to new patch behavior\n      // .sync is replaced by v-model:arg\n      if (modifiers.includes(\'camel\')) {\n          if (arg.type === 4 /* SIMPLE_EXPRESSION */) {\n              if (arg.isStatic) {\n                  arg.content = camelize(arg.content);\n              }\n              else {\n                  arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;\n              }\n          }\n          else {\n              arg.children.unshift(`${context.helperString(CAMELIZE)}(`);\n              arg.children.push(`)`);\n          }\n      }\n      if (!exp ||\n          (exp.type === 4 /* SIMPLE_EXPRESSION */ && !exp.content.trim())) {\n          context.onError(createCompilerError(33 /* X_V_BIND_NO_EXPRESSION */, loc));\n          return {\n              props: [createObjectProperty(arg, createSimpleExpression(\'\', true, loc))]\n          };\n      }\n      return {\n          props: [createObjectProperty(arg, exp)]\n      };\n  };\n\n  // Merge adjacent text nodes and expressions into a single expression\n  // e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\n  const transformText = (node, context) => {\n      if (node.type === 0 /* ROOT */ ||\n          node.type === 1 /* ELEMENT */ ||\n          node.type === 11 /* FOR */ ||\n          node.type === 10 /* IF_BRANCH */) {\n          // perform the transform on node exit so that all expressions have already\n          // been processed.\n          return () => {\n              const children = node.children;\n              let currentContainer = undefined;\n              let hasText = false;\n              for (let i = 0; i < children.length; i++) {\n                  const child = children[i];\n                  if (isText(child)) {\n                      hasText = true;\n                      for (let j = i + 1; j < children.length; j++) {\n                          const next = children[j];\n                          if (isText(next)) {\n                              if (!currentContainer) {\n                                  currentContainer = children[i] = {\n                                      type: 8 /* COMPOUND_EXPRESSION */,\n                                      loc: child.loc,\n                                      children: [child]\n                                  };\n                              }\n                              // merge adjacent text node into current\n                              currentContainer.children.push(` + `, next);\n                              children.splice(j, 1);\n                              j--;\n                          }\n                          else {\n                              currentContainer = undefined;\n                              break;\n                          }\n                      }\n                  }\n              }\n              if (!hasText ||\n                  // if this is a plain element with a single text child, leave it\n                  // as-is since the runtime has dedicated fast path for this by directly\n                  // setting textContent of the element.\n                  // for component root it\'s always normalized anyway.\n                  (children.length === 1 &&\n                      (node.type === 0 /* ROOT */ ||\n                          (node.type === 1 /* ELEMENT */ &&\n                              node.tagType === 0 /* ELEMENT */)))) {\n                  return;\n              }\n              // pre-convert text nodes into createTextVNode(text) calls to avoid\n              // runtime normalization.\n              for (let i = 0; i < children.length; i++) {\n                  const child = children[i];\n                  if (isText(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {\n                      const callArgs = [];\n                      // createTextVNode defaults to single whitespace, so if it is a\n                      // single space the code could be an empty call to save bytes.\n                      if (child.type !== 2 /* TEXT */ || child.content !== \' \') {\n                          callArgs.push(child);\n                      }\n                      // mark dynamic text with flag so it gets patched inside a block\n                      if (!context.ssr && child.type !== 2 /* TEXT */) {\n                          callArgs.push(`${1 /* TEXT */} /* ${PatchFlagNames[1 /* TEXT */]} */`);\n                      }\n                      children[i] = {\n                          type: 12 /* TEXT_CALL */,\n                          content: child,\n                          loc: child.loc,\n                          codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)\n                      };\n                  }\n              }\n          };\n      }\n  };\n\n  const seen = new WeakSet();\n  const transformOnce = (node, context) => {\n      if (node.type === 1 /* ELEMENT */ && findDir(node, \'once\', true)) {\n          if (seen.has(node)) {\n              return;\n          }\n          seen.add(node);\n          context.helper(SET_BLOCK_TRACKING);\n          return () => {\n              const cur = context.currentNode;\n              if (cur.codegenNode) {\n                  cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);\n              }\n          };\n      }\n  };\n\n  const transformModel = (dir, node, context) => {\n      const { exp, arg } = dir;\n      if (!exp) {\n          context.onError(createCompilerError(40 /* X_V_MODEL_NO_EXPRESSION */, dir.loc));\n          return createTransformProps();\n      }\n      const expString = exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : exp.loc.source;\n      if (!isMemberExpression(expString)) {\n          context.onError(createCompilerError(41 /* X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));\n          return createTransformProps();\n      }\n      const propName = arg ? arg : createSimpleExpression(\'modelValue\', true);\n      const eventName = arg\n          ? isStaticExp(arg)\n              ? `onUpdate:${arg.content}`\n              : createCompoundExpression([\'"onUpdate:" + \', arg])\n          : `onUpdate:modelValue`;\n      const props = [\n          // modelValue: foo\n          createObjectProperty(propName, dir.exp),\n          // "onUpdate:modelValue": $event => (foo = $event)\n          createObjectProperty(eventName, createCompoundExpression([`$event => (`, exp, ` = $event)`]))\n      ];\n      // modelModifiers: { foo: true, "bar-baz": true }\n      if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {\n          const modifiers = dir.modifiers\n              .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)\n              .join(`, `);\n          const modifiersKey = arg\n              ? isStaticExp(arg)\n                  ? `${arg.content}Modifiers`\n                  : createCompoundExpression([arg, \' + "Modifiers"\'])\n              : `modelModifiers`;\n          props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, true)));\n      }\n      return createTransformProps(props);\n  };\n  function createTransformProps(props = []) {\n      return { props };\n  }\n\n  function getBaseTransformPreset(prefixIdentifiers) {\n      return [\n          [\n              transformOnce,\n              transformIf,\n              transformFor,\n              ...(  [transformExpression]\n                      ),\n              transformSlotOutlet,\n              transformElement,\n              trackSlotScopes,\n              transformText\n          ],\n          {\n              on: transformOn,\n              bind: transformBind,\n              model: transformModel\n          }\n      ];\n  }\n  // we name it `baseCompile` so that higher order compilers like\n  // @vue/compiler-dom can export `compile` while re-exporting everything else.\n  function baseCompile(template, options = {}) {\n      const onError = options.onError || defaultOnError;\n      const isModuleMode = options.mode === \'module\';\n      /* istanbul ignore if */\n      {\n          if (options.prefixIdentifiers === true) {\n              onError(createCompilerError(45 /* X_PREFIX_ID_NOT_SUPPORTED */));\n          }\n          else if (isModuleMode) {\n              onError(createCompilerError(46 /* X_MODULE_MODE_NOT_SUPPORTED */));\n          }\n      }\n      const prefixIdentifiers = !true ;\n      if ( options.cacheHandlers) {\n          onError(createCompilerError(47 /* X_CACHE_HANDLER_NOT_SUPPORTED */));\n      }\n      if (options.scopeId && !isModuleMode) {\n          onError(createCompilerError(48 /* X_SCOPE_ID_NOT_SUPPORTED */));\n      }\n      const ast = isString(template) ? baseParse(template, options) : template;\n      const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();\n      transform(ast, extend({}, options, {\n          prefixIdentifiers,\n          nodeTransforms: [\n              ...nodeTransforms,\n              ...(options.nodeTransforms || []) // user transforms\n          ],\n          directiveTransforms: extend({}, directiveTransforms, options.directiveTransforms || {} // user transforms\n          )\n      }));\n      return generate(ast, extend({}, options, {\n          prefixIdentifiers\n      }));\n  }\n\n  const noopDirectiveTransform = () => ({ props: [] });\n\n  const V_MODEL_RADIO = Symbol( `vModelRadio` );\n  const V_MODEL_CHECKBOX = Symbol( `vModelCheckbox` );\n  const V_MODEL_TEXT = Symbol( `vModelText` );\n  const V_MODEL_SELECT = Symbol( `vModelSelect` );\n  const V_MODEL_DYNAMIC = Symbol( `vModelDynamic` );\n  const V_ON_WITH_MODIFIERS = Symbol( `vOnModifiersGuard` );\n  const V_ON_WITH_KEYS = Symbol( `vOnKeysGuard` );\n  const V_SHOW = Symbol( `vShow` );\n  const TRANSITION$1 = Symbol( `Transition` );\n  const TRANSITION_GROUP = Symbol( `TransitionGroup` );\n  registerRuntimeHelpers({\n      [V_MODEL_RADIO]: `vModelRadio`,\n      [V_MODEL_CHECKBOX]: `vModelCheckbox`,\n      [V_MODEL_TEXT]: `vModelText`,\n      [V_MODEL_SELECT]: `vModelSelect`,\n      [V_MODEL_DYNAMIC]: `vModelDynamic`,\n      [V_ON_WITH_MODIFIERS]: `withModifiers`,\n      [V_ON_WITH_KEYS]: `withKeys`,\n      [V_SHOW]: `vShow`,\n      [TRANSITION$1]: `Transition`,\n      [TRANSITION_GROUP]: `TransitionGroup`\n  });\n\n  /* eslint-disable no-restricted-globals */\n  let decoder;\n  function decodeHtmlBrowser(raw) {\n      (decoder || (decoder = document.createElement(\'div\'))).innerHTML = raw;\n      return decoder.textContent;\n  }\n\n  const isRawTextContainer = /*#__PURE__*/ makeMap(\'style,iframe,script,noscript\', true);\n  const parserOptions = {\n      isVoidTag,\n      isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),\n      isPreTag: tag => tag === \'pre\',\n      decodeEntities:  decodeHtmlBrowser ,\n      isBuiltInComponent: (tag) => {\n          if (isBuiltInType(tag, `Transition`)) {\n              return TRANSITION$1;\n          }\n          else if (isBuiltInType(tag, `TransitionGroup`)) {\n              return TRANSITION_GROUP;\n          }\n      },\n      // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\n      getNamespace(tag, parent) {\n          let ns = parent ? parent.ns : 0 /* HTML */;\n          if (parent && ns === 2 /* MATH_ML */) {\n              if (parent.tag === \'annotation-xml\') {\n                  if (tag === \'svg\') {\n                      return 1 /* SVG */;\n                  }\n                  if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&\n                      a.name === \'encoding\' &&\n                      a.value != null &&\n                      (a.value.content === \'text/html\' ||\n                          a.value.content === \'application/xhtml+xml\'))) {\n                      ns = 0 /* HTML */;\n                  }\n              }\n              else if (/^m(?:[ions]|text)$/.test(parent.tag) &&\n                  tag !== \'mglyph\' &&\n                  tag !== \'malignmark\') {\n                  ns = 0 /* HTML */;\n              }\n          }\n          else if (parent && ns === 1 /* SVG */) {\n              if (parent.tag === \'foreignObject\' ||\n                  parent.tag === \'desc\' ||\n                  parent.tag === \'title\') {\n                  ns = 0 /* HTML */;\n              }\n          }\n          if (ns === 0 /* HTML */) {\n              if (tag === \'svg\') {\n                  return 1 /* SVG */;\n              }\n              if (tag === \'math\') {\n                  return 2 /* MATH_ML */;\n              }\n          }\n          return ns;\n      },\n      // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\n      getTextMode({ tag, ns }) {\n          if (ns === 0 /* HTML */) {\n              if (tag === \'textarea\' || tag === \'title\') {\n                  return 1 /* RCDATA */;\n              }\n              if (isRawTextContainer(tag)) {\n                  return 2 /* RAWTEXT */;\n              }\n          }\n          return 0 /* DATA */;\n      }\n  };\n\n  // Parse inline CSS strings for static style attributes into an object.\n  // This is a NodeTransform since it works on the static `style` attribute and\n  // converts it into a dynamic equivalent:\n  // style="color: red" -> :style=\'{ "color": "red" }\'\n  // It is then processed by `transformElement` and included in the generated\n  // props.\n  const transformStyle = node => {\n      if (node.type === 1 /* ELEMENT */) {\n          node.props.forEach((p, i) => {\n              if (p.type === 6 /* ATTRIBUTE */ && p.name === \'style\' && p.value) {\n                  // replace p with an expression node\n                  node.props[i] = {\n                      type: 7 /* DIRECTIVE */,\n                      name: `bind`,\n                      arg: createSimpleExpression(`style`, true, p.loc),\n                      exp: parseInlineCSS(p.value.content, p.loc),\n                      modifiers: [],\n                      loc: p.loc\n                  };\n              }\n          });\n      }\n  };\n  const parseInlineCSS = (cssText, loc) => {\n      const normalized = parseStringStyle(cssText);\n      return createSimpleExpression(JSON.stringify(normalized), false, loc, true);\n  };\n\n  function createDOMCompilerError(code, loc) {\n      return createCompilerError(code, loc,  DOMErrorMessages );\n  }\n  const DOMErrorMessages = {\n      [49 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,\n      [50 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,\n      [51 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,\n      [52 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,\n      [53 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\n      [54 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,\n      [55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\n      [56 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model\'s behavior.`,\n      [57 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,\n      [58 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,\n      [59 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<\script> and <style>) are ignored in client component templates.`\n  };\n\n  const transformVHtml = (dir, node, context) => {\n      const { exp, loc } = dir;\n      if (!exp) {\n          context.onError(createDOMCompilerError(49 /* X_V_HTML_NO_EXPRESSION */, loc));\n      }\n      if (node.children.length) {\n          context.onError(createDOMCompilerError(50 /* X_V_HTML_WITH_CHILDREN */, loc));\n          node.children.length = 0;\n      }\n      return {\n          props: [\n              createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression(\'\', true))\n          ]\n      };\n  };\n\n  const transformVText = (dir, node, context) => {\n      const { exp, loc } = dir;\n      if (!exp) {\n          context.onError(createDOMCompilerError(51 /* X_V_TEXT_NO_EXPRESSION */, loc));\n      }\n      if (node.children.length) {\n          context.onError(createDOMCompilerError(52 /* X_V_TEXT_WITH_CHILDREN */, loc));\n          node.children.length = 0;\n      }\n      return {\n          props: [\n              createObjectProperty(createSimpleExpression(`textContent`, true), exp\n                  ? createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc)\n                  : createSimpleExpression(\'\', true))\n          ]\n      };\n  };\n\n  const transformModel$1 = (dir, node, context) => {\n      const baseResult = transformModel(dir, node, context);\n      // base transform has errors OR component v-model (only need props)\n      if (!baseResult.props.length || node.tagType === 1 /* COMPONENT */) {\n          return baseResult;\n      }\n      if (dir.arg) {\n          context.onError(createDOMCompilerError(54 /* X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));\n      }\n      function checkDuplicatedValue() {\n          const value = findProp(node, \'value\');\n          if (value) {\n              context.onError(createDOMCompilerError(56 /* X_V_MODEL_UNNECESSARY_VALUE */, value.loc));\n          }\n      }\n      const { tag } = node;\n      const isCustomElement = context.isCustomElement(tag);\n      if (tag === \'input\' ||\n          tag === \'textarea\' ||\n          tag === \'select\' ||\n          isCustomElement) {\n          let directiveToUse = V_MODEL_TEXT;\n          let isInvalidType = false;\n          if (tag === \'input\' || isCustomElement) {\n              const type = findProp(node, `type`);\n              if (type) {\n                  if (type.type === 7 /* DIRECTIVE */) {\n                      // :type="foo"\n                      directiveToUse = V_MODEL_DYNAMIC;\n                  }\n                  else if (type.value) {\n                      switch (type.value.content) {\n                          case \'radio\':\n                              directiveToUse = V_MODEL_RADIO;\n                              break;\n                          case \'checkbox\':\n                              directiveToUse = V_MODEL_CHECKBOX;\n                              break;\n                          case \'file\':\n                              isInvalidType = true;\n                              context.onError(createDOMCompilerError(55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));\n                              break;\n                          default:\n                              // text type\n                               checkDuplicatedValue();\n                              break;\n                      }\n                  }\n              }\n              else if (hasDynamicKeyVBind(node)) {\n                  // element has bindings with dynamic keys, which can possibly contain\n                  // "type".\n                  directiveToUse = V_MODEL_DYNAMIC;\n              }\n              else {\n                  // text type\n                   checkDuplicatedValue();\n              }\n          }\n          else if (tag === \'select\') {\n              directiveToUse = V_MODEL_SELECT;\n          }\n          else {\n              // textarea\n               checkDuplicatedValue();\n          }\n          // inject runtime directive\n          // by returning the helper symbol via needRuntime\n          // the import will replaced a resolveDirective call.\n          if (!isInvalidType) {\n              baseResult.needRuntime = context.helper(directiveToUse);\n          }\n      }\n      else {\n          context.onError(createDOMCompilerError(53 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));\n      }\n      // native vmodel doesn\'t need the `modelValue` props since they are also\n      // passed to the runtime as `binding.value`. removing it reduces code size.\n      baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* SIMPLE_EXPRESSION */ &&\n          p.key.content === \'modelValue\'));\n      return baseResult;\n  };\n\n  const isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`);\n  const isNonKeyModifier = /*#__PURE__*/ makeMap(\n  // event propagation management\n`stop,prevent,self,`   +\n      // system modifiers + exact\n      `ctrl,shift,alt,meta,exact,` +\n      // mouse\n      `middle`);\n  // left & right could be mouse or key modifiers based on event type\n  const maybeKeyModifier = /*#__PURE__*/ makeMap(\'left,right\');\n  const isKeyboardEvent = /*#__PURE__*/ makeMap(`onkeyup,onkeydown,onkeypress`, true);\n  const resolveModifiers = (key, modifiers) => {\n      const keyModifiers = [];\n      const nonKeyModifiers = [];\n      const eventOptionModifiers = [];\n      for (let i = 0; i < modifiers.length; i++) {\n          const modifier = modifiers[i];\n          if (isEventOptionModifier(modifier)) {\n              // eventOptionModifiers: modifiers for addEventListener() options,\n              // e.g. .passive & .capture\n              eventOptionModifiers.push(modifier);\n          }\n          else {\n              // runtimeModifiers: modifiers that needs runtime guards\n              if (maybeKeyModifier(modifier)) {\n                  if (isStaticExp(key)) {\n                      if (isKeyboardEvent(key.content)) {\n                          keyModifiers.push(modifier);\n                      }\n                      else {\n                          nonKeyModifiers.push(modifier);\n                      }\n                  }\n                  else {\n                      keyModifiers.push(modifier);\n                      nonKeyModifiers.push(modifier);\n                  }\n              }\n              else {\n                  if (isNonKeyModifier(modifier)) {\n                      nonKeyModifiers.push(modifier);\n                  }\n                  else {\n                      keyModifiers.push(modifier);\n                  }\n              }\n          }\n      }\n      return {\n          keyModifiers,\n          nonKeyModifiers,\n          eventOptionModifiers\n      };\n  };\n  const transformClick = (key, event) => {\n      const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === \'onclick\';\n      return isStaticClick\n          ? createSimpleExpression(event, true)\n          : key.type !== 4 /* SIMPLE_EXPRESSION */\n              ? createCompoundExpression([\n                  `(`,\n                  key,\n                  `) === "onClick" ? "${event}" : (`,\n                  key,\n                  `)`\n              ])\n              : key;\n  };\n  const transformOn$1 = (dir, node, context) => {\n      return transformOn(dir, node, context, baseResult => {\n          const { modifiers } = dir;\n          if (!modifiers.length)\n              return baseResult;\n          let { key, value: handlerExp } = baseResult.props[0];\n          const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers);\n          // normalize click.right and click.middle since they don\'t actually fire\n          if (nonKeyModifiers.includes(\'right\')) {\n              key = transformClick(key, `onContextmenu`);\n          }\n          if (nonKeyModifiers.includes(\'middle\')) {\n              key = transformClick(key, `onMouseup`);\n          }\n          if (nonKeyModifiers.length) {\n              handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\n                  handlerExp,\n                  JSON.stringify(nonKeyModifiers)\n              ]);\n          }\n          if (keyModifiers.length &&\n              // if event name is dynamic, always wrap with keys guard\n              (!isStaticExp(key) || isKeyboardEvent(key.content))) {\n              handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [\n                  handlerExp,\n                  JSON.stringify(keyModifiers)\n              ]);\n          }\n          if (eventOptionModifiers.length) {\n              const modifierPostfix = eventOptionModifiers.map(capitalize).join(\'\');\n              key = isStaticExp(key)\n                  ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)\n                  : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);\n          }\n          return {\n              props: [createObjectProperty(key, handlerExp)]\n          };\n      });\n  };\n\n  const transformShow = (dir, node, context) => {\n      const { exp, loc } = dir;\n      if (!exp) {\n          context.onError(createDOMCompilerError(57 /* X_V_SHOW_NO_EXPRESSION */, loc));\n      }\n      return {\n          props: [],\n          needRuntime: context.helper(V_SHOW)\n      };\n  };\n\n  const warnTransitionChildren = (node, context) => {\n      if (node.type === 1 /* ELEMENT */ &&\n          node.tagType === 1 /* COMPONENT */) {\n          const component = context.isBuiltInComponent(node.tag);\n          if (component === TRANSITION$1) {\n              return () => {\n                  if (node.children.length && hasMultipleChildren(node)) {\n                      context.onError(createDOMCompilerError(58 /* X_TRANSITION_INVALID_CHILDREN */, {\n                          start: node.children[0].loc.start,\n                          end: node.children[node.children.length - 1].loc.end,\n                          source: \'\'\n                      }));\n                  }\n              };\n          }\n      }\n  };\n  function hasMultipleChildren(node) {\n      // #1352 filter out potential comment nodes.\n      const children = (node.children = node.children.filter(c => c.type !== 3 /* COMMENT */));\n      const child = children[0];\n      return (children.length !== 1 ||\n          child.type === 11 /* FOR */ ||\n          (child.type === 9 /* IF */ && child.branches.some(hasMultipleChildren)));\n  }\n\n  const ignoreSideEffectTags = (node, context) => {\n      if (node.type === 1 /* ELEMENT */ &&\n          node.tagType === 0 /* ELEMENT */ &&\n          (node.tag === \'script\' || node.tag === \'style\')) {\n          context.onError(createDOMCompilerError(59 /* X_IGNORED_SIDE_EFFECT_TAG */, node.loc));\n          context.removeNode();\n      }\n  };\n\n  const DOMNodeTransforms = [\n      transformStyle,\n      ...( [warnTransitionChildren] )\n  ];\n  const DOMDirectiveTransforms = {\n      cloak: noopDirectiveTransform,\n      html: transformVHtml,\n      text: transformVText,\n      model: transformModel$1,\n      on: transformOn$1,\n      show: transformShow\n  };\n  function compile$1(template, options = {}) {\n      return baseCompile(template, extend({}, parserOptions, options, {\n          nodeTransforms: [\n              // ignore <\script> and <tag>\n              // this is not put inside DOMNodeTransforms because that list is used\n              // by compiler-ssr to generate vnode fallback branches\n              ignoreSideEffectTags,\n              ...DOMNodeTransforms,\n              ...(options.nodeTransforms || [])\n          ],\n          directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),\n          transformHoist:  null \n      }));\n  }\n\n  // This entry is the "full-build" that includes both the runtime\n   initDev();\n  const compileCache = Object.create(null);\n  function compileToFunction(template, options) {\n      if (!isString(template)) {\n          if (template.nodeType) {\n              template = template.innerHTML;\n          }\n          else {\n               warn(`invalid template option: `, template);\n              return NOOP;\n          }\n      }\n      const key = template;\n      const cached = compileCache[key];\n      if (cached) {\n          return cached;\n      }\n      if (template[0] === \'#\') {\n          const el = document.querySelector(template);\n          if ( !el) {\n              warn(`Template element not found or is empty: ${template}`);\n          }\n          // __UNSAFE__\n          // Reason: potential execution of JS expressions in in-DOM template.\n          // The user must make sure the in-DOM template is trusted. If it\'s rendered\n          // by the server, the template should not contain any user data.\n          template = el ? el.innerHTML : ``;\n      }\n      const { code } = compile$1(template, extend({\n          hoistStatic: true,\n          onError(err) {\n              {\n                  const message = `Template compilation error: ${err.message}`;\n                  const codeFrame = err.loc &&\n                      generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);\n                  warn(codeFrame ? `${message}\\n${codeFrame}` : message);\n              }\n          }\n      }, options));\n      // The wildcard import results in a huge object with every export\n      // with keys that cannot be mangled, and can be quite heavy size-wise.\n      // In the global build we know `Vue` is available globally so we can avoid\n      // the wildcard object.\n      const render = ( new Function(code)()\n          );\n      render._rc = true;\n      return (compileCache[key] = render);\n  }\n  registerRuntimeCompiler(compileToFunction);\n\n  exports.BaseTransition = BaseTransition;\n  exports.Comment = Comment;\n  exports.Fragment = Fragment;\n  exports.KeepAlive = KeepAlive;\n  exports.Static = Static;\n  exports.Suspense = Suspense;\n  exports.Teleport = Teleport;\n  exports.Text = Text;\n  exports.Transition = Transition;\n  exports.TransitionGroup = TransitionGroup;\n  exports.callWithAsyncErrorHandling = callWithAsyncErrorHandling;\n  exports.callWithErrorHandling = callWithErrorHandling;\n  exports.camelize = camelize;\n  exports.capitalize = capitalize;\n  exports.cloneVNode = cloneVNode;\n  exports.compile = compileToFunction;\n  exports.computed = computed$1;\n  exports.createApp = createApp;\n  exports.createBlock = createBlock;\n  exports.createCommentVNode = createCommentVNode;\n  exports.createHydrationRenderer = createHydrationRenderer;\n  exports.createRenderer = createRenderer;\n  exports.createSSRApp = createSSRApp;\n  exports.createSlots = createSlots;\n  exports.createStaticVNode = createStaticVNode;\n  exports.createTextVNode = createTextVNode;\n  exports.createVNode = createVNode;\n  exports.customRef = customRef;\n  exports.defineAsyncComponent = defineAsyncComponent;\n  exports.defineComponent = defineComponent;\n  exports.getCurrentInstance = getCurrentInstance;\n  exports.getTransitionRawChildren = getTransitionRawChildren;\n  exports.h = h;\n  exports.handleError = handleError;\n  exports.hydrate = hydrate;\n  exports.initCustomFormatter = initCustomFormatter;\n  exports.inject = inject;\n  exports.isProxy = isProxy;\n  exports.isReactive = isReactive;\n  exports.isReadonly = isReadonly;\n  exports.isRef = isRef;\n  exports.isVNode = isVNode;\n  exports.markRaw = markRaw;\n  exports.mergeProps = mergeProps;\n  exports.nextTick = nextTick;\n  exports.onActivated = onActivated;\n  exports.onBeforeMount = onBeforeMount;\n  exports.onBeforeUnmount = onBeforeUnmount;\n  exports.onBeforeUpdate = onBeforeUpdate;\n  exports.onDeactivated = onDeactivated;\n  exports.onErrorCaptured = onErrorCaptured;\n  exports.onMounted = onMounted;\n  exports.onRenderTracked = onRenderTracked;\n  exports.onRenderTriggered = onRenderTriggered;\n  exports.onUnmounted = onUnmounted;\n  exports.onUpdated = onUpdated;\n  exports.openBlock = openBlock;\n  exports.popScopeId = popScopeId;\n  exports.provide = provide;\n  exports.proxyRefs = proxyRefs;\n  exports.pushScopeId = pushScopeId;\n  exports.queuePostFlushCb = queuePostFlushCb;\n  exports.reactive = reactive;\n  exports.readonly = readonly;\n  exports.ref = ref;\n  exports.registerRuntimeCompiler = registerRuntimeCompiler;\n  exports.render = render;\n  exports.renderList = renderList;\n  exports.renderSlot = renderSlot;\n  exports.resolveComponent = resolveComponent;\n  exports.resolveDirective = resolveDirective;\n  exports.resolveDynamicComponent = resolveDynamicComponent;\n  exports.resolveTransitionHooks = resolveTransitionHooks;\n  exports.setBlockTracking = setBlockTracking;\n  exports.setDevtoolsHook = setDevtoolsHook;\n  exports.setTransitionHooks = setTransitionHooks;\n  exports.shallowReactive = shallowReactive;\n  exports.shallowReadonly = shallowReadonly;\n  exports.shallowRef = shallowRef;\n  exports.ssrContextKey = ssrContextKey;\n  exports.ssrUtils = ssrUtils;\n  exports.toDisplayString = toDisplayString;\n  exports.toHandlerKey = toHandlerKey;\n  exports.toHandlers = toHandlers;\n  exports.toRaw = toRaw;\n  exports.toRef = toRef;\n  exports.toRefs = toRefs;\n  exports.transformVNodeArgs = transformVNodeArgs;\n  exports.triggerRef = triggerRef;\n  exports.unref = unref;\n  exports.useCssModule = useCssModule;\n  exports.useCssVars = useCssVars;\n  exports.useSSRContext = useSSRContext;\n  exports.useTransitionState = useTransitionState;\n  exports.vModelCheckbox = vModelCheckbox;\n  exports.vModelDynamic = vModelDynamic;\n  exports.vModelRadio = vModelRadio;\n  exports.vModelSelect = vModelSelect;\n  exports.vModelText = vModelText;\n  exports.vShow = vShow;\n  exports.version = version;\n  exports.warn = warn;\n  exports.watch = watch;\n  exports.watchEffect = watchEffect;\n  exports.withCtx = withCtx;\n  exports.withDirectives = withDirectives;\n  exports.withKeys = withKeys;\n  exports.withModifiers = withModifiers;\n  exports.withScopeId = withScopeId;\n\n  return exports;\n\n}({}));';
